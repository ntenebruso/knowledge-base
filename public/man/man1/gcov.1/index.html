<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - gcov.1 | Technical Notes</title>

      <link rel="stylesheet" href="/css/main.min.a9ecaac9d4f7845fc2de4738f7709cab0bd1c3d19c3466fadd637a6987603257.css" integrity="sha256-qeyqydT3hF/C3kc493CcqwvRw9GcNGb63WN6aYdgMlc=" crossorigin="anonymous">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - gcov.1</h1>
    
<p>
\\</p>
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
NAME
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>gcov - coverage testing tool</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
SYNOPSIS
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p>gcov [*-v*|*–version*] [*-h*|*–help*] [*-a*|*–all-blocks*]
[*-b*|*–branch-probabilities*] [*-c*|*–branch-counts*]
[*-d*|*–display-progress*] [*-f*|*–function-summaries*]
[*-j*|*–json-format*] [*-H*|*–human-readable*] [*-k*|*–use-colors*]
[*-l*|*–long-file-names*] [*-m*|*–demangled-names*]
[*-n*|*–no-output*] [*-o*|*–object-directory* /directory|file/]
[*-p*|*–preserve-paths*] [*-q*|*–use-hotness-colors*]
[*-r*|*–relative-only*] [*-s*|*–source-prefix* /directory/]
[*-t*|*–stdout*] [*-u*|*–unconditional-branches*]
[*-x*|*–hash-filenames*] <em>files</em></p>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
DESCRIPTION
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p><strong>gcov</strong> is a test coverage program. Use it in concert with GCC to analyze
your programs to help create more efficient, faster running code and to
discover untested parts of your program. You can use <strong>gcov</strong> as a
profiling tool to help discover where your optimization efforts will
best affect your code. You can also use <strong>gcov</strong> along with the other
profiling tool, <strong>gprof</strong>, to assess which parts of your code use the
greatest amount of computing time.</p>
<p>
Profiling tools help you analyze your code&#39;s performance. Using a
profiler such as <strong>gcov</strong> or <strong>gprof</strong>, you can find out some basic
performance statistics, such as:</p>
<ul>
<li>how often each line of code executes</li>
<li>what lines of code are actually executed</li>
<li>how much computing time each section of code uses</li>
</ul>
<p>Once you know these things about how your code works when compiled, you
can look at each module to see which modules should be optimized. <strong>gcov</strong>
helps you determine where to work on optimization.</p>
<p>
Software developers also use coverage testing in concert with
testsuites, to make sure software is actually good enough for a release.
Testsuites can verify that a program works as expected; a coverage
program tests to see how much of the program is exercised by the
testsuite. Developers can then determine what kinds of test cases need
to be added to the testsuites to create both better testing and a better
final product.</p>
<p>
You should compile your code without optimization if you plan to use
<strong>gcov</strong> because the optimization, by combining some lines of code into
one function, may not give you as much information as you need to look
for `hot spots&#39; where the code is using a great deal of computer time.
Likewise, because <strong>gcov</strong> accumulates statistics by line (at the lowest
resolution), it works best with a programming style that places only one
statement on each line. If you use complicated macros that expand to
loops or to other control structures, the statistics are less
helpful—they only report on the line where the macro call appears. If
your complex macros behave like functions, you can replace them with
inline functions to solve this problem.</p>
<p>
<strong>gcov</strong> creates a logfile called <em>sourcefile.gcov</em> which indicates how
many times each line of a source file <em>sourcefile.c</em> has executed. You
can use these logfiles along with <strong>gprof</strong> to aid in fine-tuning the
performance of your programs. <strong>gprof</strong> gives timing information you can
use along with the information you get from <strong>gcov</strong>.</p>
<p>
<strong>gcov</strong> works only on code compiled with GCC. It is not compatible with
any other profiling or test coverage mechanism.</p>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
OPTIONS
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<dl>
<dt>
-a
</dt>
<dd></dd>
<dt>
–all-blocks
</dt>
<dd></dd>
</dl>
<p>Write individual execution counts for every basic block. Normally gcov
outputs execution counts only for the main blocks of a line. With this
option you can determine if blocks within a single line are not being
executed.</p>
<dl>
<dt>
-b
</dt>
<dd></dd>
<dt>
–branch-probabilities
</dt>
<dd></dd>
</dl>
<p>Write branch frequencies to the output file, and write branch summary
info to the standard output. This option allows you to see how often
each branch in your program was taken. Unconditional branches will not
be shown, unless the <strong>-u</strong> option is given.</p>
<dl>
<dt>
-c
</dt>
<dd></dd>
<dt>
–branch-counts
</dt>
<dd></dd>
</dl>
<p>Write branch frequencies as the number of branches taken, rather than
the percentage of branches taken.</p>
<dl>
<dt>
-d
</dt>
<dd></dd>
<dt>
–display-progress
</dt>
<dd></dd>
</dl>
<p>Display the progress on the standard output.</p>
<dl>
<dt>
-f
</dt>
<dd></dd>
<dt>
–function-summaries
</dt>
<dd></dd>
</dl>
<p>Output summaries for each function in addition to the file level
summary.</p>
<dl>
<dt>
-h
</dt>
<dd></dd>
<dt>
–help
</dt>
<dd></dd>
</dl>
<p>Display help about using <strong>gcov</strong> (on the standard output), and exit
without doing any further processing.</p>
<dl>
<dt>
-j
</dt>
<dd></dd>
<dt>
–json-format
</dt>
<dd></dd>
</dl>
<p>Output gcov file in an easy-to-parse JSON intermediate format which does
not require source code for generation. The JSON file is compressed with
gzip compression algorithm and the files have <em>.gcov.json.gz</em> extension.
Structure of the JSON is following: { &#34;current_working_directory&#34;:
&#34;foo/bar&#34;, &#34;data_file&#34;: &#34;a.out&#34;, &#34;format_version&#34;: &#34;1&#34;, &#34;gcc_version&#34;:
&#34;11.1.1 20210510&#34; &#34;files&#34;: [&#34;$file&#34;] } Fields of the root element have
following semantics:</p>
<blockquote>
<ul>
<li><em>current_working_directory</em>: working directory where a compilation
unit was compiled</li>
<li><em>data_file</em>: name of the data file (GCDA)</li>
<li><em>format_version</em>: semantic version of the format</li>
<li><em>gcc_version</em>: version of the GCC compiler</li>
</ul>
</blockquote>
<blockquote>
<p>Each <em>file</em> has the following form: { &#34;file&#34;: &#34;a.c&#34;, &#34;functions&#34;:
[&#34;$function&#34;], &#34;lines&#34;: [&#34;$line&#34;] } Fields of the <em>file</em> element have
following semantics:</p>
<ul>
<li><em>file_name</em>: name of the source file</li>
</ul>
</blockquote>
<blockquote>
<p>Each <em>function</em> has the following form: { &#34;blocks&#34;: 2,
&#34;blocks_executed&#34;: 2, &#34;demangled_name&#34;: &#34;foo&#34;, &#34;end_column&#34;: 1,
&#34;end_line&#34;: 4, &#34;execution_count&#34;: 1, &#34;name&#34;: &#34;foo&#34;, &#34;start_column&#34;: 5,
&#34;start_line&#34;: 1 } Fields of the <em>function</em> element have following
semantics:</p>
<ul>
<li><em>blocks</em>: number of blocks that are in the function</li>
<li><em>blocks_executed</em>: number of executed blocks of the function</li>
<li><em>demangled_name</em>: demangled name of the function</li>
<li><em>end_column</em>: column in the source file where the function ends</li>
<li><em>end_line</em>: line in the source file where the function ends</li>
<li><em>execution_count</em>: number of executions of the function</li>
<li><em>name</em>: name of the function</li>
<li><em>start_column</em>: column in the source file where the function begins</li>
<li><em>start_line</em>: line in the source file where the function begins</li>
</ul>
</blockquote>
<blockquote>
<p>Note that line numbers and column numbers number from 1. In the current
implementation, <em>start_line</em> and <em>start_column</em> do not include any
template parameters and the leading return type but that this is likely
to be fixed in the future. Each <em>line</em> has the following form: {
&#34;branches&#34;: [&#34;$branch&#34;], &#34;count&#34;: 2, &#34;line_number&#34;: 15,
&#34;unexecuted_block&#34;: false, &#34;function_name&#34;: &#34;foo&#34;, } Branches are
present only with <em>-b</em> option. Fields of the <em>line</em> element have
following semantics:</p>
<ul>
<li><em>count</em>: number of executions of the line</li>
<li><em>line_number</em>: line number</li>
<li><em>unexecuted_block</em>: flag whether the line contains an unexecuted block
(not all statements on the line are executed)</li>
<li><em>function_name</em>: a name of a function this <em>line</em> belongs to (for a
line with an inlined statements can be not set)</li>
</ul>
</blockquote>
<blockquote>
<p>Each <em>branch</em> has the following form: { &#34;count&#34;: 11, &#34;fallthrough&#34;:
true, &#34;throw&#34;: false } Fields of the <em>branch</em> element have following
semantics:</p>
<ul>
<li><em>count</em>: number of executions of the branch</li>
<li><em>fallthrough</em>: true when the branch is a fall through branch</li>
<li><em>throw</em>: true when the branch is an exceptional branch</li>
</ul>
</blockquote>
<blockquote>
</blockquote>
<dl>
<dt>
-H
</dt>
<dd></dd>
<dt>
–human-readable
</dt>
<dd></dd>
</dl>
<p>Write counts in human readable format (like 24.6k).</p>
<dl>
<dt>
-k
</dt>
<dd></dd>
<dt>
–use-colors
</dt>
<dd></dd>
</dl>
<p>Use colors for lines of code that have zero coverage. We use red color
for non-exceptional lines and cyan for exceptional. Same colors are used
for basic blocks with <strong>-a</strong> option.</p>
<dl>
<dt>
-l
</dt>
<dd></dd>
<dt>
–long-file-names
</dt>
<dd></dd>
</dl>
<p>Create long file names for included source files. For example, if the
header file <em>x.h</em> contains code, and was included in the file <em>a.c</em>,
then running <strong>gcov</strong> on the file <em>a.c</em> will produce an output file called
<em>a.c##x.h.gcov</em> instead of <em>x.h.gcov</em>. This can be useful if <em>x.h</em> is
included in multiple source files and you want to see the individual
contributions. If you use the <strong>-p</strong> option, both the including and
included file names will be complete path names.</p>
<dl>
<dt>
-m
</dt>
<dd></dd>
<dt>
–demangled-names
</dt>
<dd></dd>
</dl>
<p>Display demangled function names in output. The default is to show
mangled function names.</p>
<dl>
<dt>
-n
</dt>
<dd></dd>
<dt>
–no-output
</dt>
<dd></dd>
</dl>
<p>Do not create the <strong>gcov</strong> output file.</p>
<dl>
<dt>
-o directory|file
</dt>
<dd></dd>
<dt>
–object-directory directory
</dt>
<dd></dd>
<dt>
–object-file file
</dt>
<dd></dd>
</dl>
<p>Specify either the directory containing the gcov data files, or the
object path name. The <em>.gcno</em>, and <em>.gcda</em> data files are searched for
using this option. If a directory is specified, the data files are in
that directory and named after the input file name, without its
extension. If a file is specified here, the data files are named after
that file, without its extension.</p>
<dl>
<dt>
-p
</dt>
<dd></dd>
<dt>
–preserve-paths
</dt>
<dd></dd>
</dl>
<p>Preserve complete path information in the names of generated <em>.gcov</em>
files. Without this option, just the filename component is used. With
this option, all directories are used, with <strong>/</strong> characters translated to
<strong>#</strong> characters, <em>.</em> directory components removed and unremoveable <em>..</em>
components renamed to <strong>^</strong>. This is useful if sourcefiles are in several
different directories.</p>
<dl>
<dt>
-q
</dt>
<dd></dd>
<dt>
–use-hotness-colors
</dt>
<dd></dd>
</dl>
<p>Emit perf-like colored output for hot lines. Legend of the color scale
is printed at the very beginning of the output file.</p>
<dl>
<dt>
-r
</dt>
<dd></dd>
<dt>
–relative-only
</dt>
<dd></dd>
</dl>
<p>Only output information about source files with a relative pathname
(after source prefix elision). Absolute paths are usually system header
files and coverage of any inline functions therein is normally
uninteresting.</p>
<dl>
<dt>
-s directory
</dt>
<dd></dd>
<dt>
–source-prefix directory
</dt>
<dd></dd>
</dl>
<p>A prefix for source file names to remove when generating the output
coverage files. This option is useful when building in a separate
directory, and the pathname to the source directory is not wanted when
determining the output file names. Note that this prefix detection is
applied before determining whether the source file is absolute.</p>
<dl>
<dt>
-t
</dt>
<dd></dd>
<dt>
–stdout
</dt>
<dd></dd>
</dl>
<p>Output to standard output instead of output files.</p>
<dl>
<dt>
-u
</dt>
<dd></dd>
<dt>
–unconditional-branches
</dt>
<dd></dd>
</dl>
<p>When branch probabilities are given, include those of unconditional
branches. Unconditional branches are normally not interesting.</p>
<dl>
<dt>
-v
</dt>
<dd></dd>
<dt>
–version
</dt>
<dd></dd>
</dl>
<p>Display the <strong>gcov</strong> version number (on the standard output), and exit
without doing any further processing.</p>
<dl>
<dt>
-w
</dt>
<dd></dd>
<dt>
–verbose
</dt>
<dd></dd>
</dl>
<p>Print verbose informations related to basic blocks and arcs.</p>
<dl>
<dt>
-x
</dt>
<dd></dd>
<dt>
–hash-filenames
</dt>
<dd></dd>
</dl>
<p>When using <em>–preserve-paths</em>, gcov uses the full pathname of the source
files to create an output filename. This can lead to long filenames that
can overflow filesystem limits. This option creates names of the form
<em>source-file##md5.gcov</em>, where the <em>source-file</em> component is the final
filename part and the <em>md5</em> component is calculated from the full
mangled name that would have been used otherwise. The option is an
alternative to the <em>–preserve-paths</em> on systems which have a filesystem
limit.</p>
<p>
<strong>gcov</strong> should be run with the current directory the same as that when
you invoked the compiler. Otherwise it will not be able to locate the
source files. <strong>gcov</strong> produces files called <em>mangledname.gcov</em> in the
current directory. These contain the coverage information of the source
file they correspond to. One <em>.gcov</em> file is produced for each source
(or header) file containing code, which was compiled to produce the data
files. The <em>mangledname</em> part of the output file name is usually simply
the source file name, but can be something more complicated if the <strong>-l</strong>
or <strong>-p</strong> options are given. Refer to those options for details.</p>
<p>
If you invoke <strong>gcov</strong> with multiple input files, the contributions from
each input file are summed. Typically you would invoke it with the same
list of files as the final link of your executable.</p>
<p>
The <em>.gcov</em> files contain the <strong>:</strong> separated fields along with program
source code. The format is</p>
<p>
&lt;execution_count&gt;:&lt;line_number&gt;:&lt;source line text&gt;</p>
<p>
Additional block information may succeed each line, when requested by
command line option. The <em>execution_count</em> is <strong>-</strong> for lines containing
no code. Unexecuted lines are marked <strong>#####</strong> or <strong><code class="verbatim">===</code></strong>, depending on
whether they are reachable by non-exceptional paths or only exceptional
paths such as C++ exception handlers, respectively. Given the <strong>-a</strong>
option, unexecuted blocks are marked <strong>$$$$$</strong> or <strong>%%%%%</strong>, depending on
whether a basic block is reachable via non-exceptional or exceptional
paths. Executed basic blocks having a statement with zero
<em>execution_count</em> end with <strong>*</strong> character and are colored with magenta
color with the <strong>-k</strong> option. This functionality is not supported in Ada.</p>
<p>
Note that GCC can completely remove the bodies of functions that are not
needed Ω- for instance if they are inlined everywhere. Such functions
are marked with <strong>-</strong>, which can be confusing. Use the
<strong>-fkeep-inline-functions</strong> and <strong>-fkeep-static-functions</strong> options to
retain these functions and allow gcov to properly show their
<em>execution_count</em>.</p>
<p>
Some lines of information at the start have <em>line_number</em> of zero. These
preamble lines are of the form</p>
<p>
-:0:&lt;tag&gt;:&lt;value&gt;</p>
<p>
The ordering and number of these preamble lines will be augmented as
<strong>gcov</strong> development progresses — do not rely on them remaining
unchanged. Use <em>tag</em> to locate a particular preamble line.</p>
<p>
The additional block information is of the form</p>
<p>
&lt;tag&gt; &lt;information&gt;</p>
<p>
The <em>information</em> is human readable, but designed to be simple enough
for machine parsing too.</p>
<p>
When printing percentages, 0% and 100% are only printed when the values
are <em>exactly</em> 0% and 100% respectively. Other values which would
conventionally be rounded to 0% or 100% are instead printed as the
nearest non-boundary value.</p>
<p>
When using <strong>gcov</strong>, you must first compile your program with a special
GCC option <strong>–coverage</strong>. This tells the compiler to generate additional
information needed by gcov (basically a flow graph of the program) and
also includes additional code in the object files for generating the
extra profiling information needed by gcov. These additional files are
placed in the directory where the object file is located.</p>
<p>
Running the program will cause profile output to be generated. For each
source file compiled with <strong>-fprofile-arcs</strong>, an accompanying <em>.gcda</em> file
will be placed in the object file directory.</p>
<p>
Running <strong>gcov</strong> with your program&#39;s source file names as arguments will
now produce a listing of the code along with frequency of execution for
each line. For example, if your program is called <em>tmp.cpp</em>, this is
what you see when you use the basic <strong>gcov</strong> facility:</p>
<p>
$ g++ --coverage tmp.cpp -c $ g++ –coverage tmp.o $ a.out $ gcov
tmp.cpp -m File tmp.cpp Lines executed:92.86% of 14 Creating
tmp.cpp.gcov</p>
<p>
The file <em>tmp.cpp.gcov</em> contains output from <strong>gcov</strong>. Here is a sample:</p>
<p>
-: 0:Source:tmp.cpp -: 0:Working directory:/home/gcc/testcase -:
0:Graph:tmp.gcno -: 0:Data:tmp.gcda -: 0:Runs:1 -: 0:Programs:1 -:
1:#include &lt;stdio.h&gt; -: 2: -: 3:template&lt;class T&gt; -: 4:class Foo -: 5:{
-: 6: public: 1*: 7: Foo(): b (1000) {} ——————
Foo&lt;char&gt;::Foo(): #####: 7: Foo(): b (1000) {} ——————
Foo&lt;int&gt;::Foo(): 1: 7: Foo(): b (1000) {} —————— 2*: 8: void
inc () { b++; } —————— Foo&lt;char&gt;::inc(): #####: 8: void inc
() { b++; } —————— Foo&lt;int&gt;::inc(): 2: 8: void inc () { b++;
} —————— -: 9: -: 10: private: -: 11: int b; -: 12:}; -: 13:
-: 14:template class Foo&lt;int&gt;; -: 15:template class Foo&lt;char&gt;; -: 16: -:
17:int 1: 18:main (void) -: 19:{ -: 20: int i, total; 1: 21: Foo&lt;int&gt;
counter; -: 22: 1: 23: counter.inc(); 1: 24: counter.inc(); 1: 25: total
= 0; -: 26: 11: 27: for (i = 0; i &lt; 10; i++) 10: 28: total += i; -: 29:
1*: 30: int v = total &gt; 100 ? 1 : 2; -: 31: 1: 32: if (total != 45)
​#####: 33: printf (&#34;Failure\n&#34;); -: 34: else 1: 35: printf
(&#34;Success\n&#34;); 1: 36: return 0; -: 37:}</p>
<p>
Note that line 7 is shown in the report multiple times. First occurrence
presents total number of execution of the line and the next two belong
to instances of class Foo constructors. As you can also see, line 30
contains some unexecuted basic blocks and thus execution count has
asterisk symbol.</p>
<p>
When you use the <strong>-a</strong> option, you will get individual block counts, and
the output looks like this:</p>
<p>
-: 0:Source:tmp.cpp -: 0:Working directory:/home/gcc/testcase -:
0:Graph:tmp.gcno -: 0:Data:tmp.gcda -: 0:Runs:1 -: 0:Programs:1 -:
1:#include &lt;stdio.h&gt; -: 2: -: 3:template&lt;class T&gt; -: 4:class Foo -: 5:{
-: 6: public: 1*: 7: Foo(): b (1000) {} ——————
Foo&lt;char&gt;::Foo(): #####: 7: Foo(): b (1000) {} ——————
Foo&lt;int&gt;::Foo(): 1: 7: Foo(): b (1000) {} —————— 2*: 8: void
inc () { b++; } —————— Foo&lt;char&gt;::inc(): #####: 8: void inc
() { b++; } —————— Foo&lt;int&gt;::inc(): 2: 8: void inc () { b++;
} —————— -: 9: -: 10: private: -: 11: int b; -: 12:}; -: 13:
-: 14:template class Foo&lt;int&gt;; -: 15:template class Foo&lt;char&gt;; -: 16: -:
17:int 1: 18:main (void) -: 19:{ -: 20: int i, total; 1: 21: Foo&lt;int&gt;
counter; 1: 21-block 0 -: 22: 1: 23: counter.inc(); 1: 23-block 0 1: 24:
counter.inc(); 1: 24-block 0 1: 25: total = 0; -: 26: 11: 27: for (i =
0; i &lt; 10; i++) 1: 27-block 0 11: 27-block 1 10: 28: total += i; 10:
28-block 0 -: 29: 1*: 30: int v = total &gt; 100 ? 1 : 2; 1: 30-block 0
%%%%%: 30-block 1 1: 30-block 2 -: 31: 1: 32: if (total != 45) 1:
32-block 0 #####: 33: printf (&#34;Failure\n&#34;); %%%%%: 33-block 0 -: 34:
else 1: 35: printf (&#34;Success\n&#34;); 1: 35-block 0 1: 36: return 0; 1:
36-block 0 -: 37:}</p>
<p>
In this mode, each basic block is only shown on one line Ω- the last
line of the block. A multi-line block will only contribute to the
execution count of that last line, and other lines will not be shown to
contain code, unless previous blocks end on those lines. The total
execution count of a line is shown and subsequent lines show the
execution counts for individual blocks that end on that line. After each
block, the branch and call counts of the block will be shown, if the
<strong>-b</strong> option is given.</p>
<p>
Because of the way GCC instruments calls, a call count can be shown
after a line with no individual blocks. As you can see, line 33 contains
a basic block that was not executed.</p>
<p>
When you use the <strong>-b</strong> option, your output looks like this:</p>
<p>
-: 0:Source:tmp.cpp -: 0:Working directory:/home/gcc/testcase -:
0:Graph:tmp.gcno -: 0:Data:tmp.gcda -: 0:Runs:1 -: 0:Programs:1 -:
1:#include &lt;stdio.h&gt; -: 2: -: 3:template&lt;class T&gt; -: 4:class Foo -: 5:{
-: 6: public: 1*: 7: Foo(): b (1000) {} ——————
Foo&lt;char&gt;::Foo(): function Foo&lt;char&gt;::Foo() called 0 returned 0% blocks
executed 0% #####: 7: Foo(): b (1000) {} ——————
Foo&lt;int&gt;::Foo(): function Foo&lt;int&gt;::Foo() called 1 returned 100% blocks
executed 100% 1: 7: Foo(): b (1000) {} —————— 2*: 8: void
inc () { b++; } —————— Foo&lt;char&gt;::inc(): function
Foo&lt;char&gt;::inc() called 0 returned 0% blocks executed 0% #####: 8: void
inc () { b++; } —————— Foo&lt;int&gt;::inc(): function
Foo&lt;int&gt;::inc() called 2 returned 100% blocks executed 100% 2: 8: void
inc () { b++; } —————— -: 9: -: 10: private: -: 11: int b;
-: 12:}; -: 13: -: 14:template class Foo&lt;int&gt;; -: 15:template class
Foo&lt;char&gt;; -: 16: -: 17:int function main called 1 returned 100% blocks
executed 81% 1: 18:main (void) -: 19:{ -: 20: int i, total; 1: 21:
Foo&lt;int&gt; counter; call 0 returned 100% branch 1 taken 100% (fallthrough)
branch 2 taken 0% (throw) -: 22: 1: 23: counter.inc(); call 0 returned
100% branch 1 taken 100% (fallthrough) branch 2 taken 0% (throw) 1: 24:
counter.inc(); call 0 returned 100% branch 1 taken 100% (fallthrough)
branch 2 taken 0% (throw) 1: 25: total = 0; -: 26: 11: 27: for (i = 0; i
&lt; 10; i++) branch 0 taken 91% (fallthrough) branch 1 taken 9% 10: 28:
total += i; -: 29: 1*: 30: int v = total &gt; 100 ? 1 : 2; branch 0 taken
0% (fallthrough) branch 1 taken 100% -: 31: 1: 32: if (total != 45)
branch 0 taken 0% (fallthrough) branch 1 taken 100% #####: 33: printf
(&#34;Failure\n&#34;); call 0 never executed branch 1 never executed branch 2
never executed -: 34: else 1: 35: printf (&#34;Success\n&#34;); call 0 returned
100% branch 1 taken 100% (fallthrough) branch 2 taken 0% (throw) 1: 36:
return 0; -: 37:}</p>
<p>
For each function, a line is printed showing how many times the function
is called, how many times it returns and what percentage of the
function&#39;s blocks were executed.</p>
<p>
For each basic block, a line is printed after the last line of the basic
block describing the branch or call that ends the basic block. There can
be multiple branches and calls listed for a single source line if there
are multiple basic blocks that end on that line. In this case, the
branches and calls are each given a number. There is no simple way to
map these branches and calls back to source constructs. In general,
though, the lowest numbered branch or call will correspond to the
leftmost construct on the source line.</p>
<p>
For a branch, if it was executed at least once, then a percentage
indicating the number of times the branch was taken divided by the
number of times the branch was executed will be printed. Otherwise, the
message never executed is printed.</p>
<p>
For a call, if it was executed at least once, then a percentage
indicating the number of times the call returned divided by the number
of times the call was executed will be printed. This will usually be
100%, but may be less for functions that call <code class="verbatim">exit</code> or <code class="verbatim">longjmp</code>, and
thus may not return every time they are called.</p>
<p>
The execution counts are cumulative. If the example program were
executed again without removing the <em>.gcda</em> file, the count for the
number of times each line in the source was executed would be added to
the results of the previous run(s). This is potentially useful in
several ways. For example, it could be used to accumulate data over a
number of program runs as part of a test verification suite, or to
provide more accurate long-term information over a large number of
program runs.</p>
<p>
The data in the <em>.gcda</em> files is saved immediately before the program
exits. For each source file compiled with <strong>-fprofile-arcs</strong>, the
profiling code first attempts to read in an existing <em>.gcda</em> file; if
the file doesn&#39;t match the executable (differing number of basic block
counts) it will ignore the contents of the file. It then adds in the new
execution counts and finally writes the data to the file.</p>
<div id="outline-container-headline-5" class="outline-3">
<h3 id="headline-5">
Using <strong>gcov</strong> with GCC Optimization
</h3>
<div id="outline-text-headline-5" class="outline-text-3">
<p>If you plan to use <strong>gcov</strong> to help optimize your code, you must first
compile your program with a special GCC option <strong>–coverage</strong>. Aside from
that, you can use any other GCC options; but if you want to prove that
every single line in your program was executed, you should not compile
with optimization at the same time. On some machines the optimizer can
eliminate some simple code lines by combining them with other lines. For
example, code like this:</p>
<p>
if (a != b) c = 1; else c = 0;</p>
<p>
can be compiled into one instruction on some machines. In this case,
there is no way for <strong>gcov</strong> to calculate separate execution counts for
each line because there isn&#39;t separate code for each line. Hence the
<strong>gcov</strong> output looks like this if you compiled the program with
optimization:</p>
<p>
100: 12:if (a != b) 100: 13: c = 1; 100: 14:else 100: 15: c = 0;</p>
<p>
The output shows that this block of code, combined by optimization,
executed 100 times. In one sense this result is correct, because there
was only one instruction representing all four of these lines. However,
the output does not indicate how many times the result was 0 and how
many times the result was 1.</p>
<p>
Inlineable functions can create unexpected line counts. Line counts are
shown for the source code of the inlineable function, but what is shown
depends on where the function is inlined, or if it is not inlined at
all.</p>
<p>
If the function is not inlined, the compiler must emit an out of line
copy of the function, in any object file that needs it. If <em>fileA.o</em> and
<em>fileB.o</em> both contain out of line bodies of a particular inlineable
function, they will also both contain coverage counts for that function.
When <em>fileA.o</em> and <em>fileB.o</em> are linked together, the linker will, on
many systems, select one of those out of line bodies for all calls to
that function, and remove or ignore the other. Unfortunately, it will
not remove the coverage counters for the unused function body. Hence
when instrumented, all but one use of that function will show zero
counts.</p>
<p>
If the function is inlined in several places, the block structure in
each location might not be the same. For instance, a condition might now
be calculable at compile time in some instances. Because the coverage of
all the uses of the inline function will be shown for the same source
lines, the line counts themselves might seem inconsistent.</p>
<p>
Long-running applications can use the <code class="verbatim">_ _gcov_reset</code> and <code class="verbatim">_ _gcov_dump</code>
facilities to restrict profile collection to the program region of
interest. Calling <code class="verbatim">_ _gcov_reset(void)</code> will clear all run-time profile
counters to zero, and calling <code class="verbatim">_ _gcov_dump(void)</code> will cause the
profile information collected at that point to be dumped to <em>.gcda</em>
output files. Instrumented applications use a static destructor with
priority 99 to invoke the <code class="verbatim">_ _gcov_dump</code> function. Thus <code class="verbatim">_ _gcov_dump</code>
is executed after all user defined static destructors, as well as
handlers registered with <code class="verbatim">atexit</code>.</p>
<p>
If an executable loads a dynamic shared object via dlopen functionality,
<strong>-Wl,–dynamic-list-data</strong> is needed to dump all profile data.</p>
<p>
Profiling run-time library reports various errors related to profile
manipulation and profile saving. Errors are printed into standard error
output or <strong>GCOV_ERROR_FILE</strong> file, if environment variable is used. In
order to terminate immediately after an errors occurs set
<strong>GCOV_EXIT_AT_ERROR</strong> environment variable. That can help users to find
profile clashing which leads to a misleading profile.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-6" class="outline-2">
<h2 id="headline-6">
SEE ALSO
</h2>
<div id="outline-text-headline-6" class="outline-text-2">
<p><strong>gpl</strong> (7), <strong>gfdl</strong> (7), <strong>fsf-funding</strong> (7), <strong>gcc</strong> (1) and the Info entry
for <em>gcc</em>.</p>
</div>
</div>
<div id="outline-container-headline-7" class="outline-2">
<h2 id="headline-7">
COPYRIGHT
</h2>
<div id="outline-text-headline-7" class="outline-text-2">
<p>Copyright (c) 1996-2023 Free Software Foundation, Inc.</p>
<p>
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being GNU General Public License and Funding Free
Software, the Front-Cover texts being (a) (see below), and with the
Back-Cover Texts being (b) (see below). A copy of the license is
included in the <strong>gfdl</strong> (7) man page.</p>
<p>
(a) The FSF&#39;s Front-Cover Text is:</p>
<p>
A GNU Manual</p>
<p>
(b) The FSF&#39;s Back-Cover Text is:</p>
<p>
You have freedom to copy and modify this GNU Manual, like GNU software.
Copies published by the Free Software Foundation raise funds for GNU
development.</p>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.95916b5b8c09add4922ea47e674b5da7fc4b6347a3e8c4e25e98b4b7d236080b.js" integrity="sha256-lZFrW4wJrdSSLqR&#43;Z0tdp/xLY0ej6MTiXpi0t9I2CAs=" crossorigin="anonymous"></script>
    </body>
</html>
