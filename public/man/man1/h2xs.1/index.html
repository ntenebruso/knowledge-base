<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - h2xs.1 | Technical Notes</title>

      <link rel="stylesheet" href="/css/main.min.a9ecaac9d4f7845fc2de4738f7709cab0bd1c3d19c3466fadd637a6987603257.css" integrity="sha256-qeyqydT3hF/C3kc493CcqwvRw9GcNGb63WN6aYdgMlc=" crossorigin="anonymous">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - h2xs.1</h1>
    
<p>
\\</p>
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
NAME
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>h2xs - convert .h C header files to Perl extensions</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
SYNOPSIS
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p><strong>h2xs</strong> [*OPTIONS* …] [headerfile … [extra_libraries]]</p>
<p>
<strong>h2xs</strong> <strong>-h*|</strong>-?*|*–help*</p>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
DESCRIPTION
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p><em>h2xs</em> builds a Perl extension from C header files. The extension will
include functions which can be used to retrieve the value of any #define
statement which was in the C header files.</p>
<p>
The <em>module_name</em> will be used for the name of the extension. If
module_name is not supplied then the name of the first header file will
be used, with the first character capitalized.</p>
<p>
If the extension might need extra libraries, they should be included
here. The extension Makefile.PL will take care of checking whether the
libraries actually exist and how they should be loaded. The extra
libraries should be specified in the form -lm -lposix, etc, just as on
the cc command line. By default, the Makefile.PL will search through the
library path determined by Configure. That path can be augmented by
including arguments of the form <strong>-L/another/library/path</strong> in the
extra-libraries argument.</p>
<p>
In spite of its name, <em>h2xs</em> may also be used to create a skeleton pure
Perl module. See the <strong>-X</strong> option.</p>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
OPTIONS
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<dl>
<dt>
-A, –omit-autoload
</dt>
<dd>Omit all autoload facilities. This is the same
as <strong>-c</strong> but also removes the <code class="verbatim">use AutoLoader</code> statement from the .pm
file.</dd>
<dt>
-B, –beta-version
</dt>
<dd>Use an alpha/beta style version number. Causes
version number to be &#34;0.00_01&#34; unless <strong>-v</strong> is specified.</dd>
<dt>
-C, –omit-changes
</dt>
<dd>Omits creation of the <em>Changes</em> file, and adds a
HISTORY section to the POD template.</dd>
<dt>
-F, –cpp-flags=addflags
</dt>
<dd>Additional flags to specify to C
preprocessor when scanning header for function declarations. Writes
these options in the generated <em>Makefile.PL</em> too.</dd>
<dt>
-M, –func-mask=regular expression
</dt>
<dd>selects functions/macros to
process.</dd>
<dt>
-O, –overwrite-ok
</dt>
<dd>Allows a pre-existing extension directory to be
overwritten.</dd>
<dt>
-P, –omit-pod
</dt>
<dd>Omit the autogenerated stub POD section.</dd>
<dt>
-X, –omit-XS
</dt>
<dd>Omit the XS portion. Used to generate a skeleton pure
Perl module. <code class="verbatim">-c</code> and <code class="verbatim">-f</code> are implicitly enabled.</dd>
<dt>
-a, –gen-accessors
</dt>
<dd>Generate an accessor method for each element of
structs and unions. The generated methods are named after the element
name; will return the current value of the element if called without
additional arguments; and will set the element to the supplied value
(and return the new value) if called with an additional argument.
Embedded structures and unions are returned as a pointer rather than
the complete structure, to facilitate chained calls. These methods all
apply to the Ptr type for the structure; additionally two methods are
constructed for the structure type itself, <code class="verbatim">_to_ptr</code> which returns a
Ptr type pointing to the same structure, and a <code class="verbatim">new</code> method to
construct and return a new structure, initialised to zeroes.</dd>
<dt>
-b, –compat-version=version
</dt>
<dd>Generates a .pm file which is
backwards compatible with the specified perl version. For versions &lt;
5.6.0, the changes are. - no use of &#39;our&#39; (uses &#39;use vars&#39; instead) -
no &#39;use warnings&#39; Specifying a compatibility version higher than the
version of perl you are using to run h2xs will have no effect. If
unspecified h2xs will default to compatibility with the version of
perl you are using to run h2xs.</dd>
<dt>
-c, –omit-constant
</dt>
<dd>Omit <code class="verbatim">constant()</code> from the .xs file and
corresponding specialised <code class="verbatim">AUTOLOAD</code> from the .pm file.</dd>
<dt>
-d, –debugging
</dt>
<dd>Turn on debugging messages.</dd>
<dt>
-e, –omit-enums=[regular expression]
</dt>
<dd>If <em>regular expression</em> is
not given, skip all constants that are defined in a C enumeration.
Otherwise skip only those constants that are defined in an enum whose
name matches <em>regular expression</em>. Since <em>regular expression</em> is
optional, make sure that this switch is followed by at least one other
switch if you omit <em>regular expression</em> and have some pending
arguments such as header-file names. This is ok: h2xs -e -n
Module::Foo foo.h This is not ok: h2xs -n Module::Foo -e foo.h In the
latter, foo.h is taken as <em>regular expression</em>.</dd>
<dt>
-f, –force
</dt>
<dd>Allows an extension to be created for a header even if
that header is not found in standard include directories.</dd>
<dt>
-g, –global
</dt>
<dd>Include code for safely storing static data in the .xs
file. Extensions that do no make use of static data can ignore this
option.</dd>
<dt>
-h, -?, –help
</dt>
<dd>Print the usage, help and version for this h2xs and
exit.</dd>
<dt>
-k, –omit-const-func
</dt>
<dd>For function arguments declared as <code class="verbatim">const</code>,
omit the const attribute in the generated XS code.</dd>
<dt>
-m, –gen-tied-var
</dt>
<dd><strong>Experimental</strong>: for each variable declared in
the header file(s), declare a perl variable of the same name magically
tied to the C variable.</dd>
<dt>
-n, –name=module_name
</dt>
<dd>Specifies a name to be used for the
extension, e.g., -n RPC::DCE</dd>
<dt>
-o, –opaque-re=regular expression
</dt>
<dd>Use &#34;opaque&#34; data type for the C
types matched by the regular expression, even if these types are
<code class="verbatim">typedef</code>-equivalent to types from typemaps. Should not be used
without <strong>-x</strong>. This may be useful since, say, types which are
<code class="verbatim">typedef</code>-equivalent to integers may represent OS-related handles, and
one may want to work with these handles in OO-way, as in
<code class="verbatim">$handle-&gt;do_something()</code>. Use <code class="verbatim">-o .</code> if you want to handle all the
=typedef=ed types as opaque types. The type-to-match is whitewashed
(except for commas, which have no whitespace before them, and multiple
<code class="verbatim">*</code> which have no whitespace between them).</dd>
<dt>
-p, –remove-prefix=prefix
</dt>
<dd>Specify a prefix which should be removed
from the Perl function names, e.g., -p sec_rgy_ This sets up the XS
<strong>PREFIX</strong> keyword and removes the prefix from functions that are
autoloaded via the <code class="verbatim">constant()</code> mechanism.</dd>
<dt>
-s, –const-subs=sub1,sub2
</dt>
<dd>Create a perl subroutine for the
specified macros rather than autoload with the <strong>constant()</strong>
subroutine. These macros are assumed to have a return type of <strong>char
​*</strong>, e.g., -s sec_rgy_wildcard_name,sec_rgy_wildcard_sid.</dd>
<dt>
-t, –default-type=type
</dt>
<dd>Specify the internal type that the
<strong>constant()</strong> mechanism uses for macros. The default is IV (signed
integer). Currently all macros found during the header scanning
process will be assumed to have this type. Future versions of <code class="verbatim">h2xs</code>
may gain the ability to make educated guesses.</dd>
<dt>
–use-new-tests
</dt>
<dd>When <strong>–compat-version</strong> (<strong>-b</strong>) is present the
generated tests will use <code class="verbatim">Test::More</code> rather than <code class="verbatim">Test</code> which is the
default for versions before 5.6.2. <code class="verbatim">Test::More</code> will be added to
PREREQ_PM in the generated <code class="verbatim">Makefile.PL</code>.</dd>
<dt>
–use-old-tests
</dt>
<dd>Will force the generation of test code that uses
the older <code class="verbatim">Test</code> module.</dd>
<dt>
–skip-exporter
</dt>
<dd>Do not use <code class="verbatim">Exporter</code> and/or export any symbol.</dd>
<dt>
–skip-ppport
</dt>
<dd>Do not use <code class="verbatim">Devel::PPPort</code>: no portability to older
version.</dd>
<dt>
–skip-autoloader
</dt>
<dd>Do not use the module <code class="verbatim">AutoLoader</code>; but keep the
<strong>constant()</strong> function and <code class="verbatim">sub AUTOLOAD</code> for constants.</dd>
<dt>
–skip-strict
</dt>
<dd>Do not use the pragma <code class="verbatim">strict</code>.</dd>
<dt>
–skip-warnings
</dt>
<dd>Do not use the pragma <code class="verbatim">warnings</code>.</dd>
<dt>
-v, –version=version
</dt>
<dd>Specify a version number for this extension.
This version number is added to the templates. The default is 0.01, or
0.00_01 if <code class="verbatim">-B</code> is specified. The version specified should be numeric.</dd>
<dt>
-x, –autogen-xsubs
</dt>
<dd>Automatically generate XSUBs basing on function
declarations in the header file. The package <code class="verbatim">C::Scan</code> should be
installed. If this option is specified, the name of the header file
may look like <code class="verbatim">NAME1,NAME2</code>. In this case NAME1 is used instead of the
specified string, but XSUBs are emitted only for the declarations
included from file NAME2. Note that some types of
arguments/return-values for functions may result in
XSUB-declarations/typemap-entries which need hand-editing. Such may be
objects which cannot be converted from/to a pointer (like
<code class="verbatim">long long</code>), pointers to functions, or arrays. See also the section
on &#34;LIMITATIONS of <strong>-x</strong>&#34;.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-5" class="outline-2">
<h2 id="headline-5">
EXAMPLES
</h2>
<div id="outline-text-headline-5" class="outline-text-2">
<p>​# Default behavior, extension is Rusers h2xs rpcsvc/rusers # Same, but
extension is RUSERS h2xs -n RUSERS rpcsvc/rusers # Extension is
rpcsvc::rusers. Still finds &lt;rpcsvc/rusers.h&gt; h2xs rpcsvc::rusers #
Extension is ONC::RPC. Still finds &lt;rpcsvc/rusers.h&gt; h2xs -n ONC::RPC
rpcsvc/rusers # Without constant() or AUTOLOAD h2xs -c rpcsvc/rusers #
Creates templates for an extension named RPC h2xs -cfn RPC # Extension
is ONC::RPC. h2xs -cfn ONC::RPC # Extension is a pure Perl module with
no XS code. h2xs -X My::Module # Extension is Lib::Foo which works at
least with Perl5.005_03. # Constants are created for all #defines and
enums h2xs can find # in foo.h. h2xs -b 5.5.3 -n Lib::Foo foo.h #
Extension is Lib::Foo which works at least with Perl5.005_03. #
Constants are created for all #defines but only for enums # whose names
do not start with bar_. h2xs -b 5.5.3 -e ^bar_ -n Lib::Foo foo.h #
Makefile.PL will look for library -lrpc in # additional directory
/opt/net/lib h2xs rpcsvc/rusers -L/opt/net/lib -lrpc # Extension is
DCE::rgynbase # prefix &#34;sec_rgy_&#34; is dropped from perl function names
h2xs -n DCE::rgynbase -p sec_rgy_ dce/rgynbase # Extension is
DCE::rgynbase # prefix &#34;sec_rgy_&#34; is dropped from perl function names #
subroutines are created for sec_rgy_wildcard_name and #
sec_rgy_wildcard_sid h2xs -n DCE::rgynbase -p sec_rgy_ \ -s
sec_rgy_wildcard_name,sec_rgy_wildcard_sid dce/rgynbase # Make XS
without defines in perl.h, but with function declarations # visible from
perl.h. Name of the extension is perl1. # When scanning perl.h, define
-DEXT=extern -DdEXT= -DINIT(x)= # Extra backslashes below because the
string is passed to shell. # Note that a directory with perl header
files would # be added automatically to include path. h2xs -xAn perl1 -F
&#34;-DEXT=extern -DdEXT= -DINIT\(x\)=&#34; perl.h # Same with function
declaration in proto.h as visible from perl.h. h2xs -xAn perl2
perl.h,proto.h # Same but select only functions which match <em>^av_</em> h2xs
-M ^av_ -xAn perl2 perl.h,proto.h # Same but treat SV* etc as &#34;opaque&#34;
types h2xs -o ^[S]V \*$ -M ^av_ -xAn perl2 perl.h,proto.h</p>
<div id="outline-container-headline-6" class="outline-3">
<h3 id="headline-6">
Extension based on <em>.h</em> and <em>.c</em> files
</h3>
<div id="outline-text-headline-6" class="outline-text-3">
<p>Suppose that you have some C files implementing some functionality, and
the corresponding header files. How to create an extension which makes
this functionality accessible in Perl? The example below assumes that
the header files are <em>interface_simple.h</em> and <em>interface_hairy.h</em>, and
you want the perl module be named as <code class="verbatim">Ext::Ension</code>. If you need some
preprocessor directives and/or linking with external libraries, see the
flags <code class="verbatim">-F</code>, <code class="verbatim">-L</code> and <code class="verbatim">-l</code> in &#34;OPTIONS&#34;.</p>
<dl>
<dt>
Find the directory name
</dt>
<dd>Start with a dummy run of h2xs: h2xs -Afn
Ext::Ension The only purpose of this step is to create the needed
directories, and let you know the names of these directories. From the
output you can see that the directory for the extension is
<em>Ext/Ension</em>.</dd>
<dt>
Copy C files
</dt>
<dd>Copy your header files and C files to this directory
<em>Ext/Ension</em>.</dd>
<dt>
Create the extension
</dt>
<dd>Run h2xs, overwriting older autogenerated
files: h2xs -Oxan Ext::Ension interface_simple.h interface_hairy.h
h2xs looks for header files <em>after</em> changing to the extension
directory, so it will find your header files OK.</dd>
<dt>
Archive and test
</dt>
<dd>As usual, run cd Ext/Ension perl Makefile.PL make
dist make make test</dd>
<dt>
Hints
</dt>
<dd>It is important to do <code class="verbatim">make dist</code> as early as possible. This
way you can easily <strong>merge</strong> (1) your changes to autogenerated files if
you decide to edit your <code class="verbatim">.h</code> files and rerun h2xs. Do not forget to
edit the documentation in the generated <em>.pm</em> file. Consider the
autogenerated files as skeletons only, you may invent better
interfaces than what h2xs could guess. Consider this section as a
guideline only, some other options of h2xs may better suit your needs.</dd>
</dl>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-7" class="outline-2">
<h2 id="headline-7">
ENVIRONMENT
</h2>
<div id="outline-text-headline-7" class="outline-text-2">
<p>No environment variables are used.</p>
</div>
</div>
<div id="outline-container-headline-8" class="outline-2">
<h2 id="headline-8">
AUTHOR
</h2>
<div id="outline-text-headline-8" class="outline-text-2">
<p>Larry Wall and others</p>
</div>
</div>
<div id="outline-container-headline-9" class="outline-2">
<h2 id="headline-9">
SEE ALSO
</h2>
<div id="outline-text-headline-9" class="outline-text-2">
<p>perl, perlxstut, ExtUtils::MakeMaker, and AutoLoader.</p>
</div>
</div>
<div id="outline-container-headline-10" class="outline-2">
<h2 id="headline-10">
DIAGNOSTICS
</h2>
<div id="outline-text-headline-10" class="outline-text-2">
<p>The usual warnings if it cannot read or write the files involved.</p>
</div>
</div>
<div id="outline-container-headline-11" class="outline-2">
<h2 id="headline-11">
LIMITATIONS of <strong>-x</strong>
</h2>
<div id="outline-text-headline-11" class="outline-text-2">
<p><em>h2xs</em> would not distinguish whether an argument to a C function which
is of the form, say, <code class="verbatim">int *</code>, is an input, output, or input/output
parameter. In particular, argument declarations of the form</p>
<p>
int foo(n) int *n</p>
<p>
should be better rewritten as</p>
<p>
int foo(n) int &amp;n</p>
<p>
if <code class="verbatim">n</code> is an input parameter.</p>
<p>
Additionally, <em>h2xs</em> has no facilities to intuit that a function</p>
<p>
int foo(addr,l) char *addr int l</p>
<p>
takes a pair of address and length of data at this address, so it is
better to rewrite this function as</p>
<p>
int foo(sv) SV *addr PREINIT: STRLEN len; char *s; CODE: s =
SvPV(sv,len); RETVAL = foo(s, len); OUTPUT: RETVAL</p>
<p>
or alternately</p>
<p>
static int my_foo(SV *sv) { STRLEN len; char *s = SvPV(sv,len); return
foo(s, len); } MODULE = foo PACKAGE = foo PREFIX = my_ int foo(sv) SV
​*sv</p>
<p>
See perlxs and perlxstut for additional details.</p>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.95916b5b8c09add4922ea47e674b5da7fc4b6347a3e8c4e25e98b4b7d236080b.js" integrity="sha256-lZFrW4wJrdSSLqR&#43;Z0tdp/xLY0ej6MTiXpi0t9I2CAs=" crossorigin="anonymous"></script>
    </body>
</html>
