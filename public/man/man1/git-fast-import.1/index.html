<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - git-fast-import.1 | Technical Notes</title>

      <link rel="stylesheet" href="/css/main.min.a9ecaac9d4f7845fc2de4738f7709cab0bd1c3d19c3466fadd637a6987603257.css" integrity="sha256-qeyqydT3hF/C3kc493CcqwvRw9GcNGb63WN6aYdgMlc=" crossorigin="anonymous">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - git-fast-import.1</h1>
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
NAME
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>git-fast-import - Backend for fast Git data importers</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
SYNOPSIS
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<pre class="example">
frontend | git fast-import [&lt;options&gt;]
</pre>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
DESCRIPTION
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p>This program is usually not what the end user wants to run directly.
Most end users want to use one of the existing frontend programs, which
parses a specific type of foreign source and feeds the contents stored
there to <em>git fast-import</em>.</p>
<p>
fast-import reads a mixed command/data stream from standard input and
writes one or more packfiles directly into the current repository. When
EOF is received on standard input, fast import writes out updated branch
and tag refs, fully updating the current repository with the newly
imported data.</p>
<p>
The fast-import backend itself can import into an empty repository (one
that has already been initialized by <em>git init</em>) or incrementally update
an existing populated repository. Whether or not incremental imports are
supported from a particular foreign source depends on the frontend
program in use.</p>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
OPTIONS
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<p>–force</p>
<blockquote>
<p>Force updating modified existing branches, even if doing so would cause
commits to be lost (as the new commit does not contain the old commit).</p>
</blockquote>
<p>
–quiet</p>
<blockquote>
<p>Disable the output shown by –stats, making fast-import usually be
silent when it is successful. However, if the import stream has
directives intended to show user output (e.g. <strong>progress</strong> directives),
the corresponding messages will still be shown.</p>
</blockquote>
<p>
–stats</p>
<blockquote>
<p>Display some basic statistics about the objects fast-import has created,
the packfiles they were stored into, and the memory used by fast-import
during this run. Showing this output is currently the default, but can
be disabled with –quiet.</p>
</blockquote>
<p>
–allow-unsafe-features</p>
<blockquote>
<p>Many command-line options can be provided as part of the fast-import
stream itself by using the <strong>feature</strong> or <strong>option</strong> commands. However, some
of these options are unsafe (e.g., allowing fast-import to access the
filesystem outside of the repository). These options are disabled by
default, but can be allowed by providing this option on the command
line. This currently impacts only the <strong>export-marks</strong>, <strong>import-marks</strong>,
and <strong>import-marks-if-exists</strong> feature commands.</p>
<blockquote>
<pre class="example">
Only enable this option if you trust the program generating the
fast-import stream! This option is enabled automatically for
remote-helpers that use the `import` capability, as they are
already trusted to run their own code.
</pre>
</blockquote>
</blockquote>
<div id="outline-container-headline-5" class="outline-3">
<h3 id="headline-5">
Options for Frontends
</h3>
<div id="outline-text-headline-5" class="outline-text-3">
<p>–cat-blob-fd=&lt;fd&gt;</p>
<blockquote>
<p>Write responses to <strong>get-mark</strong>, <strong>cat-blob</strong>, and <strong>ls</strong> queries to the file
descriptor &lt;fd&gt; instead of <strong>stdout</strong>. Allows <strong>progress</strong> output intended
for the end-user to be separated from other output.</p>
</blockquote>
<p>
–date-format=&lt;fmt&gt;</p>
<blockquote>
<p>Specify the type of dates the frontend will supply to fast-import within
<strong>author</strong>, <strong>committer</strong> and <strong>tagger</strong> commands. See “Date Formats” below
for details about which formats are supported, and their syntax.</p>
</blockquote>
<p>
–done</p>
<blockquote>
<p>Terminate with error if there is no <strong>done</strong> command at the end of the
stream. This option might be useful for detecting errors that cause the
frontend to terminate before it has started to write a stream.</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-6" class="outline-3">
<h3 id="headline-6">
Locations of Marks Files
</h3>
<div id="outline-text-headline-6" class="outline-text-3">
<p>–export-marks=&lt;file&gt;</p>
<blockquote>
<p>Dumps the internal marks table to &lt;file&gt; when complete. Marks are
written one per line as <strong>:markid SHA-1</strong>. Frontends can use this file to
validate imports after they have been completed, or to save the marks
table across incremental runs. As &lt;file&gt; is only opened and truncated at
checkpoint (or completion) the same path can also be safely given to
–import-marks.</p>
</blockquote>
<p>
–import-marks=&lt;file&gt;</p>
<blockquote>
<p>Before processing any input, load the marks specified in &lt;file&gt;. The
input file must exist, must be readable, and must use the same format as
produced by –export-marks. Multiple options may be supplied to import
more than one set of marks. If a mark is defined to different values,
the last file wins.</p>
</blockquote>
<p>
–import-marks-if-exists=&lt;file&gt;</p>
<blockquote>
<p>Like –import-marks but instead of erroring out, silently skips the file
if it does not exist.</p>
</blockquote>
<p>
–[no-]relative-marks</p>
<blockquote>
<p>After specifying –relative-marks the paths specified with
–import-marks= and –export-marks= are relative to an internal
directory in the current repository. In git-fast-import this means that
the paths are relative to the .git/info/fast-import directory. However,
other importers may use a different location.</p>
<p>
Relative and non-relative marks may be combined by interweaving
–(no-)-relative-marks with the –(import|export)-marks= options.</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-7" class="outline-3">
<h3 id="headline-7">
Submodule Rewriting
</h3>
<div id="outline-text-headline-7" class="outline-text-3">
<p>–rewrite-submodules-from=&lt;name&gt;:&lt;file&gt;,
–rewrite-submodules-to=&lt;name&gt;:&lt;file&gt;</p>
<blockquote>
<p>Rewrite the object IDs for the submodule specified by &lt;name&gt; from the
values used in the from &lt;file&gt; to those used in the to &lt;file&gt;. The from
marks should have been created by <strong>git fast-export</strong>, and the to marks
should have been created by <strong>git fast-import</strong> when importing that same
submodule.</p>
<p>
&lt;name&gt; may be any arbitrary string not containing a colon character, but
the same value must be used with both options when specifying
corresponding marks. Multiple submodules may be specified with different
values for &lt;name&gt;. It is an error not to use these options in
corresponding pairs.</p>
<p>
These options are primarily useful when converting a repository from one
hash algorithm to another; without them, fast-import will fail if it
encounters a submodule because it has no way of writing the object ID
into the new hash algorithm.</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-8" class="outline-3">
<h3 id="headline-8">
Performance and Compression Tuning
</h3>
<div id="outline-text-headline-8" class="outline-text-3">
<p>–active-branches=&lt;n&gt;</p>
<blockquote>
<p>Maximum number of branches to maintain active at once. See “Memory
Utilization” below for details. Default is 5.</p>
</blockquote>
<p>
–big-file-threshold=&lt;n&gt;</p>
<blockquote>
<p>Maximum size of a blob that fast-import will attempt to create a delta
for, expressed in bytes. The default is 512m (512 MiB). Some importers
may wish to lower this on systems with constrained memory.</p>
</blockquote>
<p>
–depth=&lt;n&gt;</p>
<blockquote>
<p>Maximum delta depth, for blob and tree deltification. Default is 50.</p>
</blockquote>
<p>
–export-pack-edges=&lt;file&gt;</p>
<blockquote>
<p>After creating a packfile, print a line of data to &lt;file&gt; listing the
filename of the packfile and the last commit on each branch that was
written to that packfile. This information may be useful after importing
projects whose total object set exceeds the 4 GiB packfile limit, as
these commits can be used as edge points during calls to <em>git
pack-objects</em>.</p>
</blockquote>
<p>
–max-pack-size=&lt;n&gt;</p>
<blockquote>
<p>Maximum size of each output packfile. The default is unlimited.</p>
</blockquote>
<p>
fastimport.unpackLimit</p>
<blockquote>
<p>See *git-config*(1)</p>
</blockquote>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-9" class="outline-2">
<h2 id="headline-9">
PERFORMANCE
</h2>
<div id="outline-text-headline-9" class="outline-text-2">
<p>The design of fast-import allows it to import large projects in a
minimum amount of memory usage and processing time. Assuming the
frontend is able to keep up with fast-import and feed it a constant
stream of data, import times for projects holding 10+ years of history
and containing 100,000+ individual commits are generally completed in
just 1-2 hours on quite modest (~$2,000 USD) hardware.</p>
<p>
Most bottlenecks appear to be in foreign source data access (the source
just cannot extract revisions fast enough) or disk IO (fast-import
writes as fast as the disk will take the data). Imports will run faster
if the source data is stored on a different drive than the destination
Git repository (due to less IO contention).</p>
</div>
</div>
<div id="outline-container-headline-10" class="outline-2">
<h2 id="headline-10">
DEVELOPMENT COST
</h2>
<div id="outline-text-headline-10" class="outline-text-2">
<p>A typical frontend for fast-import tends to weigh in at approximately
200 lines of Perl/Python/Ruby code. Most developers have been able to
create working importers in just a couple of hours, even though it is
their first exposure to fast-import, and sometimes even to Git. This is
an ideal situation, given that most conversion tools are throw-away (use
once, and never look back).</p>
</div>
</div>
<div id="outline-container-headline-11" class="outline-2">
<h2 id="headline-11">
PARALLEL OPERATION
</h2>
<div id="outline-text-headline-11" class="outline-text-2">
<p>Like <em>git push</em> or <em>git fetch</em>, imports handled by fast-import are safe
to run alongside parallel <strong>git repack -a -d</strong> or <strong>git gc</strong> invocations, or
any other Git operation (including <em>git prune</em>, as loose objects are
never used by fast-import).</p>
<p>
fast-import does not lock the branch or tag refs it is actively
importing. After the import, during its ref update phase, fast-import
tests each existing branch ref to verify the update will be a
fast-forward update (the commit stored in the ref is contained in the
new history of the commit to be written). If the update is not a
fast-forward update, fast-import will skip updating that ref and instead
prints a warning message. fast-import will always attempt to update all
branch refs, and does not stop on the first failure.</p>
<p>
Branch updates can be forced with –force, but it&#39;s recommended that
this only be used on an otherwise quiet repository. Using –force is not
necessary for an initial import into an empty repository.</p>
</div>
</div>
<div id="outline-container-headline-12" class="outline-2">
<h2 id="headline-12">
TECHNICAL DISCUSSION
</h2>
<div id="outline-text-headline-12" class="outline-text-2">
<p>fast-import tracks a set of branches in memory. Any branch can be
created or modified at any point during the import process by sending a
<strong>commit</strong> command on the input stream. This design allows a frontend
program to process an unlimited number of branches simultaneously,
generating commits in the order they are available from the source data.
It also simplifies the frontend programs considerably.</p>
<p>
fast-import does not use or alter the current working directory, or any
file within it. (It does however update the current Git repository, as
referenced by <strong>GIT_DIR</strong>.) Therefore an import frontend may use the
working directory for its own purposes, such as extracting file
revisions from the foreign source. This ignorance of the working
directory also allows fast-import to run very quickly, as it does not
need to perform any costly file update operations when switching between
branches.</p>
</div>
</div>
<div id="outline-container-headline-13" class="outline-2">
<h2 id="headline-13">
INPUT FORMAT
</h2>
<div id="outline-text-headline-13" class="outline-text-2">
<p>With the exception of raw file data (which Git does not interpret) the
fast-import input format is text (ASCII) based. This text based format
simplifies development and debugging of frontend programs, especially
when a higher level language such as Perl, Python or Ruby is being used.</p>
<p>
fast-import is very strict about its input. Where we say SP below we
mean <strong>exactly</strong> one space. Likewise LF means one (and only one) linefeed
and HT one (and only one) horizontal tab. Supplying additional
whitespace characters will cause unexpected results, such as branch
names or file names with leading or trailing spaces in their name, or
early termination of fast-import when it encounters unexpected input.</p>
<div id="outline-container-headline-14" class="outline-3">
<h3 id="headline-14">
Stream Comments
</h3>
<div id="outline-text-headline-14" class="outline-text-3">
<p>To aid in debugging frontends fast-import ignores any line that begins
with <strong>#</strong> (ASCII pound/hash) up to and including the line ending <strong>LF</strong>. A
comment line may contain any sequence of bytes that does not contain an
LF and therefore may be used to include any detailed debugging
information that might be specific to the frontend and useful when
inspecting a fast-import data stream.</p>
</div>
</div>
<div id="outline-container-headline-15" class="outline-3">
<h3 id="headline-15">
Date Formats
</h3>
<div id="outline-text-headline-15" class="outline-text-3">
<p>The following date formats are supported. A frontend should select the
format it will use for this import by passing the format name in the
–date-format=&lt;fmt&gt; command-line option.</p>
<p>
<strong>raw</strong></p>
<blockquote>
<p>This is the Git native format and is <strong>&lt;time&gt; SP &lt;offutc&gt;</strong>. It is also
fast-import&#39;s default format, if –date-format was not specified.</p>
<p>
The time of the event is specified by <strong>&lt;time&gt;</strong> as the number of seconds
since the UNIX epoch (midnight, Jan 1, 1970, UTC) and is written as an
ASCII decimal integer.</p>
<p>
The local offset is specified by <strong>&lt;offutc&gt;</strong> as a positive or negative
offset from UTC. For example EST (which is 5 hours behind UTC) would be
expressed in <strong>&lt;tz&gt;</strong> by “-0500” while UTC is “+0000”. The local offset
does not affect <strong>&lt;time&gt;</strong>; it is used only as an advisement to help
formatting routines display the timestamp.</p>
<p>
If the local offset is not available in the source material, use
“+0000”, or the most common local offset. For example many organizations
have a CVS repository which has only ever been accessed by users who are
located in the same location and time zone. In this case a reasonable
offset from UTC could be assumed.</p>
<p>
Unlike the <strong>rfc2822</strong> format, this format is very strict. Any variation
in formatting will cause fast-import to reject the value, and some
sanity checks on the numeric values may also be performed.</p>
</blockquote>
<p>
<strong>raw-permissive</strong></p>
<blockquote>
<p>This is the same as <strong>raw</strong> except that no sanity checks on the numeric
epoch and local offset are performed. This can be useful when trying to
filter or import an existing history with e.g. bogus timezone values.</p>
</blockquote>
<p>
<strong>rfc2822</strong></p>
<blockquote>
<p>This is the standard date format as described by RFC 2822.</p>
<p>
An example value is “Tue Feb 6 11:22:18 2007 -0500”. The Git parser is
accurate, but a little on the lenient side. It is the same parser used
by <em>git am</em> when applying patches received from email.</p>
<p>
Some malformed strings may be accepted as valid dates. In some of these
cases Git will still be able to obtain the correct date from the
malformed string. There are also some types of malformed strings which
Git will parse wrong, and yet consider valid. Seriously malformed
strings will be rejected.</p>
<p>
Unlike the <strong>raw</strong> format above, the time zone/UTC offset information
contained in an RFC 2822 date string is used to adjust the date value to
UTC prior to storage. Therefore it is important that this information be
as accurate as possible.</p>
<p>
If the source material uses RFC 2822 style dates, the frontend should
let fast-import handle the parsing and conversion (rather than
attempting to do it itself) as the Git parser has been well tested in
the wild.</p>
<p>
Frontends should prefer the <strong>raw</strong> format if the source material already
uses UNIX-epoch format, can be coaxed to give dates in that format, or
its format is easily convertible to it, as there is no ambiguity in
parsing.</p>
</blockquote>
<p>
<strong>now</strong></p>
<blockquote>
<p>Always use the current time and time zone. The literal <strong>now</strong> must always
be supplied for <strong>&lt;when&gt;</strong>.</p>
<p>
This is a toy format. The current time and time zone of this system is
always copied into the identity string at the time it is being created
by fast-import. There is no way to specify a different time or time
zone.</p>
<p>
This particular format is supplied as it&#39;s short to implement and may be
useful to a process that wants to create a new commit right now, without
needing to use a working directory or <em>git update-index</em>.</p>
<p>
If separate <strong>author</strong> and <strong>committer</strong> commands are used in a <strong>commit</strong> the
timestamps may not match, as the system clock will be polled twice (once
for each command). The only way to ensure that both author and committer
identity information has the same timestamp is to omit <strong>author</strong> (thus
copying from <strong>committer</strong>) or to use a date format other than <strong>now</strong>.</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-16" class="outline-3">
<h3 id="headline-16">
Commands
</h3>
<div id="outline-text-headline-16" class="outline-text-3">
<p>fast-import accepts several commands to update the current repository
and control the current import process. More detailed discussion (with
examples) of each command follows later.</p>
<p>
<strong>commit</strong></p>
<blockquote>
<p>Creates a new branch or updates an existing branch by creating a new
commit and updating the branch to point at the newly created commit.</p>
</blockquote>
<p>
<strong>tag</strong></p>
<blockquote>
<p>Creates an annotated tag object from an existing commit or branch.
Lightweight tags are not supported by this command, as they are not
recommended for recording meaningful points in time.</p>
</blockquote>
<p>
<strong>reset</strong></p>
<blockquote>
<p>Reset an existing branch (or a new branch) to a specific revision. This
command must be used to change a branch to a specific revision without
making a commit on it.</p>
</blockquote>
<p>
<strong>blob</strong></p>
<blockquote>
<p>Convert raw file data into a blob, for future use in a <strong>commit</strong> command.
This command is optional and is not needed to perform an import.</p>
</blockquote>
<p>
<strong>alias</strong></p>
<blockquote>
<p>Record that a mark refers to a given object without first creating any
new object. Using –import-marks and referring to missing marks will
cause fast-import to fail, so aliases can provide a way to set otherwise
pruned commits to a valid value (e.g. the nearest non-pruned ancestor).</p>
</blockquote>
<p>
<strong>checkpoint</strong></p>
<blockquote>
<p>Forces fast-import to close the current packfile, generate its unique
SHA-1 checksum and index, and start a new packfile. This command is
optional and is not needed to perform an import.</p>
</blockquote>
<p>
<strong>progress</strong></p>
<blockquote>
<p>Causes fast-import to echo the entire line to its own standard output.
This command is optional and is not needed to perform an import.</p>
</blockquote>
<p>
<strong>done</strong></p>
<blockquote>
<p>Marks the end of the stream. This command is optional unless the <strong>done</strong>
feature was requested using the <strong>–done</strong> command-line option or <strong>feature
done</strong> command.</p>
</blockquote>
<p>
<strong>get-mark</strong></p>
<blockquote>
<p>Causes fast-import to print the SHA-1 corresponding to a mark to the
file descriptor set with <strong>–cat-blob-fd</strong>, or <strong>stdout</strong> if unspecified.</p>
</blockquote>
<p>
<strong>cat-blob</strong></p>
<blockquote>
<p>Causes fast-import to print a blob in <em>cat-file –batch</em> format to the
file descriptor set with <strong>–cat-blob-fd</strong> or <strong>stdout</strong> if unspecified.</p>
</blockquote>
<p>
<strong>ls</strong></p>
<blockquote>
<p>Causes fast-import to print a line describing a directory entry in
<em>ls-tree</em> format to the file descriptor set with <strong>–cat-blob-fd</strong> or
<strong>stdout</strong> if unspecified.</p>
</blockquote>
<p>
<strong>feature</strong></p>
<blockquote>
<p>Enable the specified feature. This requires that fast-import supports
the specified feature, and aborts if it does not.</p>
</blockquote>
<p>
<strong>option</strong></p>
<blockquote>
<p>Specify any of the options listed under OPTIONS that do not change
stream semantic to suit the frontend&#39;s needs. This command is optional
and is not needed to perform an import.</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-17" class="outline-3">
<h3 id="headline-17">
<strong>commit</strong>
</h3>
<div id="outline-text-headline-17" class="outline-text-3">
<p>Create or update a branch with a new commit, recording one logical
change to the project.</p>
<blockquote>
<pre class="example">
        commit SP &lt;ref&gt; LF
        mark?
        original-oid?
        (author (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF)?
        committer (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF
        (encoding SP &lt;encoding&gt;)?
        data
        (from SP &lt;commit-ish&gt; LF)?
        (merge SP &lt;commit-ish&gt; LF)*
        (filemodify | filedelete | filecopy | filerename | filedeleteall | notemodify)*
        LF?
</pre>
</blockquote>
<p>
where <strong>&lt;ref&gt;</strong> is the name of the branch to make the commit on. Typically
branch names are prefixed with <strong>refs/heads/</strong> in Git, so importing the
CVS branch symbol <strong>RELENG-1_0</strong> would use <strong>refs/heads/RELENG-1_0</strong> for the
value of <strong>&lt;ref&gt;</strong>. The value of <strong>&lt;ref&gt;</strong> must be a valid refname in Git.
As <strong>LF</strong> is not valid in a Git refname, no quoting or escaping syntax is
supported here.</p>
<p>
A <strong>mark</strong> command may optionally appear, requesting fast-import to save a
reference to the newly created commit for future use by the frontend
(see below for format). It is very common for frontends to mark every
commit they create, thereby allowing future branch creation from any
imported commit.</p>
<p>
The <strong>data</strong> command following <strong>committer</strong> must supply the commit message
(see below for <strong>data</strong> command syntax). To import an empty commit message
use a 0 length data. Commit messages are free-form and are not
interpreted by Git. Currently they must be encoded in UTF-8, as
fast-import does not permit other encodings to be specified.</p>
<p>
Zero or more <strong>filemodify</strong>, <strong>filedelete</strong>, <strong>filecopy</strong>, <strong>filerename</strong>,
<strong>filedeleteall</strong> and <strong>notemodify</strong> commands may be included to update the
contents of the branch prior to creating the commit. These commands may
be supplied in any order. However it is recommended that a
<strong>filedeleteall</strong> command precede all <strong>filemodify</strong>, <strong>filecopy</strong>,
<strong>filerename</strong> and <strong>notemodify</strong> commands in the same commit, as
<strong>filedeleteall</strong> wipes the branch clean (see below).</p>
<p>
The <strong>LF</strong> after the command is optional (it used to be required). Note
that for reasons of backward compatibility, if the commit ends with a
<strong>data</strong> command (i.e. it has no <strong>from</strong>, <strong>merge</strong>, <strong>filemodify</strong>,
<strong>filedelete</strong>, <strong>filecopy</strong>, <strong>filerename</strong>, <strong>filedeleteall</strong> or <strong>notemodify</strong>
commands) then two <strong>LF</strong> commands may appear at the end of the command
instead of just one.</p>
<p>
\\</p>
<p>
<strong>author</strong></p>
<blockquote>
<p>An <strong>author</strong> command may optionally appear, if the author information
might differ from the committer information. If <strong>author</strong> is omitted then
fast-import will automatically use the committer&#39;s information for the
author portion of the commit. See below for a description of the fields
in <strong>author</strong>, as they are identical to <strong>committer</strong>.</p>
</blockquote>
<p>
\\</p>
<p>
<strong>committer</strong></p>
<blockquote>
<p>The <strong>committer</strong> command indicates who made this commit, and when they
made it.</p>
<p>
Here <strong>&lt;name&gt;</strong> is the person&#39;s display name (for example “Com M Itter”)
and <strong>&lt;email&gt;</strong> is the person&#39;s email address (“cm@example.com”). <strong>LT</strong> and
<strong>GT</strong> are the literal less-than (\x3c) and greater-than (\x3e) symbols.
These are required to delimit the email address from the other fields in
the line. Note that <strong>&lt;name&gt;</strong> and <strong>&lt;email&gt;</strong> are free-form and may contain
any sequence of bytes, except <strong>LT</strong>, <strong>GT</strong> and <strong>LF</strong>. <strong>&lt;name&gt;</strong> is typically
UTF-8 encoded.</p>
<p>
The time of the change is specified by <strong>&lt;when&gt;</strong> using the date format
that was selected by the –date-format=&lt;fmt&gt; command-line option. See
“Date Formats” above for the set of supported formats, and their syntax.</p>
</blockquote>
<p>
\\</p>
<p>
<strong>encoding</strong></p>
<blockquote>
<p>The optional <strong>encoding</strong> command indicates the encoding of the commit
message. Most commits are UTF-8 and the encoding is omitted, but this
allows importing commit messages into git without first reencoding them.</p>
</blockquote>
<p>
\\</p>
<p>
<strong>from</strong></p>
<blockquote>
<p>The <strong>from</strong> command is used to specify the commit to initialize this
branch from. This revision will be the first ancestor of the new commit.
The state of the tree built at this commit will begin with the state at
the <strong>from</strong> commit, and be altered by the content modifications in this
commit.</p>
<p>
Omitting the <strong>from</strong> command in the first commit of a new branch will
cause fast-import to create that commit with no ancestor. This tends to
be desired only for the initial commit of a project. If the frontend
creates all files from scratch when making a new branch, a <strong>merge</strong>
command may be used instead of <strong>from</strong> to start the commit with an empty
tree. Omitting the <strong>from</strong> command on existing branches is usually
desired, as the current commit on that branch is automatically assumed
to be the first ancestor of the new commit.</p>
<p>
As <strong>LF</strong> is not valid in a Git refname or SHA-1 expression, no quoting or
escaping syntax is supported within <strong>&lt;commit-ish&gt;</strong>.</p>
<p>
Here <strong>&lt;commit-ish&gt;</strong> is any of the following:</p>
<blockquote>
<p>·</p>
<p>
The name of an existing branch already in fast-import&#39;s internal branch
table. If fast-import doesn&#39;t know the name, it&#39;s treated as a SHA-1
expression.</p>
</blockquote>
<blockquote>
<p>·</p>
<p>
A mark reference, <strong>:&lt;idnum&gt;</strong>, where <strong>&lt;idnum&gt;</strong> is the mark number.</p>
<p>
The reason fast-import uses <strong>:</strong> to denote a mark reference is this
character is not legal in a Git branch name. The leading <strong>:</strong> makes it
easy to distinguish between the mark 42 (<strong>:42</strong>) and the branch 42 (<strong>42</strong>
or <strong>refs/heads/42</strong>), or an abbreviated SHA-1 which happened to consist
only of base-10 digits.</p>
<p>
Marks must be declared (via <strong>mark</strong>) before they can be used.</p>
</blockquote>
<blockquote>
<p>·</p>
<p>
A complete 40 byte or abbreviated commit SHA-1 in hex.</p>
</blockquote>
<blockquote>
<p>·</p>
<p>
Any valid Git SHA-1 expression that resolves to a commit. See
“SPECIFYING REVISIONS” in *gitrevisions*(7) for details.</p>
</blockquote>
<blockquote>
<p>·</p>
<p>
The special null SHA-1 (40 zeros) specifies that the branch is to be
removed.</p>
</blockquote>
<p>
The special case of restarting an incremental import from the current
branch value should be written as:</p>
<blockquote>
<pre class="example">
        from refs/heads/branch^0
</pre>
</blockquote>
<p>
The <strong>^0</strong> suffix is necessary as fast-import does not permit a branch to
start from itself, and the branch is created in memory before the <strong>from</strong>
command is even read from the input. Adding <strong>^0</strong> will force fast-import
to resolve the commit through Git&#39;s revision parsing library, rather
than its internal branch table, thereby loading in the existing value of
the branch.</p>
</blockquote>
<p>
\\</p>
<p>
<strong>merge</strong></p>
<blockquote>
<p>Includes one additional ancestor commit. The additional ancestry link
does not change the way the tree state is built at this commit. If the
<strong>from</strong> command is omitted when creating a new branch, the first <strong>merge</strong>
commit will be the first ancestor of the current commit, and the branch
will start out with no files. An unlimited number of <strong>merge</strong> commands
per commit are permitted by fast-import, thereby establishing an n-way
merge.</p>
<p>
Here <strong>&lt;commit-ish&gt;</strong> is any of the commit specification expressions also
accepted by <strong>from</strong> (see above).</p>
</blockquote>
<p>
\\</p>
<p>
<strong>filemodify</strong></p>
<blockquote>
<p>Included in a <strong>commit</strong> command to add a new file or change the content
of an existing file. This command has two different means of specifying
the content of the file.</p>
<p>
External data format</p>
<blockquote>
<p>The data content for the file was already supplied by a prior <strong>blob</strong>
command. The frontend just needs to connect it.</p>
<blockquote>
<pre class="example">
        M SP &lt;mode&gt; SP &lt;dataref&gt; SP &lt;path&gt; LF
</pre>
</blockquote>
<p>
Here usually <strong>&lt;dataref&gt;</strong> must be either a mark reference (<strong>:&lt;idnum&gt;</strong>)
set by a prior <strong>blob</strong> command, or a full 40-byte SHA-1 of an existing
Git blob object. If <strong>&lt;mode&gt;</strong> is <strong>040000`</strong> then <strong>&lt;dataref&gt;</strong> must be the
full 40-byte SHA-1 of an existing Git tree object or a mark reference
set with <strong>–import-marks</strong>.</p>
</blockquote>
<p>
Inline data format</p>
<blockquote>
<p>The data content for the file has not been supplied yet. The frontend
wants to supply it as part of this modify command.</p>
<blockquote>
<pre class="example">
        M SP &lt;mode&gt; SP inline SP &lt;path&gt; LF
        data
</pre>
</blockquote>
<p>
See below for a detailed description of the <strong>data</strong> command.</p>
</blockquote>
<p>
In both formats <strong>&lt;mode&gt;</strong> is the type of file entry, specified in octal.
Git only supports the following modes:</p>
<blockquote>
<p>·</p>
<p>
<strong>100644</strong> or <strong>644</strong>: A normal (not-executable) file. The majority of files
in most projects use this mode. If in doubt, this is what you want.</p>
</blockquote>
<blockquote>
<p>·</p>
<p>
<strong>100755</strong> or <strong>755</strong>: A normal, but executable, file.</p>
</blockquote>
<blockquote>
<p>·</p>
<p>
<strong>120000</strong>: A symlink, the content of the file will be the link target.</p>
</blockquote>
<blockquote>
<p>·</p>
<p>
<strong>160000</strong>: A gitlink, SHA-1 of the object refers to a commit in another
repository. Git links can only be specified either by SHA or through a
commit mark. They are used to implement submodules.</p>
</blockquote>
<blockquote>
<p>·</p>
<p>
<strong>040000</strong>: A subdirectory. Subdirectories can only be specified by SHA or
through a tree mark set with <strong>–import-marks</strong>.</p>
</blockquote>
<p>
In both formats <strong>&lt;path&gt;</strong> is the complete path of the file to be added
(if not already existing) or modified (if already existing).</p>
<p>
A <strong>&lt;path&gt;</strong> can be written as unquoted bytes or a C-style quoted string.</p>
<p>
When a <strong>&lt;path&gt;</strong> does not start with a double quote (<strong>&#34;</strong>), it is an
unquoted string and is parsed as literal bytes without any escape
sequences. However, if the filename contains <strong>LF</strong> or starts with double
quote, it cannot be represented as an unquoted string and must be
quoted. Additionally, the source <strong>&lt;path&gt;</strong> in <strong>filecopy</strong> or <strong>filerename</strong>
must be quoted if it contains SP.</p>
<p>
When a <strong>&lt;path&gt;</strong> starts with a double quote (<strong>&#34;</strong>), it is a C-style quoted
string, where the complete filename is enclosed in a pair of double
quotes and escape sequences are used. Certain characters must be escaped
by preceding them with a backslash: <strong>LF</strong> is written as <strong>\n</strong>, backslash
as <strong>\\</strong>, and double quote as <strong>\&#34;</strong>. Some characters may optionally be
written with escape sequences: <strong>\a</strong> for bell, <strong>\b</strong> for backspace, <strong>\f</strong>
for form feed, <strong>\n</strong> for line feed, <strong>\r</strong> for carriage return, <strong>\t</strong> for
horizontal tab, and <strong>\v</strong> for vertical tab. Any byte can be written with
3-digit octal codes (e.g., <strong>\033</strong>). All filenames can be represented as
quoted strings.</p>
<p>
A <strong>&lt;path&gt;</strong> must use UNIX-style directory separators (forward slash <strong>/</strong>)
and its value must be in canonical form. That is it must not:</p>
<blockquote>
<p>·</p>
<p>
contain an empty directory component (e.g. <strong>foo//bar</strong> is invalid),</p>
</blockquote>
<blockquote>
<p>·</p>
<p>
end with a directory separator (e.g. <strong>foo/</strong> is invalid),</p>
</blockquote>
<blockquote>
<p>·</p>
<p>
start with a directory separator (e.g. <strong>/foo</strong> is invalid),</p>
</blockquote>
<blockquote>
<p>·</p>
<p>
contain the special component <strong>.</strong> or <strong>..</strong> (e.g. <strong>foo/./bar</strong> and
<strong>foo/../bar</strong> are invalid).</p>
</blockquote>
<p>
The root of the tree can be represented by an empty string as <strong>&lt;path&gt;</strong>.</p>
<p>
<strong>&lt;path&gt;</strong> cannot contain NUL, either literally or escaped as <strong>\000</strong>. It
is recommended that <strong>&lt;path&gt;</strong> always be encoded using UTF-8.</p>
</blockquote>
<p>
\\</p>
<p>
<strong>filedelete</strong></p>
<blockquote>
<p>Included in a <strong>commit</strong> command to remove a file or recursively delete an
entire directory from the branch. If the file or directory removal makes
its parent directory empty, the parent directory will be automatically
removed too. This cascades up the tree until the first non-empty
directory or the root is reached.</p>
<blockquote>
<pre class="example">
        D SP &lt;path&gt; LF
</pre>
</blockquote>
<p>
here <strong>&lt;path&gt;</strong> is the complete path of the file or subdirectory to be
removed from the branch. See <strong>filemodify</strong> above for a detailed
description of <strong>&lt;path&gt;</strong>.</p>
</blockquote>
<p>
\\</p>
<p>
<strong>filecopy</strong></p>
<blockquote>
<p>Recursively copies an existing file or subdirectory to a different
location within the branch. The existing file or directory must exist.
If the destination exists it will be completely replaced by the content
copied from the source.</p>
<blockquote>
<pre class="example">
        C SP &lt;path&gt; SP &lt;path&gt; LF
</pre>
</blockquote>
<p>
here the first <strong>&lt;path&gt;</strong> is the source location and the second <strong>&lt;path&gt;</strong>
is the destination. See <strong>filemodify</strong> above for a detailed description of
what <strong>&lt;path&gt;</strong> may look like. To use a source path that contains SP the
path must be quoted.</p>
<p>
A <strong>filecopy</strong> command takes effect immediately. Once the source location
has been copied to the destination any future commands applied to the
source location will not impact the destination of the copy.</p>
</blockquote>
<p>
\\</p>
<p>
<strong>filerename</strong></p>
<blockquote>
<p>Renames an existing file or subdirectory to a different location within
the branch. The existing file or directory must exist. If the
destination exists it will be replaced by the source directory.</p>
<blockquote>
<pre class="example">
        R SP &lt;path&gt; SP &lt;path&gt; LF
</pre>
</blockquote>
<p>
here the first <strong>&lt;path&gt;</strong> is the source location and the second <strong>&lt;path&gt;</strong>
is the destination. See <strong>filemodify</strong> above for a detailed description of
what <strong>&lt;path&gt;</strong> may look like. To use a source path that contains SP the
path must be quoted.</p>
<p>
A <strong>filerename</strong> command takes effect immediately. Once the source
location has been renamed to the destination any future commands applied
to the source location will create new files there and not impact the
destination of the rename.</p>
<p>
Note that a <strong>filerename</strong> is the same as a <strong>filecopy</strong> followed by a
<strong>filedelete</strong> of the source location. There is a slight performance
advantage to using <strong>filerename</strong>, but the advantage is so small that it
is never worth trying to convert a delete/add pair in source material
into a rename for fast-import. This <strong>filerename</strong> command is provided
just to simplify frontends that already have rename information and
don&#39;t want bother with decomposing it into a <strong>filecopy</strong> followed by a
<strong>filedelete</strong>.</p>
</blockquote>
<p>
\\</p>
<p>
<strong>filedeleteall</strong></p>
<blockquote>
<p>Included in a <strong>commit</strong> command to remove all files (and also all
directories) from the branch. This command resets the internal branch
structure to have no files in it, allowing the frontend to subsequently
add all interesting files from scratch.</p>
<blockquote>
<pre class="example">
        deleteall LF
</pre>
</blockquote>
<p>
This command is extremely useful if the frontend does not know (or does
not care to know) what files are currently on the branch, and therefore
cannot generate the proper <strong>filedelete</strong> commands to update the content.</p>
<p>
Issuing a <strong>filedeleteall</strong> followed by the needed <strong>filemodify</strong> commands
to set the correct content will produce the same results as sending only
the needed <strong>filemodify</strong> and <strong>filedelete</strong> commands. The <strong>filedeleteall</strong>
approach may however require fast-import to use slightly more memory per
active branch (less than 1 MiB for even most large projects); so
frontends that can easily obtain only the affected paths for a commit
are encouraged to do so.</p>
</blockquote>
<p>
\\</p>
<p>
<strong>notemodify</strong></p>
<blockquote>
<p>Included in a <strong>commit</strong> <strong>&lt;notes-ref&gt;</strong> command to add a new note
annotating a <strong>&lt;commit-ish&gt;</strong> or change this annotation contents.
Internally it is similar to filemodify 100644 on <strong>&lt;commit-ish&gt;</strong> path
(maybe split into subdirectories). It&#39;s not advised to use any other
commands to write to the <strong>&lt;notes-ref&gt;</strong> tree except <strong>filedeleteall</strong> to
delete all existing notes in this tree. This command has two different
means of specifying the content of the note.</p>
<p>
External data format</p>
<blockquote>
<p>The data content for the note was already supplied by a prior <strong>blob</strong>
command. The frontend just needs to connect it to the commit that is to
be annotated.</p>
<blockquote>
<pre class="example">
        N SP &lt;dataref&gt; SP &lt;commit-ish&gt; LF
</pre>
</blockquote>
<p>
Here <strong>&lt;dataref&gt;</strong> can be either a mark reference (<strong>:&lt;idnum&gt;</strong>) set by a
prior <strong>blob</strong> command, or a full 40-byte SHA-1 of an existing Git blob
object.</p>
</blockquote>
<p>
Inline data format</p>
<blockquote>
<p>The data content for the note has not been supplied yet. The frontend
wants to supply it as part of this modify command.</p>
<blockquote>
<pre class="example">
        N SP inline SP &lt;commit-ish&gt; LF
        data
</pre>
</blockquote>
<p>
See below for a detailed description of the <strong>data</strong> command.</p>
</blockquote>
<p>
In both formats <strong>&lt;commit-ish&gt;</strong> is any of the commit specification
expressions also accepted by <strong>from</strong> (see above).</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-18" class="outline-3">
<h3 id="headline-18">
<strong>mark</strong>
</h3>
<div id="outline-text-headline-18" class="outline-text-3">
<p>Arranges for fast-import to save a reference to the current object,
allowing the frontend to recall this object at a future point in time,
without knowing its SHA-1. Here the current object is the object
creation command the <strong>mark</strong> command appears within. This can be
<strong>commit</strong>, <strong>tag</strong>, and <strong>blob</strong>, but <strong>commit</strong> is the most common usage.</p>
<blockquote>
<pre class="example">
        mark SP : &lt;idnum&gt; LF
</pre>
</blockquote>
<p>
where <strong>&lt;idnum&gt;</strong> is the number assigned by the frontend to this mark. The
value of <strong>&lt;idnum&gt;</strong> is expressed as an ASCII decimal integer. The value 0
is reserved and cannot be used as a mark. Only values greater than or
equal to 1 may be used as marks.</p>
<p>
New marks are created automatically. Existing marks can be moved to
another object simply by reusing the same <strong>&lt;idnum&gt;</strong> in another <strong>mark</strong>
command.</p>
</div>
</div>
<div id="outline-container-headline-19" class="outline-3">
<h3 id="headline-19">
<strong>original-oid</strong>
</h3>
<div id="outline-text-headline-19" class="outline-text-3">
<p>Provides the name of the object in the original source control system.
fast-import will simply ignore this directive, but filter processes
which operate on and modify the stream before feeding to fast-import may
have uses for this information</p>
<blockquote>
<pre class="example">
        original-oid SP &lt;object-identifier&gt; LF
</pre>
</blockquote>
<p>
where <strong>&lt;object-identifier&gt;</strong> is any string not containing LF.</p>
</div>
</div>
<div id="outline-container-headline-20" class="outline-3">
<h3 id="headline-20">
<strong>tag</strong>
</h3>
<div id="outline-text-headline-20" class="outline-text-3">
<p>Creates an annotated tag referring to a specific commit. To create
lightweight (non-annotated) tags see the <strong>reset</strong> command below.</p>
<blockquote>
<pre class="example">
        tag SP &lt;name&gt; LF
        mark?
        from SP &lt;commit-ish&gt; LF
        original-oid?
        tagger (SP &lt;name&gt;)? SP LT &lt;email&gt; GT SP &lt;when&gt; LF
        data
</pre>
</blockquote>
<p>
where <strong>&lt;name&gt;</strong> is the name of the tag to create.</p>
<p>
Tag names are automatically prefixed with <strong>refs/tags/</strong> when stored in
Git, so importing the CVS branch symbol <strong>RELENG-1_0-FINAL</strong> would use
just <strong>RELENG-1_0-FINAL</strong> for <strong>&lt;name&gt;</strong>, and fast-import will write the
corresponding ref as <strong>refs/tags/RELENG-1_0-FINAL</strong>.</p>
<p>
The value of <strong>&lt;name&gt;</strong> must be a valid refname in Git and therefore may
contain forward slashes. As <strong>LF</strong> is not valid in a Git refname, no
quoting or escaping syntax is supported here.</p>
<p>
The <strong>from</strong> command is the same as in the <strong>commit</strong> command; see above for
details.</p>
<p>
The <strong>tagger</strong> command uses the same format as <strong>committer</strong> within
<strong>commit</strong>; again see above for details.</p>
<p>
The <strong>data</strong> command following <strong>tagger</strong> must supply the annotated tag
message (see below for <strong>data</strong> command syntax). To import an empty tag
message use a 0 length data. Tag messages are free-form and are not
interpreted by Git. Currently they must be encoded in UTF-8, as
fast-import does not permit other encodings to be specified.</p>
<p>
Signing annotated tags during import from within fast-import is not
supported. Trying to include your own PGP/GPG signature is not
recommended, as the frontend does not (easily) have access to the
complete set of bytes which normally goes into such a signature. If
signing is required, create lightweight tags from within fast-import
with <strong>reset</strong>, then create the annotated versions of those tags offline
with the standard <em>git tag</em> process.</p>
</div>
</div>
<div id="outline-container-headline-21" class="outline-3">
<h3 id="headline-21">
<strong>reset</strong>
</h3>
<div id="outline-text-headline-21" class="outline-text-3">
<p>Creates (or recreates) the named branch, optionally starting from a
specific revision. The reset command allows a frontend to issue a new
<strong>from</strong> command for an existing branch, or to create a new branch from an
existing commit without creating a new commit.</p>
<blockquote>
<pre class="example">
        reset SP &lt;ref&gt; LF
        (from SP &lt;commit-ish&gt; LF)?
        LF?
</pre>
</blockquote>
<p>
For a detailed description of <strong>&lt;ref&gt;</strong> and <strong>&lt;commit-ish&gt;</strong> see above under
<strong>commit</strong> and <strong>from</strong>.</p>
<p>
The <strong>LF</strong> after the command is optional (it used to be required).</p>
<p>
The <strong>reset</strong> command can also be used to create lightweight
(non-annotated) tags. For example:</p>
<blockquote>
<pre class="example">
reset refs/tags/938
from :938
</pre>
</blockquote>
<p>
would create the lightweight tag <strong>refs/tags/938</strong> referring to whatever
commit mark <strong>:938</strong> references.</p>
</div>
</div>
<div id="outline-container-headline-22" class="outline-3">
<h3 id="headline-22">
<strong>blob</strong>
</h3>
<div id="outline-text-headline-22" class="outline-text-3">
<p>Requests writing one file revision to the packfile. The revision is not
connected to any commit; this connection must be formed in a subsequent
<strong>commit</strong> command by referencing the blob through an assigned mark.</p>
<blockquote>
<pre class="example">
        blob LF
        mark?
        original-oid?
        data
</pre>
</blockquote>
<p>
The mark command is optional here as some frontends have chosen to
generate the Git SHA-1 for the blob on their own, and feed that directly
to <strong>commit</strong>. This is typically more work than it&#39;s worth however, as
marks are inexpensive to store and easy to use.</p>
</div>
</div>
<div id="outline-container-headline-23" class="outline-3">
<h3 id="headline-23">
<strong>data</strong>
</h3>
<div id="outline-text-headline-23" class="outline-text-3">
<p>Supplies raw data (for use as blob/file content, commit messages, or
annotated tag messages) to fast-import. Data can be supplied using an
exact byte count or delimited with a terminating line. Real frontends
intended for production-quality conversions should always use the exact
byte count format, as it is more robust and performs better. The
delimited format is intended primarily for testing fast-import.</p>
<p>
Comment lines appearing within the <strong>&lt;raw&gt;</strong> part of <strong>data</strong> commands are
always taken to be part of the body of the data and are therefore never
ignored by fast-import. This makes it safe to import any file/message
content whose lines might start with <strong>#</strong>.</p>
<p>
Exact byte count format</p>
<blockquote>
<p>The frontend must specify the number of bytes of data.</p>
<blockquote>
<pre class="example">
        data SP &lt;count&gt; LF
        &lt;raw&gt; LF?
</pre>
</blockquote>
<p>
where <strong>&lt;count&gt;</strong> is the exact number of bytes appearing within <strong>&lt;raw&gt;</strong>.
The value of <strong>&lt;count&gt;</strong> is expressed as an ASCII decimal integer. The
<strong>LF</strong> on either side of <strong>&lt;raw&gt;</strong> is not included in <strong>&lt;count&gt;</strong> and will not
be included in the imported data.</p>
<p>
The <strong>LF</strong> after <strong>&lt;raw&gt;</strong> is optional (it used to be required) but
recommended. Always including it makes debugging a fast-import stream
easier as the next command always starts in column 0 of the next line,
even if <strong>&lt;raw&gt;</strong> did not end with an <strong>LF</strong>.</p>
</blockquote>
<p>
Delimited format</p>
<blockquote>
<p>A delimiter string is used to mark the end of the data. fast-import will
compute the length by searching for the delimiter. This format is
primarily useful for testing and is not recommended for real data.</p>
<blockquote>
<pre class="example">
        data SP &lt;&lt; &lt;delim&gt; LF
        &lt;raw&gt; LF
        &lt;delim&gt; LF
        LF?
</pre>
</blockquote>
<p>
where <strong>&lt;delim&gt;</strong> is the chosen delimiter string. The string <strong>&lt;delim&gt;</strong>
must not appear on a line by itself within <strong>&lt;raw&gt;</strong>, as otherwise
fast-import will think the data ends earlier than it really does. The
<strong>LF</strong> immediately trailing <strong>&lt;raw&gt;</strong> is part of <strong>&lt;raw&gt;</strong>. This is one of the
limitations of the delimited format, it is impossible to supply a data
chunk which does not have an LF as its last byte.</p>
<p>
The <strong>LF</strong> after <strong>&lt;delim&gt; LF</strong> is optional (it used to be required).</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-24" class="outline-3">
<h3 id="headline-24">
<strong>alias</strong>
</h3>
<div id="outline-text-headline-24" class="outline-text-3">
<p>Record that a mark refers to a given object without first creating any
new object.</p>
<blockquote>
<pre class="example">
        alias LF
        mark
        to SP &lt;commit-ish&gt; LF
        LF?
</pre>
</blockquote>
<p>
For a detailed description of <strong>&lt;commit-ish&gt;</strong> see above under <strong>from</strong>.</p>
</div>
</div>
<div id="outline-container-headline-25" class="outline-3">
<h3 id="headline-25">
<strong>checkpoint</strong>
</h3>
<div id="outline-text-headline-25" class="outline-text-3">
<p>Forces fast-import to close the current packfile, start a new one, and
to save out all current branch refs, tags and marks.</p>
<blockquote>
<pre class="example">
        checkpoint LF
        LF?
</pre>
</blockquote>
<p>
Note that fast-import automatically switches packfiles when the current
packfile reaches –max-pack-size, or 4 GiB, whichever limit is smaller.
During an automatic packfile switch fast-import does not update the
branch refs, tags or marks.</p>
<p>
As a <strong>checkpoint</strong> can require a significant amount of CPU time and disk
IO (to compute the overall pack SHA-1 checksum, generate the
corresponding index file, and update the refs) it can easily take
several minutes for a single <strong>checkpoint</strong> command to complete.</p>
<p>
Frontends may choose to issue checkpoints during extremely large and
long running imports, or when they need to allow another Git process
access to a branch. However given that a 30 GiB Subversion repository
can be loaded into Git through fast-import in about 3 hours, explicit
checkpointing may not be necessary.</p>
<p>
The <strong>LF</strong> after the command is optional (it used to be required).</p>
</div>
</div>
<div id="outline-container-headline-26" class="outline-3">
<h3 id="headline-26">
<strong>progress</strong>
</h3>
<div id="outline-text-headline-26" class="outline-text-3">
<p>Causes fast-import to print the entire <strong>progress</strong> line unmodified to its
standard output channel (file descriptor 1) when the command is
processed from the input stream. The command otherwise has no impact on
the current import, or on any of fast-import&#39;s internal state.</p>
<blockquote>
<pre class="example">
        progress SP &lt;any&gt; LF
        LF?
</pre>
</blockquote>
<p>
The <strong>&lt;any&gt;</strong> part of the command may contain any sequence of bytes that
does not contain <strong>LF</strong>. The <strong>LF</strong> after the command is optional. Callers
may wish to process the output through a tool such as sed to remove the
leading part of the line, for example:</p>
<blockquote>
<pre class="example">
frontend | git fast-import | sed s/^progress //
</pre>
</blockquote>
<p>
Placing a <strong>progress</strong> command immediately after a <strong>checkpoint</strong> will
inform the reader when the <strong>checkpoint</strong> has been completed and it can
safely access the refs that fast-import updated.</p>
</div>
</div>
<div id="outline-container-headline-27" class="outline-3">
<h3 id="headline-27">
<strong>get-mark</strong>
</h3>
<div id="outline-text-headline-27" class="outline-text-3">
<p>Causes fast-import to print the SHA-1 corresponding to a mark to stdout
or to the file descriptor previously arranged with the <strong>–cat-blob-fd</strong>
argument. The command otherwise has no impact on the current import; its
purpose is to retrieve SHA-1s that later commits might want to refer to
in their commit messages.</p>
<blockquote>
<pre class="example">
        get-mark SP : &lt;idnum&gt; LF
</pre>
</blockquote>
<p>
See “Responses To Commands” below for details about how to read this
output safely.</p>
</div>
</div>
<div id="outline-container-headline-28" class="outline-3">
<h3 id="headline-28">
<strong>cat-blob</strong>
</h3>
<div id="outline-text-headline-28" class="outline-text-3">
<p>Causes fast-import to print a blob to a file descriptor previously
arranged with the <strong>–cat-blob-fd</strong> argument. The command otherwise has no
impact on the current import; its main purpose is to retrieve blobs that
may be in fast-import&#39;s memory but not accessible from the target
repository.</p>
<blockquote>
<pre class="example">
        cat-blob SP &lt;dataref&gt; LF
</pre>
</blockquote>
<p>
The <strong>&lt;dataref&gt;</strong> can be either a mark reference (<strong>:&lt;idnum&gt;</strong>) set
previously or a full 40-byte SHA-1 of a Git blob, preexisting or ready
to be written.</p>
<p>
Output uses the same format as <strong>git cat-file –batch</strong>:</p>
<blockquote>
<pre class="example">
&lt;sha1&gt; SP blob SP &lt;size&gt; LF
&lt;contents&gt; LF
</pre>
</blockquote>
<p>
This command can be used where a <strong>filemodify</strong> directive can appear,
allowing it to be used in the middle of a commit. For a <strong>filemodify</strong>
using an inline directive, it can also appear right before the <strong>data</strong>
directive.</p>
<p>
See “Responses To Commands” below for details about how to read this
output safely.</p>
</div>
</div>
<div id="outline-container-headline-29" class="outline-3">
<h3 id="headline-29">
<strong>ls</strong>
</h3>
<div id="outline-text-headline-29" class="outline-text-3">
<p>Prints information about the object at a path to a file descriptor
previously arranged with the <strong>–cat-blob-fd</strong> argument. This allows
printing a blob from the active commit (with <strong>cat-blob</strong>) or copying a
blob or tree from a previous commit for use in the current one (with
<strong>filemodify</strong>).</p>
<p>
The <strong>ls</strong> command can also be used where a <strong>filemodify</strong> directive can
appear, allowing it to be used in the middle of a commit.</p>
<p>
Reading from the active commit</p>
<blockquote>
<p>This form can only be used in the middle of a <strong>commit</strong>. The path names a
directory entry within fast-import&#39;s active commit. The path must be
quoted in this case.</p>
<blockquote>
<pre class="example">
        ls SP &lt;path&gt; LF
</pre>
</blockquote>
</blockquote>
<p>
Reading from a named tree</p>
<blockquote>
<p>The <strong>&lt;dataref&gt;</strong> can be a mark reference (<strong>:&lt;idnum&gt;</strong>) or the full 40-byte
SHA-1 of a Git tag, commit, or tree object, preexisting or waiting to be
written. The path is relative to the top level of the tree named by
<strong>&lt;dataref&gt;</strong>.</p>
<blockquote>
<pre class="example">
        ls SP &lt;dataref&gt; SP &lt;path&gt; LF
</pre>
</blockquote>
</blockquote>
<p>
See <strong>filemodify</strong> above for a detailed description of <strong>&lt;path&gt;</strong>.</p>
<p>
Output uses the same format as <strong>git ls-tree &lt;tree&gt; – &lt;path&gt;</strong>:</p>
<blockquote>
<pre class="example">
&lt;mode&gt; SP (blob | tree | commit) SP &lt;dataref&gt; HT &lt;path&gt; LF
</pre>
</blockquote>
<p>
The &lt;dataref&gt; represents the blob, tree, or commit object at &lt;path&gt; and
can be used in later <em>get-mark</em>, <em>cat-blob</em>, <em>filemodify</em>, or <em>ls</em>
commands.</p>
<p>
If there is no file or subtree at that path, <em>git fast-import</em> will
instead report</p>
<blockquote>
<pre class="example">
missing SP &lt;path&gt; LF
</pre>
</blockquote>
<p>
See “Responses To Commands” below for details about how to read this
output safely.</p>
</div>
</div>
<div id="outline-container-headline-30" class="outline-3">
<h3 id="headline-30">
<strong>feature</strong>
</h3>
<div id="outline-text-headline-30" class="outline-text-3">
<p>Require that fast-import supports the specified feature, or abort if it
does not.</p>
<blockquote>
<pre class="example">
        feature SP &lt;feature&gt; (= &lt;argument&gt;)? LF
</pre>
</blockquote>
<p>
The &lt;feature&gt; part of the command may be any one of the following:</p>
<p>
date-format, export-marks, relative-marks, no-relative-marks, force</p>
<blockquote>
<p>Act as though the corresponding command-line option with a leading <strong>–</strong>
was passed on the command line (see OPTIONS, above).</p>
</blockquote>
<p>
import-marks, import-marks-if-exists</p>
<blockquote>
<p>Like –import-marks except in two respects: first, only one &#34;feature
import-marks&#34; or &#34;feature import-marks-if-exists&#34; command is allowed per
stream; second, an –import-marks= or –import-marks-if-exists
command-line option overrides any of these &#34;feature&#34; commands in the
stream; third, &#34;feature import-marks-if-exists&#34; like a corresponding
command-line option silently skips a nonexistent file.</p>
</blockquote>
<p>
get-mark, cat-blob, ls</p>
<blockquote>
<p>Require that the backend support the <em>get-mark</em>, <em>cat-blob</em>, or <em>ls</em>
command respectively. Versions of fast-import not supporting the
specified command will exit with a message indicating so. This lets the
import error out early with a clear message, rather than wasting time on
the early part of an import before the unsupported command is detected.</p>
</blockquote>
<p>
notes</p>
<blockquote>
<p>Require that the backend support the <em>notemodify</em> (N) subcommand to the
<em>commit</em> command. Versions of fast-import not supporting notes will exit
with a message indicating so.</p>
</blockquote>
<p>
done</p>
<blockquote>
<p>Error out if the stream ends without a <em>done</em> command. Without this
feature, errors causing the frontend to end abruptly at a convenient
point in the stream can go undetected. This may occur, for example, if
an import front end dies in mid-operation without emitting SIGTERM or
SIGKILL at its subordinate git fast-import instance.</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-31" class="outline-3">
<h3 id="headline-31">
<strong>option</strong>
</h3>
<div id="outline-text-headline-31" class="outline-text-3">
<p>Processes the specified option so that git fast-import behaves in a way
that suits the frontend&#39;s needs. Note that options specified by the
frontend are overridden by any options the user may specify to git
fast-import itself.</p>
<blockquote>
<pre class="example">
    option SP &lt;option&gt; LF
</pre>
</blockquote>
<p>
The <strong>&lt;option&gt;</strong> part of the command may contain any of the options listed
in the OPTIONS section that do not change import semantics, without the
leading <strong>–</strong> and is treated in the same way.</p>
<p>
Option commands must be the first commands on the input (not counting
feature commands), to give an option command after any non-option
command is an error.</p>
<p>
The following command-line options change import semantics and may
therefore not be passed as option:</p>
<blockquote>
<p>·</p>
<p>
date-format</p>
</blockquote>
<blockquote>
<p>·</p>
<p>
import-marks</p>
</blockquote>
<blockquote>
<p>·</p>
<p>
export-marks</p>
</blockquote>
<blockquote>
<p>·</p>
<p>
cat-blob-fd</p>
</blockquote>
<blockquote>
<p>·</p>
<p>
force</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-32" class="outline-3">
<h3 id="headline-32">
<strong>done</strong>
</h3>
<div id="outline-text-headline-32" class="outline-text-3">
<p>If the <strong>done</strong> feature is not in use, treated as if EOF was read. This
can be used to tell fast-import to finish early.</p>
<p>
If the <strong>–done</strong> command-line option or <strong>feature done</strong> command is in use,
the <strong>done</strong> command is mandatory and marks the end of the stream.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-33" class="outline-2">
<h2 id="headline-33">
RESPONSES TO COMMANDS
</h2>
<div id="outline-text-headline-33" class="outline-text-2">
<p>New objects written by fast-import are not available immediately. Most
fast-import commands have no visible effect until the next checkpoint
(or completion). The frontend can send commands to fill fast-import&#39;s
input pipe without worrying about how quickly they will take effect,
which improves performance by simplifying scheduling.</p>
<p>
For some frontends, though, it is useful to be able to read back data
from the current repository as it is being updated (for example when the
source material describes objects in terms of patches to be applied to
previously imported objects). This can be accomplished by connecting the
frontend and fast-import via bidirectional pipes:</p>
<blockquote>
<pre class="example">
mkfifo fast-import-output
frontend &lt;fast-import-output |
git fast-import &gt;fast-import-output
</pre>
</blockquote>
<p>
A frontend set up this way can use <strong>progress</strong>, <strong>get-mark</strong>, <strong>ls</strong>, and
<strong>cat-blob</strong> commands to read information from the import in progress.</p>
<p>
To avoid deadlock, such frontends must completely consume any pending
output from <strong>progress</strong>, <strong>ls</strong>, <strong>get-mark</strong>, and <strong>cat-blob</strong> before
performing writes to fast-import that might block.</p>
</div>
</div>
<div id="outline-container-headline-34" class="outline-2">
<h2 id="headline-34">
CRASH REPORTS
</h2>
<div id="outline-text-headline-34" class="outline-text-2">
<p>If fast-import is supplied invalid input it will terminate with a
non-zero exit status and create a crash report in the top level of the
Git repository it was importing into. Crash reports contain a snapshot
of the internal fast-import state as well as the most recent commands
that lead up to the crash.</p>
<p>
All recent commands (including stream comments, file changes and
progress commands) are shown in the command history within the crash
report, but raw file data and commit messages are excluded from the
crash report. This exclusion saves space within the report file and
reduces the amount of buffering that fast-import must perform during
execution.</p>
<p>
After writing a crash report fast-import will close the current packfile
and export the marks table. This allows the frontend developer to
inspect the repository state and resume the import from the point where
it crashed. The modified branches and tags are not updated during a
crash, as the import did not complete successfully. Branch and tag
information can be found in the crash report and must be applied
manually if the update is needed.</p>
<p>
An example crash:</p>
<blockquote>
<pre class="example">
$ cat &gt;in &lt;&lt;END_OF_INPUT
# my very first test commit
commit refs/heads/master
committer Shawn O. Pearce &lt;spearce&gt; 19283 -0400
# who is that guy anyway?
data &lt;&lt;EOF
this is my commit
EOF
M 644 inline .gitignore
data &lt;&lt;EOF
.gitignore
EOF
M 777 inline bob
END_OF_INPUT
</pre>
</blockquote>
<blockquote>
<pre class="example">
$ git fast-import &lt;in
fatal: Corrupt mode: M 777 inline bob
fast-import: dumping crash report to .git/fast_import_crash_8434
</pre>
</blockquote>
<blockquote>
<pre class="example">
$ cat .git/fast_import_crash_8434
fast-import crash report:
    fast-import process: 8434
    parent process     : 1391
    at Sat Sep 1 00:58:12 2007
</pre>
</blockquote>
<blockquote>
<pre class="example">
fatal: Corrupt mode: M 777 inline bob
</pre>
</blockquote>
<blockquote>
<pre class="example">
Most Recent Commands Before Crash
---------------------------------
  # my very first test commit
  commit refs/heads/master
  committer Shawn O. Pearce &lt;spearce&gt; 19283 -0400
  # who is that guy anyway?
  data &lt;&lt;EOF
  M 644 inline .gitignore
  data &lt;&lt;EOF
* M 777 inline bob
</pre>
</blockquote>
<blockquote>
<pre class="example">
Active Branch LRU
-----------------
    active_branches = 1 cur, 5 max
</pre>
</blockquote>
<blockquote>
<pre class="example">
pos  clock name
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1)      0 refs/heads/master
</pre>
</blockquote>
<blockquote>
<pre class="example">
Inactive Branches
-----------------
refs/heads/master:
  status      : active loaded dirty
  tip commit  : 0000000000000000000000000000000000000000
  old tree    : 0000000000000000000000000000000000000000
  cur tree    : 0000000000000000000000000000000000000000
  commit clock: 0
  last pack   :
</pre>
</blockquote>
<blockquote>
<pre class="example">
-------------------
END OF CRASH REPORT
</pre>
</blockquote>
</div>
</div>
<div id="outline-container-headline-35" class="outline-2">
<h2 id="headline-35">
TIPS AND TRICKS
</h2>
<div id="outline-text-headline-35" class="outline-text-2">
<p>The following tips and tricks have been collected from various users of
fast-import, and are offered here as suggestions.</p>
<div id="outline-container-headline-36" class="outline-3">
<h3 id="headline-36">
Use One Mark Per Commit
</h3>
<div id="outline-text-headline-36" class="outline-text-3">
<p>When doing a repository conversion, use a unique mark per commit (<strong>mark
:&lt;n&gt;</strong>) and supply the –export-marks option on the command line.
fast-import will dump a file which lists every mark and the Git object
SHA-1 that corresponds to it. If the frontend can tie the marks back to
the source repository, it is easy to verify the accuracy and
completeness of the import by comparing each Git commit to the
corresponding source revision.</p>
<p>
Coming from a system such as Perforce or Subversion, this should be
quite simple, as the fast-import mark can also be the Perforce changeset
number or the Subversion revision number.</p>
</div>
</div>
<div id="outline-container-headline-37" class="outline-3">
<h3 id="headline-37">
Freely Skip Around Branches
</h3>
<div id="outline-text-headline-37" class="outline-text-3">
<p>Don&#39;t bother trying to optimize the frontend to stick to one branch at a
time during an import. Although doing so might be slightly faster for
fast-import, it tends to increase the complexity of the frontend code
considerably.</p>
<p>
The branch LRU builtin to fast-import tends to behave very well, and the
cost of activating an inactive branch is so low that bouncing around
between branches has virtually no impact on import performance.</p>
</div>
</div>
<div id="outline-container-headline-38" class="outline-3">
<h3 id="headline-38">
Handling Renames
</h3>
<div id="outline-text-headline-38" class="outline-text-3">
<p>When importing a renamed file or directory, simply delete the old
name(s) and modify the new name(s) during the corresponding commit. Git
performs rename detection after-the-fact, rather than explicitly during
a commit.</p>
</div>
</div>
<div id="outline-container-headline-39" class="outline-3">
<h3 id="headline-39">
Use Tag Fixup Branches
</h3>
<div id="outline-text-headline-39" class="outline-text-3">
<p>Some other SCM systems let the user create a tag from multiple files
which are not from the same commit/changeset. Or to create tags which
are a subset of the files available in the repository.</p>
<p>
Importing these tags as-is in Git is impossible without making at least
one commit which “fixes up” the files to match the content of the tag.
Use fast-import&#39;s <strong>reset</strong> command to reset a dummy branch outside of
your normal branch space to the base commit for the tag, then commit one
or more file fixup commits, and finally tag the dummy branch.</p>
<p>
For example since all normal branches are stored under <strong>refs/heads/</strong>
name the tag fixup branch <strong>TAG_FIXUP</strong>. This way it is impossible for the
fixup branch used by the importer to have namespace conflicts with real
branches imported from the source (the name <strong>TAG_FIXUP</strong> is not
<strong>refs/heads/TAG_FIXUP</strong>).</p>
<p>
When committing fixups, consider using <strong>merge</strong> to connect the commit(s)
which are supplying file revisions to the fixup branch. Doing so will
allow tools such as <em>git blame</em> to track through the real commit history
and properly annotate the source files.</p>
<p>
After fast-import terminates the frontend will need to do <strong>rm
.git/TAG_FIXUP</strong> to remove the dummy branch.</p>
</div>
</div>
<div id="outline-container-headline-40" class="outline-3">
<h3 id="headline-40">
Import Now, Repack Later
</h3>
<div id="outline-text-headline-40" class="outline-text-3">
<p>As soon as fast-import completes the Git repository is completely valid
and ready for use. Typically this takes only a very short time, even for
considerably large projects (100,000+ commits).</p>
<p>
However repacking the repository is necessary to improve data locality
and access performance. It can also take hours on extremely large
projects (especially if -f and a large –window parameter is used).
Since repacking is safe to run alongside readers and writers, run the
repack in the background and let it finish when it finishes. There is no
reason to wait to explore your new Git project!</p>
<p>
If you choose to wait for the repack, don&#39;t try to run benchmarks or
performance tests until repacking is completed. fast-import outputs
suboptimal packfiles that are simply never seen in real use situations.</p>
</div>
</div>
<div id="outline-container-headline-41" class="outline-3">
<h3 id="headline-41">
Repacking Historical Data
</h3>
<div id="outline-text-headline-41" class="outline-text-3">
<p>If you are repacking very old imported data (e.g. older than the last
year), consider expending some extra CPU time and supplying –window=50
(or higher) when you run <em>git repack</em>. This will take longer, but will
also produce a smaller packfile. You only need to expend the effort
once, and everyone using your project will benefit from the smaller
repository.</p>
</div>
</div>
<div id="outline-container-headline-42" class="outline-3">
<h3 id="headline-42">
Include Some Progress Messages
</h3>
<div id="outline-text-headline-42" class="outline-text-3">
<p>Every once in a while have your frontend emit a <strong>progress</strong> message to
fast-import. The contents of the messages are entirely free-form, so one
suggestion would be to output the current month and year each time the
current commit date moves into the next month. Your users will feel
better knowing how much of the data stream has been processed.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-43" class="outline-2">
<h2 id="headline-43">
PACKFILE OPTIMIZATION
</h2>
<div id="outline-text-headline-43" class="outline-text-2">
<p>When packing a blob fast-import always attempts to deltify against the
last blob written. Unless specifically arranged for by the frontend,
this will probably not be a prior version of the same file, so the
generated delta will not be the smallest possible. The resulting
packfile will be compressed, but will not be optimal.</p>
<p>
Frontends which have efficient access to all revisions of a single file
(for example reading an RCS/CVS ,v file) can choose to supply all
revisions of that file as a sequence of consecutive <strong>blob</strong> commands.
This allows fast-import to deltify the different file revisions against
each other, saving space in the final packfile. Marks can be used to
later identify individual file revisions during a sequence of <strong>commit</strong>
commands.</p>
<p>
The packfile(s) created by fast-import do not encourage good disk access
patterns. This is caused by fast-import writing the data in the order it
is received on standard input, while Git typically organizes data within
packfiles to make the most recent (current tip) data appear before
historical data. Git also clusters commits together, speeding up
revision traversal through better cache locality.</p>
<p>
For this reason it is strongly recommended that users repack the
repository with <strong>git repack -a -d</strong> after fast-import completes, allowing
Git to reorganize the packfiles for faster data access. If blob deltas
are suboptimal (see above) then also adding the <strong>-f</strong> option to force
recomputation of all deltas can significantly reduce the final packfile
size (30-50% smaller can be quite typical).</p>
<p>
Instead of running <strong>git repack</strong> you can also run <strong>git gc –aggressive</strong>,
which will also optimize other things after an import (e.g. pack loose
refs). As noted in the &#34;AGGRESSIVE&#34; section in <strong>git-gc*(1) the
*–aggressive</strong> option will find new deltas with the <strong>-f</strong> option to
<strong>git-repack*(1). For the reasons elaborated on above using
*–aggressive</strong> after a fast-import is one of the few cases where it&#39;s
known to be worthwhile.</p>
</div>
</div>
<div id="outline-container-headline-44" class="outline-2">
<h2 id="headline-44">
MEMORY UTILIZATION
</h2>
<div id="outline-text-headline-44" class="outline-text-2">
<p>There are a number of factors which affect how much memory fast-import
requires to perform an import. Like critical sections of core Git,
fast-import uses its own memory allocators to amortize any overheads
associated with malloc. In practice fast-import tends to amortize any
malloc overheads to 0, due to its use of large block allocations.</p>
<div id="outline-container-headline-45" class="outline-3">
<h3 id="headline-45">
per object
</h3>
<div id="outline-text-headline-45" class="outline-text-3">
<p>fast-import maintains an in-memory structure for every object written in
this execution. On a 32 bit system the structure is 32 bytes, on a 64
bit system the structure is 40 bytes (due to the larger pointer sizes).
Objects in the table are not deallocated until fast-import terminates.
Importing 2 million objects on a 32 bit system will require
approximately 64 MiB of memory.</p>
<p>
The object table is actually a hashtable keyed on the object name (the
unique SHA-1). This storage configuration allows fast-import to reuse an
existing or already written object and avoid writing duplicates to the
output packfile. Duplicate blobs are surprisingly common in an import,
typically due to branch merges in the source.</p>
</div>
</div>
<div id="outline-container-headline-46" class="outline-3">
<h3 id="headline-46">
per mark
</h3>
<div id="outline-text-headline-46" class="outline-text-3">
<p>Marks are stored in a sparse array, using 1 pointer (4 bytes or 8 bytes,
depending on pointer size) per mark. Although the array is sparse,
frontends are still strongly encouraged to use marks between 1 and n,
where n is the total number of marks required for this import.</p>
</div>
</div>
<div id="outline-container-headline-47" class="outline-3">
<h3 id="headline-47">
per branch
</h3>
<div id="outline-text-headline-47" class="outline-text-3">
<p>Branches are classified as active and inactive. The memory usage of the
two classes is significantly different.</p>
<p>
Inactive branches are stored in a structure which uses 96 or 120 bytes
(32 bit or 64 bit systems, respectively), plus the length of the branch
name (typically under 200 bytes), per branch. fast-import will easily
handle as many as 10,000 inactive branches in under 2 MiB of memory.</p>
<p>
Active branches have the same overhead as inactive branches, but also
contain copies of every tree that has been recently modified on that
branch. If subtree <strong>include</strong> has not been modified since the branch
became active, its contents will not be loaded into memory, but if
subtree <strong>src</strong> has been modified by a commit since the branch became
active, then its contents will be loaded in memory.</p>
<p>
As active branches store metadata about the files contained on that
branch, their in-memory storage size can grow to a considerable size
(see below).</p>
<p>
fast-import automatically moves active branches to inactive status based
on a simple least-recently-used algorithm. The LRU chain is updated on
each <strong>commit</strong> command. The maximum number of active branches can be
increased or decreased on the command line with –active-branches=.</p>
</div>
</div>
<div id="outline-container-headline-48" class="outline-3">
<h3 id="headline-48">
per active tree
</h3>
<div id="outline-text-headline-48" class="outline-text-3">
<p>Trees (aka directories) use just 12 bytes of memory on top of the memory
required for their entries (see “per active file” below). The cost of a
tree is virtually 0, as its overhead amortizes out over the individual
file entries.</p>
</div>
</div>
<div id="outline-container-headline-49" class="outline-3">
<h3 id="headline-49">
per active file entry
</h3>
<div id="outline-text-headline-49" class="outline-text-3">
<p>Files (and pointers to subtrees) within active trees require 52 or 64
bytes (32/64 bit platforms) per entry. To conserve space, file and tree
names are pooled in a common string table, allowing the filename
“Makefile” to use just 16 bytes (after including the string header
overhead) no matter how many times it occurs within the project.</p>
<p>
The active branch LRU, when coupled with the filename string pool and
lazy loading of subtrees, allows fast-import to efficiently import
projects with 2,000+ branches and 45,114+ files in a very limited memory
footprint (less than 2.7 MiB per active branch).</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-50" class="outline-2">
<h2 id="headline-50">
SIGNALS
</h2>
<div id="outline-text-headline-50" class="outline-text-2">
<p>Sending <strong>SIGUSR1</strong> to the <em>git fast-import</em> process ends the current
packfile early, simulating a <strong>checkpoint</strong> command. The impatient
operator can use this facility to peek at the objects and refs from an
import in progress, at the cost of some added running time and worse
compression.</p>
</div>
</div>
<div id="outline-container-headline-51" class="outline-2">
<h2 id="headline-51">
CONFIGURATION
</h2>
<div id="outline-text-headline-51" class="outline-text-2">
<p>Everything below this line in this section is selectively included from
the *git-config*(1) documentation. The content is the same as what&#39;s
found there:</p>
<p>
fastimport.unpackLimit</p>
<blockquote>
<p>If the number of objects imported by *git-fast-import*(1) is below this
limit, then the objects will be unpacked into loose object files.
However, if the number of imported objects equals or exceeds this limit,
then the pack will be stored as a pack. Storing the pack from a
fast-import can make the import operation complete faster, especially on
slow filesystems. If not set, the value of <strong>transfer.unpackLimit</strong> is
used instead.</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-52" class="outline-2">
<h2 id="headline-52">
SEE ALSO
</h2>
<div id="outline-text-headline-52" class="outline-text-2">
<p>*git-fast-export*(1)</p>
</div>
</div>
<div id="outline-container-headline-53" class="outline-2">
<h2 id="headline-53">
GIT
</h2>
<div id="outline-text-headline-53" class="outline-text-2">
<p>Part of the *git*(1) suite</p>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.95916b5b8c09add4922ea47e674b5da7fc4b6347a3e8c4e25e98b4b7d236080b.js" integrity="sha256-lZFrW4wJrdSSLqR&#43;Z0tdp/xLY0ej6MTiXpi0t9I2CAs=" crossorigin="anonymous"></script>
    </body>
</html>
