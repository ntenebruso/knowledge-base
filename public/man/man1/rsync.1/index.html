<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - rsync.1 | Technical Notes</title>

    <link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - rsync.1</h1>
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
NAME
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>rsync - a fast, versatile, remote (and local) file-copying tool</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
SYNOPSIS
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<pre class="example">
Local:
    rsync [OPTION...] SRC... [DEST]

Access via remote shell:
    Pull:
        rsync [OPTION...] [USER@]HOST:SRC... [DEST]
    Push:
        rsync [OPTION...] SRC... [USER@]HOST:DEST

Access via rsync daemon:
    Pull:
        rsync [OPTION...] [USER@]HOST::SRC... [DEST]
        rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]
    Push:
        rsync [OPTION...] SRC... [USER@]HOST::DEST
        rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST)
</pre>
<p>
Usages with just one SRC arg and no DEST arg will list the source files
instead of copying.</p>
<p>
The online version of this manpage (that includes cross-linking of
topics) is available at
<a href="https://download.samba.org/pub/rsync/rsync.1">https://download.samba.org/pub/rsync/rsync.1</a>.</p>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
DESCRIPTION
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p>Rsync is a fast and extraordinarily versatile file copying tool. It can
copy locally, to/from another host over any remote shell, or to/from a
remote rsync daemon. It offers a large number of options that control
every aspect of its behavior and permit very flexible specification of
the set of files to be copied. It is famous for its delta-transfer
algorithm, which reduces the amount of data sent over the network by
sending only the differences between the source files and the existing
files in the destination. Rsync is widely used for backups and mirroring
and as an improved copy command for everyday use.</p>
<p>
Rsync finds files that need to be transferred using a &#34;quick check&#34;
algorithm (by default) that looks for files that have changed in size or
in last-modified time. Any changes in the other preserved attributes (as
requested by options) are made on the destination file directly when the
quick check indicates that the file&#39;s data does not need to be updated.</p>
<p>
Some of the additional features of rsync are:</p>
<ol>
<li value="15">support for copying links, devices, owners, groups, and
permissions</li>
<li>exclude and exclude-from options similar to GNU tar</li>
<li>a CVS exclude mode for ignoring the same files that CVS would ignore</li>
<li>can use any transparent remote shell, including ssh or rsh</li>
<li>does not require super-user privileges</li>
<li>pipelining of file transfers to minimize latency costs</li>
<li>support for anonymous or authenticated rsync daemons (ideal for
mirroring)</li>
</ol>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
GENERAL
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<p>Rsync copies files either to or from a remote host, or locally on the
current host (it does not support copying files between two remote
hosts).</p>
<p>
There are two different ways for rsync to contact a remote system: using
a remote-shell program as the transport (such as ssh or rsh) or
contacting an rsync daemon directly via TCP. The remote-shell transport
is used whenever the source or destination path contains a single colon
(:) separator after a host specification. Contacting an rsync daemon
directly happens when the source or destination path contains a double
colon (::) separator after a host specification, OR when an rsync:// URL
is specified (see also the USING RSYNC-DAEMON FEATURES VIA A
REMOTE-SHELL CONNECTION section for an exception to this latter rule).</p>
<p>
As a special case, if a single source arg is specified without a
destination, the files are listed in an output format similar to &#34;<strong>ls
-l</strong>&#34;.</p>
<p>
As expected, if neither the source or destination path specify a remote
host, the copy occurs locally (see also the <strong>–list-only</strong> option).</p>
<p>
Rsync refers to the local side as the client and the remote side as the
server. Don&#39;t confuse server with an rsync daemon. A daemon is always a
server, but a server can be either a daemon or a remote-shell spawned
process.</p>
</div>
</div>
<div id="outline-container-headline-5" class="outline-2">
<h2 id="headline-5">
SETUP
</h2>
<div id="outline-text-headline-5" class="outline-text-2">
<p>See the file README.md for installation instructions.</p>
<p>
Once installed, you can use rsync to any machine that you can access via
a remote shell (as well as some that you can access using the rsync
daemon-mode protocol). For remote transfers, a modern rsync uses ssh for
its communications, but it may have been configured to use a different
remote shell by default, such as rsh or remsh.</p>
<p>
You can also specify any remote shell you like, either by using the <strong>-e</strong>
command line option, or by setting the <strong>RSYNC_RSH</strong> environment variable.</p>
<p>
Note that rsync must be installed on both the source and destination
machines.</p>
</div>
</div>
<div id="outline-container-headline-6" class="outline-2">
<h2 id="headline-6">
USAGE
</h2>
<div id="outline-text-headline-6" class="outline-text-2">
<p>You use rsync in the same way you use rcp. You must specify a source and
a destination, one of which may be remote.</p>
<p>
Perhaps the best way to explain the syntax is with some examples:</p>
<blockquote>
<pre class="example">
rsync -t *.c foo:src/
</pre>
</blockquote>
<p>
This would transfer all files matching the pattern <strong>*.c</strong> from the
current directory to the directory src on the machine foo. If any of the
files already exist on the remote system then the rsync remote-update
protocol is used to update the file by sending only the differences in
the data. Note that the expansion of wildcards on the command-line
(<strong>*.c</strong>) into a list of files is handled by the shell before it runs
rsync and not by rsync itself (exactly the same as all other Posix-style
programs).</p>
<blockquote>
<pre class="example">
rsync -avz foo:src/bar /data/tmp
</pre>
</blockquote>
<p>
This would recursively transfer all files from the directory src/bar on
the machine foo into the /data/tmp/bar directory on the local machine.
The files are transferred in archive mode, which ensures that symbolic
links, devices, attributes, permissions, ownerships, etc. are preserved
in the transfer. Additionally, compression will be used to reduce the
size of data portions of the transfer.</p>
<blockquote>
<pre class="example">
rsync -avz foo:src/bar/ /data/tmp
</pre>
</blockquote>
<p>
A trailing slash on the source changes this behavior to avoid creating
an additional directory level at the destination. You can think of a
trailing / on a source as meaning &#34;copy the contents of this directory&#34;
as opposed to &#34;copy the directory by name&#34;, but in both cases the
attributes of the containing directory are transferred to the containing
directory on the destination. In other words, each of the following
commands copies the files in the same way, including their setting of
the attributes of /dest/foo:</p>
<blockquote>
<pre class="example">
rsync -av /src/foo /dest
rsync -av /src/foo/ /dest/foo
</pre>
</blockquote>
<p>
Note also that host and module references don&#39;t require a trailing slash
to copy the contents of the default directory. For example, both of
these copy the remote directory&#39;s contents into &#34;/dest&#34;:</p>
<blockquote>
<pre class="example">
rsync -av host: /dest
rsync -av host::module /dest
</pre>
</blockquote>
<p>
You can also use rsync in local-only mode, where both the source and
destination don&#39;t have a &#39;:&#39; in the name. In this case it behaves like
an improved copy command.</p>
<p>
Finally, you can list all the (listable) modules available from a
particular rsync daemon by leaving off the module name:</p>
<blockquote>
<pre class="example">
rsync somehost.mydomain.com::
</pre>
</blockquote>
</div>
</div>
<div id="outline-container-headline-7" class="outline-2">
<h2 id="headline-7">
COPYING TO A DIFFERENT NAME
</h2>
<div id="outline-text-headline-7" class="outline-text-2">
<p>When you want to copy a directory to a different name, use a trailing
slash on the source directory to put the contents of the directory into
any destination directory you like:</p>
<blockquote>
<pre class="example">
rsync -ai foo/ bar/
</pre>
</blockquote>
<p>
Rsync also has the ability to customize a destination file&#39;s name when
copying a single item. The rules for this are:</p>
<ol>
<li value="15">The transfer list must consist of a single item (either a file
or an empty directory)</li>
<li>The final element of the destination path must not exist as a
directory</li>
<li>The destination path must not have been specified with a trailing
slash</li>
</ol>
<p>Under those circumstances, rsync will set the name of the destination&#39;s
single item to the last element of the destination path. Keep in mind
that it is best to only use this idiom when copying a file and use the
above trailing-slash idiom when copying a directory.</p>
<p>
The following example copies the <strong>foo.c</strong> file as <strong>bar.c</strong> in the <strong>save</strong>
dir (assuming that <strong>bar.c</strong> isn&#39;t a directory):</p>
<blockquote>
<pre class="example">
rsync -ai src/foo.c save/bar.c
</pre>
</blockquote>
<p>
The single-item copy rule might accidentally bite you if you unknowingly
copy a single item and specify a destination dir that doesn&#39;t exist
(without using a trailing slash). For example, if <strong>src/</strong>.c* matches one
file and <strong>save/dir</strong> doesn&#39;t exist, this will confuse you by naming the
destination file <strong>save/dir</strong>:</p>
<blockquote>
<pre class="example">
rsync -ai src/*.c save/dir
</pre>
</blockquote>
<p>
To prevent such an accident, either make sure the destination dir exists
or specify the destination path with a trailing slash:</p>
<blockquote>
<pre class="example">
rsync -ai src/*.c save/dir/
</pre>
</blockquote>
</div>
</div>
<div id="outline-container-headline-8" class="outline-2">
<h2 id="headline-8">
SORTED TRANSFER ORDER
</h2>
<div id="outline-text-headline-8" class="outline-text-2">
<p>Rsync always sorts the specified filenames into its internal transfer
list. This handles the merging together of the contents of identically
named directories, makes it easy to remove duplicate filenames. It can,
however, confuse someone when the files are transferred in a different
order than what was given on the command-line.</p>
<p>
If you need a particular file to be transferred prior to another, either
separate the files into different rsync calls, or consider using
<strong>–delay-updates</strong> (which doesn&#39;t affect the sorted transfer order, but
does make the final file-updating phase happen much more rapidly).</p>
</div>
</div>
<div id="outline-container-headline-9" class="outline-2">
<h2 id="headline-9">
MULTI-HOST SECURITY
</h2>
<div id="outline-text-headline-9" class="outline-text-2">
<p>Rsync takes steps to ensure that the file requests that are shared in a
transfer are protected against various security issues. Most of the
potential problems arise on the receiving side where rsync takes steps
to ensure that the list of files being transferred remains within the
bounds of what was requested.</p>
<p>
Toward this end, rsync 3.1.2 and later have aborted when a file list
contains an absolute or relative path that tries to escape out of the
top of the transfer. Also, beginning with version 3.2.5, rsync does two
more safety checks of the file list to (1) ensure that no extra source
arguments were added into the transfer other than those that the client
requested and (2) ensure that the file list obeys the exclude rules that
were sent to the sender.</p>
<p>
For those that don&#39;t yet have a 3.2.5 client rsync (or those that want
to be extra careful), it is safest to do a copy into a dedicated
destination directory for the remote files when you don&#39;t trust the
remote host. For example, instead of doing an rsync copy into your home
directory:</p>
<blockquote>
<pre class="example">
rsync -aiv host1:dir1 ~
</pre>
</blockquote>
<p>
Dedicate a &#34;host1-files&#34; dir to the remote content:</p>
<blockquote>
<pre class="example">
rsync -aiv host1:dir1 ~/host1-files
</pre>
</blockquote>
<p>
See the <strong>–trust-sender</strong> option for additional details.</p>
<p>
CAUTION: it is not particularly safe to use rsync to copy files from a
case-preserving filesystem to a case-ignoring filesystem. If you must
perform such a copy, you should either disable symlinks via <strong>–no-links</strong>
or enable the munging of symlinks via <strong>–munge-links</strong> (and make sure you
use the right local or remote option). This will prevent rsync from
doing potentially dangerous things if a symlink name overlaps with a
file or directory. It does not, however, ensure that you get a full copy
of all the files (since that may not be possible when the names
overlap). A potentially better solution is to list all the source files
and create a safe list of filenames that you pass to the <strong>–files-from</strong>
option. Any files that conflict in name would need to be copied to
different destination directories using more than one copy.</p>
<p>
While a copy of a case-ignoring filesystem to a case-ignoring filesystem
can work out fairly well, if no <strong>–delete-during</strong> or <strong>–delete-before</strong>
option is active, rsync can potentially update an existing file on the
receiving side without noticing that the upper-/lower-case of the
filename should be changed to match the sender.</p>
</div>
</div>
<div id="outline-container-headline-10" class="outline-2">
<h2 id="headline-10">
ADVANCED USAGE
</h2>
<div id="outline-text-headline-10" class="outline-text-2">
<p>The syntax for requesting multiple files from a remote host is done by
specifying additional remote-host args in the same style as the first,
or with the hostname omitted. For instance, all these work:</p>
<blockquote>
<pre class="example">
rsync -aiv host:file1 :file2 host:file{3,4} /dest/
rsync -aiv host::modname/file{1,2} host::modname/extra /dest/
rsync -aiv host::modname/first ::extra-file{1,2} /dest/
</pre>
</blockquote>
<p>
Note that a daemon connection only supports accessing one module per
copy command, so if the start of a follow-up path doesn&#39;t begin with the
modname of the first path, it is assumed to be a path in the module
(such as the extra-file1 &amp; extra-file2 that are grabbed above).</p>
<p>
Really old versions of rsync (2.6.9 and before) only allowed specifying
one remote-source arg, so some people have instead relied on the
remote-shell performing space splitting to break up an arg into multiple
paths. Such unintuitive behavior is no longer supported by default
(though you can request it, as described below).</p>
<p>
Starting in 3.2.4, filenames are passed to a remote shell in such a way
as to preserve the characters you give it. Thus, if you ask for a file
with spaces in the name, that&#39;s what the remote rsync looks for:</p>
<blockquote>
<pre class="example">
rsync -aiv host:&#39;a simple file.pdf&#39; /dest/
</pre>
</blockquote>
<p>
If you use scripts that have been written to manually apply extra
quoting to the remote rsync args (or to require remote arg splitting),
you can ask rsync to let your script handle the extra escaping. This is
done by either adding the <strong>–old-args</strong> option to the rsync runs in the
script (which requires a new rsync) or exporting RSYNC_OLD_ARGS=1 and
RSYNC_PROTECT_ARGS=0 (which works with old or new rsync versions).</p>
</div>
</div>
<div id="outline-container-headline-11" class="outline-2">
<h2 id="headline-11">
CONNECTING TO AN RSYNC DAEMON
</h2>
<div id="outline-text-headline-11" class="outline-text-2">
<p>It is also possible to use rsync without a remote shell as the
transport. In this case you will directly connect to a remote rsync
daemon, typically using TCP port 873. (This obviously requires the
daemon to be running on the remote system, so refer to the STARTING AN
RSYNC DAEMON TO ACCEPT CONNECTIONS section below for information on
that.)</p>
<p>
Using rsync in this way is the same as using it with a remote shell
except that:</p>
<ol>
<li value="15">Use either double-colon syntax or rsync:// URL syntax instead
of the single-colon (remote shell) syntax.</li>
<li>The first element of the &#34;path&#34; is actually a module name.</li>
<li>Additional remote source args can use an abbreviated syntax that
omits the hostname and/or the module name, as discussed in ADVANCED
USAGE.</li>
<li>The remote daemon may print a &#34;message of the day&#34; when you connect.</li>
<li>If you specify only the host (with no module or path) then a list of
accessible modules on the daemon is output.</li>
<li>If you specify a remote source path but no destination, a listing of
the matching files on the remote daemon is output.</li>
<li>The <strong>–rsh</strong> (<strong>-e</strong>) option must be omitted to avoid changing the
connection style from using a socket connection to USING
RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION.</li>
</ol>
<p>An example that copies all the files in a remote module named &#34;src&#34;:</p>
<blockquote>
<pre class="example">
rsync -av host::src /dest
</pre>
</blockquote>
<p>
Some modules on the remote daemon may require authentication. If so, you
will receive a password prompt when you connect. You can avoid the
password prompt by setting the environment variable <strong>RSYNC_PASSWORD</strong> to
the password you want to use or using the <strong>–password-file</strong> option. This
may be useful when scripting rsync.</p>
<p>
WARNING: On some systems environment variables are visible to all users.
On those systems using <strong>–password-file</strong> is recommended.</p>
<p>
You may establish the connection via a web proxy by setting the
environment variable <strong>RSYNC_PROXY</strong> to a hostname:port pair pointing to
your web proxy. Note that your web proxy&#39;s configuration must support
proxy connections to port 873.</p>
<p>
You may also establish a daemon connection using a program as a proxy by
setting the environment variable <strong>RSYNC_CONNECT_PROG</strong> to the commands
you wish to run in place of making a direct socket connection. The
string may contain the escape &#34;%H&#34; to represent the hostname specified
in the rsync command (so use &#34;%%&#34; if you need a single &#34;%&#34; in your
string). For example:</p>
<blockquote>
<pre class="example">
export RSYNC_CONNECT_PROG=&#39;ssh proxyhost nc %H 873&#39;
rsync -av targethost1::module/src/ /dest/
rsync -av rsync://targethost2/module/src/ /dest/
</pre>
</blockquote>
<p>
The command specified above uses ssh to run nc (netcat) on a proxyhost,
which forwards all data to port 873 (the rsync daemon) on the targethost
(%H).</p>
<p>
Note also that if the <strong>RSYNC_SHELL</strong> environment variable is set, that
program will be used to run the <strong>RSYNC_CONNECT_PROG</strong> command instead of
using the default shell of the <strong>system()</strong> call.</p>
</div>
</div>
<div id="outline-container-headline-12" class="outline-2">
<h2 id="headline-12">
USING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION
</h2>
<div id="outline-text-headline-12" class="outline-text-2">
<p>It is sometimes useful to use various features of an rsync daemon (such
as named modules) without actually allowing any new socket connections
into a system (other than what is already required to allow remote-shell
access). Rsync supports connecting to a host using a remote shell and
then spawning a single-use &#34;daemon&#34; server that expects to read its
config file in the home dir of the remote user. This can be useful if
you want to encrypt a daemon-style transfer&#39;s data, but since the daemon
is started up fresh by the remote user, you may not be able to use
features such as chroot or change the uid used by the daemon. (For
another way to encrypt a daemon transfer, consider using ssh to tunnel a
local port to a remote machine and configure a normal rsync daemon on
that remote host to only allow connections from &#34;localhost&#34;.)</p>
<p>
From the user&#39;s perspective, a daemon transfer via a remote-shell
connection uses nearly the same command-line syntax as a normal
rsync-daemon transfer, with the only exception being that you must
explicitly set the remote shell program on the command-line with the
<strong>–rsh=COMMAND</strong> option. (Setting the RSYNC_RSH in the environment will
not turn on this functionality.) For example:</p>
<blockquote>
<pre class="example">
rsync -av --rsh=ssh host::module /dest
</pre>
</blockquote>
<p>
If you need to specify a different remote-shell user, keep in mind that
the user@ prefix in front of the host is specifying the rsync-user value
(for a module that requires user-based authentication). This means that
you must give the &#39;-l user&#39; option to ssh when specifying the
remote-shell, as in this example that uses the short version of the
<strong>–rsh</strong> option:</p>
<blockquote>
<pre class="example">
rsync -av -e &#34;ssh -l ssh-user&#34; rsync-user@host::module /dest
</pre>
</blockquote>
<p>
The &#34;ssh-user&#34; will be used at the ssh level; the &#34;rsync-user&#34; will be
used to log-in to the &#34;module&#34;.</p>
<p>
In this setup, the daemon is started by the ssh command that is
accessing the system (which can be forced via the
<strong>~/.ssh/authorized_keys</strong> file, if desired). However, when accessing a
daemon directly, it needs to be started beforehand.</p>
</div>
</div>
<div id="outline-container-headline-13" class="outline-2">
<h2 id="headline-13">
STARTING AN RSYNC DAEMON TO ACCEPT CONNECTIONS
</h2>
<div id="outline-text-headline-13" class="outline-text-2">
<p>In order to connect to an rsync daemon, the remote system needs to have
a daemon already running (or it needs to have configured something like
inetd to spawn an rsync daemon for incoming connections on a particular
port). For full information on how to start a daemon that will handling
incoming socket connections, see the *rsyncd.conf*(5) manpage – that is
the config file for the daemon, and it contains the full details for how
to run the daemon (including stand-alone and inetd configurations).</p>
<p>
If you&#39;re using one of the remote-shell transports for the transfer,
there is no need to manually start an rsync daemon.</p>
</div>
</div>
<div id="outline-container-headline-14" class="outline-2">
<h2 id="headline-14">
EXAMPLES
</h2>
<div id="outline-text-headline-14" class="outline-text-2">
<p>Here are some examples of how rsync can be used.</p>
<p>
To backup a home directory, which consists of large MS Word files and
mail folders, a per-user cron job can be used that runs this each day:</p>
<blockquote>
<pre class="example">
rsync -aiz . bkhost:backup/joe/
</pre>
</blockquote>
<p>
To move some files from a remote host to the local host, you could run:</p>
<blockquote>
<pre class="example">
rsync -aiv --remove-source-files rhost:/tmp/{file1,file2}.c ~/src/
</pre>
</blockquote>
</div>
</div>
<div id="outline-container-headline-15" class="outline-2">
<h2 id="headline-15">
OPTION SUMMARY
</h2>
<div id="outline-text-headline-15" class="outline-text-2">
<p>Here is a short summary of the options available in rsync. Each option
also has its own detailed description later in this manpage.</p>
<pre class="example">
--verbose, -v            increase verbosity
--info=FLAGS             fine-grained informational verbosity
--debug=FLAGS            fine-grained debug verbosity
--stderr=e|a|c           change stderr output mode (default: errors)
--quiet, -q              suppress non-error messages
--no-motd                suppress daemon-mode MOTD
--checksum, -c           skip based on checksum, not mod-time &amp; size
--archive, -a            archive mode is -rlptgoD (no -A,-X,-U,-N,-H)
--no-OPTION              turn off an implied OPTION (e.g. --no-D)
--recursive, -r          recurse into directories
--relative, -R           use relative path names
--no-implied-dirs        don&#39;t send implied dirs with --relative
--backup, -b             make backups (see --suffix &amp; --backup-dir)
--backup-dir=DIR         make backups into hierarchy based in DIR
--suffix=SUFFIX          backup suffix (default ~ w/o --backup-dir)
--update, -u             skip files that are newer on the receiver
--inplace                update destination files in-place
--append                 append data onto shorter files
--append-verify          --append w/old data in file checksum
--dirs, -d               transfer directories without recursing
--old-dirs, --old-d      works like --dirs when talking to old rsync
--mkpath                 create destination&#39;s missing path components
--links, -l              copy symlinks as symlinks
--copy-links, -L         transform symlink into referent file/dir
--copy-unsafe-links      only &#34;unsafe&#34; symlinks are transformed
--safe-links             ignore symlinks that point outside the tree
--munge-links            munge symlinks to make them safe &amp; unusable
--copy-dirlinks, -k      transform symlink to dir into referent dir
--keep-dirlinks, -K      treat symlinked dir on receiver as dir
--hard-links, -H         preserve hard links
--perms, -p              preserve permissions
--executability, -E      preserve executability
--chmod=CHMOD            affect file and/or directory permissions
--acls, -A               preserve ACLs (implies --perms)
--xattrs, -X             preserve extended attributes
--owner, -o              preserve owner (super-user only)
--group, -g              preserve group
--devices                preserve device files (super-user only)
--copy-devices           copy device contents as a regular file
--write-devices          write to devices as files (implies --inplace)
--specials               preserve special files
-D                       same as --devices --specials
--times, -t              preserve modification times
--atimes, -U             preserve access (use) times
--open-noatime           avoid changing the atime on opened files
--crtimes, -N            preserve create times (newness)
--omit-dir-times, -O     omit directories from --times
--omit-link-times, -J    omit symlinks from --times
--super                  receiver attempts super-user activities
--fake-super             store/recover privileged attrs using xattrs
--sparse, -S             turn sequences of nulls into sparse blocks
--preallocate            allocate dest files before writing them
--dry-run, -n            perform a trial run with no changes made
--whole-file, -W         copy files whole (w/o delta-xfer algorithm)
--checksum-choice=STR    choose the checksum algorithm (aka --cc)
--one-file-system, -x    don&#39;t cross filesystem boundaries
--block-size=SIZE, -B    force a fixed checksum block-size
--rsh=COMMAND, -e        specify the remote shell to use
--rsync-path=PROGRAM     specify the rsync to run on remote machine
--existing               skip creating new files on receiver
--ignore-existing        skip updating files that exist on receiver
--remove-source-files    sender removes synchronized files (non-dir)
--del                    an alias for --delete-during
--delete                 delete extraneous files from dest dirs
--delete-before          receiver deletes before xfer, not during
--delete-during          receiver deletes during the transfer
--delete-delay           find deletions during, delete after
--delete-after           receiver deletes after transfer, not during
--delete-excluded        also delete excluded files from dest dirs
--ignore-missing-args    ignore missing source args without error
--delete-missing-args    delete missing source args from destination
--ignore-errors          delete even if there are I/O errors
--force                  force deletion of dirs even if not empty
--max-delete=NUM         don&#39;t delete more than NUM files
--max-size=SIZE          don&#39;t transfer any file larger than SIZE
--min-size=SIZE          don&#39;t transfer any file smaller than SIZE
--max-alloc=SIZE         change a limit relating to memory alloc
--partial                keep partially transferred files
--partial-dir=DIR        put a partially transferred file into DIR
--delay-updates          put all updated files into place at end
--prune-empty-dirs, -m   prune empty directory chains from file-list
--numeric-ids            don&#39;t map uid/gid values by user/group name
--usermap=STRING         custom username mapping
--groupmap=STRING        custom groupname mapping
--chown=USER:GROUP       simple username/groupname mapping
--timeout=SECONDS        set I/O timeout in seconds
--contimeout=SECONDS     set daemon connection timeout in seconds
--ignore-times, -I       don&#39;t skip files that match size and time
--size-only              skip files that match in size
--modify-window=NUM, -@  set the accuracy for mod-time comparisons
--temp-dir=DIR, -T       create temporary files in directory DIR
--fuzzy, -y              find similar file for basis if no dest file
--compare-dest=DIR       also compare destination files relative to DIR
--copy-dest=DIR          ... and include copies of unchanged files
--link-dest=DIR          hardlink to files in DIR when unchanged
--compress, -z           compress file data during the transfer
--compress-choice=STR    choose the compression algorithm (aka --zc)
--compress-level=NUM     explicitly set compression level (aka --zl)
--skip-compress=LIST     skip compressing files with suffix in LIST
--cvs-exclude, -C        auto-ignore files in the same way CVS does
--filter=RULE, -f        add a file-filtering RULE
-F                       same as --filter=&#39;dir-merge /.rsync-filter&#39;
                         repeated: --filter=&#39;- .rsync-filter&#39;
--exclude=PATTERN        exclude files matching PATTERN
--exclude-from=FILE      read exclude patterns from FILE
--include=PATTERN        don&#39;t exclude files matching PATTERN
--include-from=FILE      read include patterns from FILE
--files-from=FILE        read list of source-file names from FILE
--from0, -0              all *-from/filter files are delimited by 0s
--old-args               disable the modern arg-protection idiom
--secluded-args, -s      use the protocol to safely send the args
--trust-sender           trust the remote sender&#39;s file list
--copy-as=USER[:GROUP]   specify user &amp; optional group for the copy
--address=ADDRESS        bind address for outgoing socket to daemon
--port=PORT              specify double-colon alternate port number
--sockopts=OPTIONS       specify custom TCP options
--blocking-io            use blocking I/O for the remote shell
--outbuf=N|L|B           set out buffering to None, Line, or Block
--stats                  give some file-transfer stats
--8-bit-output, -8       leave high-bit chars unescaped in output
--human-readable, -h     output numbers in a human-readable format
--progress               show progress during transfer
-P                       same as --partial --progress
--itemize-changes, -i    output a change-summary for all updates
--remote-option=OPT, -M  send OPTION to the remote side only
--out-format=FORMAT      output updates using the specified FORMAT
--log-file=FILE          log what we&#39;re doing to the specified FILE
--log-file-format=FMT    log updates using the specified FMT
--password-file=FILE     read daemon-access password from FILE
--early-input=FILE       use FILE for daemon&#39;s early exec input
--list-only              list the files instead of copying them
--bwlimit=RATE           limit socket I/O bandwidth
--stop-after=MINS        Stop rsync after MINS minutes have elapsed
--stop-at=y-m-dTh:m      Stop rsync at the specified point in time
--fsync                  fsync every written file
--write-batch=FILE       write a batched update to FILE
--only-write-batch=FILE  like --write-batch but w/o updating dest
--read-batch=FILE        read a batched update from FILE
--protocol=NUM           force an older protocol version to be used
--iconv=CONVERT_SPEC     request charset conversion of filenames
--checksum-seed=NUM      set block/file checksum seed (advanced)
--ipv4, -4               prefer IPv4
--ipv6, -6               prefer IPv6
--version, -V            print the version + other info and exit
--help, -h (*)           show this help (* -h is help only on its own)
</pre>
<p>
Rsync can also be run as a daemon, in which case the following options
are accepted:</p>
<pre class="example">
--daemon                 run as an rsync daemon
--address=ADDRESS        bind to the specified address
--bwlimit=RATE           limit socket I/O bandwidth
--config=FILE            specify alternate rsyncd.conf file
--dparam=OVERRIDE, -M    override global daemon config parameter
--no-detach              do not detach from the parent
--port=PORT              listen on alternate port number
--log-file=FILE          override the &#34;log file&#34; setting
--log-file-format=FMT    override the &#34;log format&#34; setting
--sockopts=OPTIONS       specify custom TCP options
--verbose, -v            increase verbosity
--ipv4, -4               prefer IPv4
--ipv6, -6               prefer IPv6
--help, -h               show this help (when used with --daemon)
</pre>
</div>
</div>
<div id="outline-container-headline-16" class="outline-2">
<h2 id="headline-16">
OPTIONS
</h2>
<div id="outline-text-headline-16" class="outline-text-2">
<p>Rsync accepts both long (double-dash + word) and short (single-dash +
letter) options. The full list of the available options are described
below. If an option can be specified in more than one way, the choices
are comma-separated. Some options only have a long variant, not a short.</p>
<p>
If the option takes a parameter, the parameter is only listed after the
long variant, even though it must also be specified for the short. When
specifying a parameter, you can either use the form <strong>–option=param</strong>,
<strong>–option param</strong>, <strong>-o=param</strong>, <strong>-o param</strong>, or <strong>-oparam</strong> (the latter
choices assume that your option has a short variant).</p>
<p>
The parameter may need to be quoted in some manner for it to survive the
shell&#39;s command-line parsing. Also keep in mind that a leading tilde
(<strong>~</strong>) in a pathname is substituted by your shell, so make sure that you
separate the option name from the pathname using a space if you want the
local shell to expand it.</p>
<dl>
<dt>
–help
</dt>
<dd>Print a short help page describing the options available in
rsync and exit. You can also use <strong>-h</strong> for <strong>–help</strong> when it is used
without any other options (since it normally means
<strong>–human-readable</strong>).</dd>
<dt>
–version, -V
</dt>
<dd>Print the rsync version plus other info and exit.
When repeated, the information is output is a JSON format that is
still fairly readable (client side only).

The output includes a list of compiled-in capabilities, a list of
optimizations, the default list of checksum algorithms, the default
list of compression algorithms, the default list of daemon auth
digests, a link to the rsync web site, and a few other items.</dd>
<dt>
–verbose, -v
</dt>
<dd>This option increases the amount of information you
are given during the transfer. By default, rsync works silently. A
single <strong>-v</strong> will give you information about what files are being
transferred and a brief summary at the end. Two <strong>-v</strong> options will give
you information on what files are being skipped and slightly more
information at the end. More than two <strong>-v</strong> options should only be used
if you are debugging rsync.

The end-of-run summary tells you the number of bytes sent to the
remote rsync (which is the receiving side on a local copy), the number
of bytes received from the remote host, and the average bytes per
second of the transferred data computed over the entire length of the
rsync run. The second line shows the total size (in bytes), which is
the sum of all the file sizes that rsync considered transferring. It
also shows a &#34;speedup&#34; value, which is a ratio of the total file size
divided by the sum of the sent and received bytes (which is really
just a feel-good bigger-is-better number). Note that these byte values
can be made more (or less) human-readable by using the
<strong>–human-readable</strong> (or <strong>–no-human-readable</strong>) options.

In a modern rsync, the <strong>-v</strong> option is equivalent to the setting of
groups of <strong>–info</strong> and <strong>–debug</strong> options. You can choose to use these
newer options in addition to, or in place of using <strong>–verbose</strong>, as any
fine-grained settings override the implied settings of <strong>-v</strong>. Both
<strong>–info</strong> and <strong>–debug</strong> have a way to ask for help that tells you
exactly what flags are set for each increase in verbosity.

However, do keep in mind that a daemon&#39;s &#34;<strong>max verbosity</strong>&#34; setting
will limit how high of a level the various individual flags can be set
on the daemon side. For instance, if the max is 2, then any info
and/or debug flag that is set to a higher value than what would be set
by <strong>-vv</strong> will be downgraded to the <strong>-vv</strong> level in the daemon&#39;s
logging.</dd>
<dt>
–info=FLAGS
</dt>
<dd>
<p>This option lets you have fine-grained control over
the information output you want to see. An individual flag name may be
followed by a level number, with 0 meaning to silence that output, 1
being the default output level, and higher numbers increasing the
output of that flag (for those that support higher levels). Use
<strong>–info=help</strong> to see all the available flag names, what they output,
and what flag names are added for each increase in the verbose level.
Some examples:</p>
<pre class="example">
rsync -a --info=progress2 src/ dest/
rsync -avv --info=stats2,misc1,flist0 src/ dest/
</pre>
<p>
Note that <strong>–info=name</strong>&#39;s output is affected by the <strong>–out-format</strong> and
<strong>–itemize-changes</strong> (<strong>-i</strong>) options. See those options for more
information on what is output and when.</p>
<p>
This option was added to 3.1.0, so an older rsync on the server side
might reject your attempts at fine-grained control (if one or more
flags needed to be send to the server and the server was too old to
understand them). See also the &#34;<strong>max verbosity</strong>&#34; caveat above when
dealing with a daemon.</p>
</dd>
<dt>
–debug=FLAGS
</dt>
<dd>
<p>This option lets you have fine-grained control over
the debug output you want to see. An individual flag name may be
followed by a level number, with 0 meaning to silence that output, 1
being the default output level, and higher numbers increasing the
output of that flag (for those that support higher levels). Use
<strong>–debug=help</strong> to see all the available flag names, what they output,
and what flag names are added for each increase in the verbose level.
Some examples:</p>
<pre class="example">
rsync -avvv --debug=none src/ dest/
rsync -avA --del --debug=del2,acl src/ dest/
</pre>
<p>
Note that some debug messages will only be output when the
<strong>–stderr=all</strong> option is specified, especially those pertaining to I/O
and buffer debugging.</p>
<p>
Beginning in 3.2.0, this option is no longer auto-forwarded to the
server side in order to allow you to specify different debug values
for each side of the transfer, as well as to specify a new debug
option that is only present in one of the rsync versions. If you want
to duplicate the same option on both sides, using brace expansion is
an easy way to save you some typing. This works in zsh and bash:</p>
<pre class="example">
rsync -aiv {-M,}--debug=del2 src/ dest/
</pre>
</dd>
<dt>
–stderr=errors|all|client
</dt>
<dd>This option controls which processes
output to stderr and if info messages are also changed to stderr. The
mode strings can be abbreviated, so feel free to use a single letter
value. The 3 possible choices are:</dd>
</dl>
<blockquote>
<ol>
<li value="15"><strong>errors</strong> - (the default) causes all the rsync processes to
send an error directly to stderr, even if the process is on the
remote side of the transfer. Info messages are sent to the client
side via the protocol stream. If stderr is not available (i.e. when
directly connecting with a daemon via a socket) errors fall back to
being sent via the protocol stream.</li>
<li><strong>all</strong> - causes all rsync messages (info and error) to get written
directly to stderr from all (possible) processes. This causes stderr
to become line-buffered (instead of raw) and eliminates the ability
to divide up the info and error messages by file handle. For those
doing debugging or using several levels of verbosity, this option
can help to avoid clogging up the transfer stream (which should
prevent any chance of a deadlock bug hanging things up). It also
allows <strong>–debug</strong> to enable some extra I/O related messages.</li>
<li><strong>client</strong> - causes all rsync messages to be sent to the client side
via the protocol stream. One client process outputs all messages,
with errors on stderr and info messages on stdout. This <strong>was</strong> the
default in older rsync versions, but can cause error delays when a
lot of transfer data is ahead of the messages. If you&#39;re pushing
files to an older rsync, you may want to use <strong>–stderr=all</strong> since
that idiom has been around for several releases.</li>
</ol>
</blockquote>
<blockquote>
<p>This option was added in rsync 3.2.3. This version also began the
forwarding of a non-default setting to the remote side, though rsync
uses the backward-compatible options <strong>–msgs2stderr</strong> and
<strong>–no-msgs2stderr</strong> to represent the <strong>all</strong> and <strong>client</strong> settings,
respectively. A newer rsync will continue to accept these older option
names to maintain compatibility.</p>
</blockquote>
<dl>
<dt>
–quiet, -q
</dt>
<dd>This option decreases the amount of information you are
given during the transfer, notably suppressing information messages
from the remote server. This option is useful when invoking rsync from
cron.</dd>
<dt>
–no-motd
</dt>
<dd>This option affects the information that is output by the
client at the start of a daemon transfer. This suppresses the
message-of-the-day (MOTD) text, but it also affects the list of
modules that the daemon sends in response to the &#34;rsync host::&#34;
request (due to a limitation in the rsync protocol), so omit this
option if you want to request the list of modules from the daemon.</dd>
<dt>
–ignore-times, -I
</dt>
<dd>Normally rsync will skip any files that are
already the same size and have the same modification timestamp. This
option turns off this &#34;quick check&#34; behavior, causing all files to be
updated.

This option can be confusing compared to <strong>–ignore-existing</strong> and
<strong>–ignore-non-existing</strong> in that that they cause rsync to transfer
fewer files, while this option causes rsync to transfer more files.</dd>
<dt>
–size-only
</dt>
<dd>This modifies rsync&#39;s &#34;quick check&#34; algorithm for
finding files that need to be transferred, changing it from the
default of transferring files with either a changed size or a changed
last-modified time to just looking for files that have changed in
size. This is useful when starting to use rsync after using another
mirroring system which may not preserve timestamps exactly.</dd>
<dt>
–modify-window=NUM, -@
</dt>
<dd>
<p>When comparing two timestamps, rsync treats
the timestamps as being equal if they differ by no more than the
modify-window value. The default is 0, which matches just integer
seconds. If you specify a negative value (and the receiver is at least
version 3.1.3) then nanoseconds will also be taken into account.
Specifying 1 is useful for copies to/from MS Windows FAT filesystems,
because FAT represents times with a 2-second resolution (allowing
times to differ from the original by up to 1 second).</p>
<p>
If you want all your transfers to default to comparing nanoseconds,
you can create a <strong>~/.popt</strong> file and put these lines in it:</p>
<pre class="example">
rsync alias -a -a@-1
rsync alias -t -t@-1
</pre>
<p>
With that as the default, you&#39;d need to specify <strong>–modify-window=0</strong>
(aka <strong>-@0</strong>) to override it and ignore nanoseconds, e.g. if you&#39;re
copying between ext3 and ext4, or if the receiving rsync is older than
3.1.3.</p>
</dd>
<dt>
–checksum, -c
</dt>
<dd>This changes the way rsync checks if the files have
been changed and are in need of a transfer. Without this option, rsync
uses a &#34;quick check&#34; that (by default) checks if each file&#39;s size and
time of last modification match between the sender and receiver. This
option changes this to compare a 128-bit checksum for each file that
has a matching size. Generating the checksums means that both sides
will expend a lot of disk I/O reading all the data in the files in the
transfer, so this can slow things down significantly (and this is
prior to any reading that will be done to transfer changed files)

The sending side generates its checksums while it is doing the
file-system scan that builds the list of the available files. The
receiver generates its checksums when it is scanning for changed
files, and will checksum any file that has the same size as the
corresponding sender&#39;s file: files with either a changed size or a
changed checksum are selected for transfer.

Note that rsync always verifies that each <em>transferred</em> file was
correctly reconstructed on the receiving side by checking a whole-file
checksum that is generated as the file is transferred, but that
automatic after-the-transfer verification has nothing to do with this
option&#39;s before-the-transfer &#34;Does this file need to be updated?&#34;
check.

The checksum used is auto-negotiated between the client and the
server, but can be overridden using either the <strong>–checksum-choice</strong>
(<strong>–cc</strong>) option or an environment variable that is discussed in that
option&#39;s section.</dd>
<dt>
–archive, -a
</dt>
<dd>This is equivalent to <strong>-rlptgoD</strong>. It is a quick way
of saying you want recursion and want to preserve almost everything.
Be aware that it does <strong>not</strong> include preserving ACLs (<strong>-A</strong>), xattrs
(<strong>-X</strong>), atimes (<strong>-U</strong>), crtimes (<strong>-N</strong>), nor the finding and preserving
of hardlinks (<strong>-H</strong>).

The only exception to the above equivalence is when <strong>–files-from</strong> is
specified, in which case <strong>-r</strong> is not implied.</dd>
<dt>
–no-OPTION
</dt>
<dd>You may turn off one or more implied options by
prefixing the option name with &#34;no-&#34;. Not all positive options have a
negated opposite, but a lot do, including those that can be used to
disable an implied option (e.g. <strong>–no-D</strong>, <strong>–no-perms</strong>) or have
different defaults in various circumstances (e.g. <strong>–no-whole-file</strong>,
<strong>–no-blocking-io</strong>, <strong>–no-dirs</strong>). Every valid negated option accepts
both the short and the long option name after the &#34;no-&#34; prefix (e.g.
<strong>–no-R</strong> is the same as <strong>–no-relative</strong>).

As an example, if you want to use <strong>–archive</strong> (<strong>-a</strong>) but don&#39;t want
<strong>–owner</strong> (<strong>-o</strong>), instead of converting <strong>-a</strong> into <strong>-rlptgD</strong>, you can
specify <strong>-a –no-o</strong> (aka <strong>–archive –no-owner</strong>).

The order of the options is important: if you specify <strong>–no-r -a</strong>, the
<strong>-r</strong> option would end up being turned on, the opposite of <strong>-a –no-r</strong>.
Note also that the side-effects of the <strong>–files-from</strong> option are NOT
positional, as it affects the default state of several options and
slightly changes the meaning of <strong>-a</strong> (see the <strong>–files-from</strong> option
for more details).</dd>
<dt>
–recursive, -r
</dt>
<dd>This tells rsync to copy directories recursively.
See also <strong>–dirs</strong> (<strong>-d</strong>) for an option that allows the scanning of a
single directory.

See the <strong>–inc-recursive</strong> option for a discussion of the incremental
recursion for creating the list of files to transfer.</dd>
<dt>
–inc-recursive, –i-r
</dt>
<dd>This option explicitly enables on
incremental recursion when scanning for files, which is enabled by
default when using the <strong>–recursive</strong> option and both sides of the
transfer are running rsync 3.0.0 or newer.

Incremental recursion uses much less memory than non-incremental,
while also beginning the transfer more quickly (since it doesn&#39;t need
to scan the entire transfer hierarchy before it starts transferring
files). If no recursion is enabled in the source files, this option
has no effect.

Some options require rsync to know the full file list, so these
options disable the incremental recursion mode. These include:</dd>
</dl>
<blockquote>
<ol>
<li value="15"><strong>–delete-before</strong> (the old default of <strong>–delete</strong>)</li>
<li><strong>–delete-after</strong></li>
<li><strong>–prune-empty-dirs</strong></li>
<li><strong>–delay-updates</strong></li>
</ol>
</blockquote>
<blockquote>
<p>In order to make <strong>–delete</strong> compatible with incremental recursion, rsync
3.0.0 made <strong>–delete-during</strong> the default delete mode (which was first
added in 2.6.4).</p>
</blockquote>
<blockquote>
<p>One side-effect of incremental recursion is that any missing
sub-directories inside a recursively-scanned directory are (by default)
created prior to recursing into the sub-dirs. This earlier creation
point (compared to a non-incremental recursion) allows rsync to then set
the modify time of the finished directory right away (without having to
delay that until a bunch of recursive copying has finished). However,
these early directories don&#39;t yet have their completed mode, mtime, or
ownership set – they have more restrictive rights until the
subdirectory&#39;s copying actually begins. This early-creation idiom can be
avoided by using the <strong>–omit-dir-times</strong> option.</p>
</blockquote>
<blockquote>
<p>Incremental recursion can be disabled using the <strong>–no-inc-recursive</strong>
(<strong>–no-i-r</strong>) option.</p>
</blockquote>
<dl>
<dt>
–no-inc-recursive, –no-i-r
</dt>
<dd>Disables the new incremental recursion
algorithm of the <strong>–recursive</strong> option. This makes rsync scan the full
file list before it begins to transfer files. See <strong>–inc-recursive</strong>
for more info.</dd>
<dt>
–relative, -R
</dt>
<dd>
<p>Use relative paths. This means that the full path
names specified on the command line are sent to the server rather than
just the last parts of the filenames. This is particularly useful when
you want to send several different directories at the same time. For
example, if you used this command:</p>
<pre class="example">
rsync -av /foo/bar/baz.c remote:/tmp/
</pre>
<p>
would create a file named baz.c in <em>tmp</em> on the remote machine. If
instead you used</p>
<pre class="example">
rsync -avR /foo/bar/baz.c remote:/tmp/
</pre>
<p>
then a file named /tmp/foo/bar/baz.c would be created on the remote
machine, preserving its full path. These extra path elements are
called &#34;implied directories&#34; (i.e. the &#34;foo&#34; and the &#34;foo/bar&#34;
directories in the above example).</p>
<p>
Beginning with rsync 3.0.0, rsync always sends these implied
directories as real directories in the file list, even if a path
element is really a symlink on the sending side. This prevents some
really unexpected behaviors when copying the full path of a file that
you didn&#39;t realize had a symlink in its path. If you want to duplicate
a server-side symlink, include both the symlink via its path, and
referent directory via its real path. If you&#39;re dealing with an older
rsync on the sending side, you may need to use the <strong>–no-implied-dirs</strong>
option.</p>
<p>
It is also possible to limit the amount of path information that is
sent as implied directories for each path you specify. With a modern
rsync on the sending side (beginning with 2.6.7), you can insert a dot
and a slash into the source path, like this:</p>
<pre class="example">
rsync -avR /foo/./bar/baz.c remote:/tmp/
</pre>
<p>
That would create <em>tmp/bar/baz.c on the remote machine. (Note that the
dot must be followed by a slash, so &#34;/foo</em>.&#34; would not be
abbreviated.) For older rsync versions, you would need to use a chdir
to limit the source path. For example, when pushing files:</p>
<pre class="example">
(cd /foo; rsync -avR bar/baz.c remote:/tmp/)
</pre>
<p>
(Note that the parens put the two commands into a sub-shell, so that
the &#34;cd&#34; command doesn&#39;t remain in effect for future commands.) If
you&#39;re pulling files from an older rsync, use this idiom (but only for
a non-daemon transfer):</p>
<pre class="example">
rsync -avR --rsync-path=&#34;cd /foo; rsync&#34; \
     remote:bar/baz.c /tmp/
</pre>
</dd>
<dt>
–no-implied-dirs
</dt>
<dd>This option affects the default behavior of the
<strong>–relative</strong> option. When it is specified, the attributes of the
implied directories from the source names are not included in the
transfer. This means that the corresponding path elements on the
destination system are left unchanged if they exist, and any missing
implied directories are created with default attributes. This even
allows these implied path elements to have big differences, such as
being a symlink to a directory on the receiving side.

For instance, if a command-line arg or a files-from entry told rsync
to transfer the file &#34;path/foo/file&#34;, the directories &#34;path&#34; and
&#34;path/foo&#34; are implied when <strong>–relative</strong> is used. If &#34;path/foo&#34; is a
symlink to &#34;bar&#34; on the destination system, the receiving rsync would
ordinarily delete &#34;path/foo&#34;, recreate it as a directory, and receive
the file into the new directory. With <strong>–no-implied-dirs</strong>, the
receiving rsync updates &#34;path/foo/file&#34; using the existing path
elements, which means that the file ends up being created in
&#34;path/bar&#34;. Another way to accomplish this link preservation is to use
the <strong>–keep-dirlinks</strong> option (which will also affect symlinks to
directories in the rest of the transfer).

When pulling files from an rsync older than 3.0.0, you may need to use
this option if the sending side has a symlink in the path you request
and you wish the implied directories to be transferred as normal
directories.</dd>
<dt>
–backup, -b
</dt>
<dd>
<p>With this option, preexisting destination files are
renamed as each file is transferred or deleted. You can control where
the backup file goes and what (if any) suffix gets appended using the
<strong>–backup-dir</strong> and <strong>–suffix</strong> options.</p>
<p>
If you don&#39;t specify <strong>–backup-dir</strong>:</p>
<ol>
<li>the <strong>–omit-dir-times</strong> option will be forced on</li>
<li>the use of <strong>–delete</strong> (without <strong>–delete-excluded</strong>), causes rsync
to add a &#34;protect&#34; filter-rule for the backup suffix to the end of
all your existing filters that looks like this: <strong>-f &#34;P *~&#34;</strong>. This
rule prevents previously backed-up files from being deleted.</li>
</ol>
<p>Note that if you are supplying your own filter rules, you may need to
manually insert your own exclude/protect rule somewhere higher up in
the list so that it has a high enough priority to be effective (e.g.
if your rules specify a trailing inclusion/exclusion of <strong>*</strong>, the
auto-added rule would never be reached).</p>
</dd>
<dt>
–backup-dir=DIR
</dt>
<dd>This implies the <strong>–backup</strong> option, and tells
rsync to store all backups in the specified directory on the receiving
side. This can be used for incremental backups. You can additionally
specify a backup suffix using the <strong>–suffix</strong> option (otherwise the
files backed up in the specified directory will keep their original
filenames).

Note that if you specify a relative path, the backup directory will be
relative to the destination directory, so you probably want to specify
either an absolute path or a path that starts with &#34;../&#34;. If an rsync
daemon is the receiver, the backup dir cannot go outside the module&#39;s
path hierarchy, so take extra care not to delete it or copy into it.</dd>
<dt>
–suffix=SUFFIX
</dt>
<dd>This option allows you to override the default
backup suffix used with the <strong>–backup</strong> (<strong>-b</strong>) option. The default
suffix is a <strong>~</strong> if no <strong>–backup-dir</strong> was specified, otherwise it is an
empty string.</dd>
<dt>
–update, -u
</dt>
<dd>This forces rsync to skip any files which exist on the
destination and have a modified time that is newer than the source
file. (If an existing destination file has a modification time equal
to the source file&#39;s, it will be updated if the sizes are different.)

Note that this does not affect the copying of dirs, symlinks, or other
special files. Also, a difference of file format between the sender
and receiver is always considered to be important enough for an
update, no matter what date is on the objects. In other words, if the
source has a directory where the destination has a file, the transfer
would occur regardless of the timestamps.

This option is a TRANSFER RULE, so don&#39;t expect any exclude side
effects.

A caution for those that choose to combine <strong>–inplace</strong> with
<strong>–update</strong>: an interrupted transfer will leave behind a partial file
on the receiving side that has a very recent modified time, so
re-running the transfer will probably <strong>not</strong> continue the interrupted
file. As such, it is usually best to avoid combining this with
<strong>–inplace</strong> unless you have implemented manual steps to handle any
interrupted in-progress files.</dd>
<dt>
–inplace
</dt>
<dd>This option changes how rsync transfers a file when its
data needs to be updated: instead of the default method of creating a
new copy of the file and moving it into place when it is complete,
rsync instead writes the updated data directly to the destination
file.

This has several effects:</dd>
</dl>
<blockquote>
<ol>
<li value="15">Hard links are not broken. This means the new data will be
visible through other hard links to the destination file. Moreover,
attempts to copy differing source files onto a multiply-linked
destination file will result in a &#34;tug of war&#34; with the destination
data changing back and forth.</li>
<li>In-use binaries cannot be updated (either the OS will prevent this
from happening, or binaries that attempt to swap-in their data will
misbehave or crash).</li>
<li>The file&#39;s data will be in an inconsistent state during the transfer
and will be left that way if the transfer is interrupted or if an
update fails.</li>
<li>A file that rsync cannot write to cannot be updated. While a super
user can update any file, a normal user needs to be granted write
permission for the open of the file for writing to be successful.</li>
<li>The efficiency of rsync&#39;s delta-transfer algorithm may be reduced if
some data in the destination file is overwritten before it can be
copied to a position later in the file. This does not apply if you
use <strong>–backup</strong>, since rsync is smart enough to use the backup file
as the basis file for the transfer.</li>
</ol>
</blockquote>
<blockquote>
<p>WARNING: you should not use this option to update files that are being
accessed by others, so be careful when choosing to use this for a copy.</p>
</blockquote>
<blockquote>
<p>This option is useful for transferring large files with block-based
changes or appended data, and also on systems that are disk bound, not
network bound. It can also help keep a copy-on-write filesystem snapshot
from diverging the entire contents of a file that only has minor
changes.</p>
</blockquote>
<blockquote>
<p>The option implies <strong>–partial</strong> (since an interrupted transfer does not
delete the file), but conflicts with <strong>–partial-dir</strong> and
<strong>–delay-updates</strong>. Prior to rsync 2.6.4 <strong>–inplace</strong> was also
incompatible with <strong>–compare-dest</strong> and <strong>–link-dest</strong>.</p>
</blockquote>
<dl>
<dt>
–append
</dt>
<dd>This special copy mode only works to efficiently update
files that are known to be growing larger where any existing content
on the receiving side is also known to be the same as the content on
the sender. The use of <strong>–append</strong> <strong>can be dangerous</strong> if you aren&#39;t
100% sure that all the files in the transfer are shared, growing
files. You should thus use filter rules to ensure that you weed out
any files that do not fit this criteria.

Rsync updates these growing file in-place without verifying any of the
existing content in the file (it only verifies the content that it is
appending). Rsync skips any files that exist on the receiving side
that are not shorter than the associated file on the sending side
(which means that new files are transferred). It also skips any files
whose size on the sending side gets shorter during the send
negotiations (rsync warns about a &#34;diminished&#34; file when this
happens).

This does not interfere with the updating of a file&#39;s non-content
attributes (e.g. permissions, ownership, etc.) when the file does not
need to be transferred, nor does it affect the updating of any
directories or non-regular files.</dd>
<dt>
–append-verify
</dt>
<dd>This special copy mode works like <strong>–append</strong> except
that all the data in the file is included in the checksum verification
(making it less efficient but also potentially safer). This option
<strong>can be dangerous</strong> if you aren&#39;t 100% sure that all the files in the
transfer are shared, growing files. See the <strong>–append</strong> option for more
details.

Note: prior to rsync 3.0.0, the <strong>–append</strong> option worked like
<strong>–append-verify</strong>, so if you are interacting with an older rsync (or
the transfer is using a protocol prior to 30), specifying either
append option will initiate an <strong>–append-verify</strong> transfer.</dd>
<dt>
–dirs, -d
</dt>
<dd>Tell the sending side to include any directories that
are encountered. Unlike <strong>–recursive</strong>, a directory&#39;s contents are not
copied unless the directory name specified is &#34;.&#34; or ends with a
trailing slash (e.g. &#34;.&#34;, &#34;dir/.&#34;, &#34;dir/&#34;, etc.). Without this option
or the <strong>–recursive</strong> option, rsync will skip all directories it
encounters (and output a message to that effect for each one). If you
specify both <strong>–dirs</strong> and <strong>–recursive</strong>, <strong>–recursive</strong> takes
precedence.

The <strong>–dirs</strong> option is implied by the <strong>–files-from</strong> option or the
<strong>–list-only</strong> option (including an implied <strong>–list-only</strong> usage) if
<strong>–recursive</strong> wasn&#39;t specified (so that directories are seen in the
listing). Specify <strong>–no-dirs</strong> (or <strong>–no-d</strong>) if you want to turn this
off.

There is also a backward-compatibility helper option, <strong>–old-dirs</strong>
(<strong>–old-d</strong>) that tells rsync to use a hack of <strong>-r –exclude=&#39;<em>*</em></strong>&#39;* to
get an older rsync to list a single directory without recursing.</dd>
<dt>
–mkpath
</dt>
<dd>
<p>Create all missing path components of the destination
path.</p>
<p>
By default, rsync allows only the final component of the destination
path to not exist, which is an attempt to help you to validate your
destination path. With this option, rsync creates all the missing
destination-path components, just as if <strong>mkdir -p $DEST_PATH</strong> had been
run on the receiving side.</p>
<p>
When specifying a destination path, including a trailing slash ensures
that the whole path is treated as directory names to be created, even
when the file list has a single item. See the COPYING TO A DIFFERENT
NAME section for full details on how rsync decides if a final
destination-path component should be created as a directory or not.</p>
<p>
If you would like the newly-created destination dirs to match the dirs
on the sending side, you should be using <strong>–relative</strong> (<strong>-R</strong>) instead
of <strong>–mkpath</strong>. For instance, the following two commands result in the
same destination tree, but only the second command ensures that the
&#34;some/extra/path&#34; components match the dirs on the sending side:</p>
<pre class="example">
rsync -ai --mkpath host:some/extra/path/*.c some/extra/path/
rsync -aiR host:some/extra/path/*.c ./
</pre>
</dd>
<dt>
–links, -l
</dt>
<dd>Add symlinks to the transferred files instead of
noisily ignoring them with a &#34;non-regular file&#34; warning for each
symlink encountered. You can alternately silence the warning by
specifying <strong>–info=nonreg0</strong>.

The default handling of symlinks is to recreate each symlink&#39;s
unchanged value on the receiving side.

See the SYMBOLIC LINKS section for multi-option info.</dd>
<dt>
–copy-links, -L
</dt>
<dd>The sender transforms each symlink encountered in
the transfer into the referent item, following the symlink chain to
the file or directory that it references. If a symlink chain is
broken, an error is output and the file is dropped from the transfer.

This option supersedes any other options that affect symlinks in the
transfer, since there are no symlinks left in the transfer.

This option does not change the handling of existing symlinks on the
receiving side, unlike versions of rsync prior to 2.6.3 which had the
side-effect of telling the receiving side to also follow symlinks. A
modern rsync won&#39;t forward this option to a remote receiver (since
only the sender needs to know about it), so this caveat should only
affect someone using an rsync client older than 2.6.7 (which is when
<strong>-L</strong> stopped being forwarded to the receiver).

See the <strong>–keep-dirlinks</strong> (<strong>-K</strong>) if you need a symlink to a directory
to be treated as a real directory on the receiving side.

See the SYMBOLIC LINKS section for multi-option info.</dd>
<dt>
–copy-unsafe-links
</dt>
<dd>This tells rsync to copy the referent of
symbolic links that point outside the copied tree. Absolute symlinks
are also treated like ordinary files, and so are any symlinks in the
source path itself when <strong>–relative</strong> is used.

Note that the cut-off point is the top of the transfer, which is the
part of the path that rsync isn&#39;t mentioning in the verbose output. If
you copy &#34;<em>src/subdir&#34; to &#34;/dest</em>&#34; then the &#34;subdir&#34; directory is a
name inside the transfer tree, not the top of the transfer (which is
/src) so it is legal for created relative symlinks to refer to other
names inside the <em>src and /dest directories. If you instead copy
&#34;/src/subdir</em>&#34; (with a trailing slash) to &#34;/dest/subdir&#34; that would
not allow symlinks to any files outside of &#34;subdir&#34;.

Note that safe symlinks are only copied if <strong>–links</strong> was also
specified or implied. The <strong>–copy-unsafe-links</strong> option has no extra
effect when combined with <strong>–copy-links</strong>.

See the SYMBOLIC LINKS section for multi-option info.</dd>
<dt>
–safe-links
</dt>
<dd>This tells the receiving rsync to ignore any symbolic
links in the transfer which point outside the copied tree. All
absolute symlinks are also ignored.

Since this ignoring is happening on the receiving side, it will still
be effective even when the sending side has munged symlinks (when it
is using <strong>–munge-links</strong>). It also affects deletions, since the file
being present in the transfer prevents any matching file on the
receiver from being deleted when the symlink is deemed to be unsafe
and is skipped.

This option must be combined with <strong>–links</strong> (or <strong>–archive</strong>) to have
any symlinks in the transfer to conditionally ignore. Its effect is
superseded by <strong>–copy-unsafe-links</strong>.

Using this option in conjunction with <strong>–relative</strong> may give unexpected
results.

See the SYMBOLIC LINKS section for multi-option info.</dd>
<dt>
–munge-links
</dt>
<dd>This option affects just one side of the transfer and
tells rsync to munge symlink values when it is receiving files or
unmunge symlink values when it is sending files. The munged values
make the symlinks unusable on disk but allows the original contents of
the symlinks to be recovered.

The server-side rsync often enables this option without the client&#39;s
knowledge, such as in an rsync daemon&#39;s configuration file or by an
option given to the rrsync (restricted rsync) script. When specified
on the client side, specify the option normally if it is the client
side that has/needs the munged symlinks, or use <strong>-M–munge-links</strong> to
give the option to the server when it has/needs the munged symlinks.
Note that on a local transfer, the client is the sender, so specifying
the option directly unmunges symlinks while specifying it as a remote
option munges symlinks.

This option has no effect when sent to a daemon via <strong>–remote-option</strong>
because the daemon configures whether it wants munged symlinks via its
&#34;<strong>munge symlinks</strong>&#34; parameter.

The symlink value is munged/unmunged once it is in the transfer, so
any option that transforms symlinks into non-symlinks occurs prior to
the munging/unmunging <strong>except</strong> for <strong>–safe-links</strong>, which is a choice
that the receiver makes, so it bases its decision on the
munged/unmunged value. This does mean that if a receiver has munging
enabled, that using <strong>–safe-links</strong> will cause all symlinks to be
ignored (since they are all absolute).

The method that rsync uses to munge the symlinks is to prefix each
one&#39;s value with the string &#34;<em>rsyncd-munged</em>&#34;. This prevents the links
from being used as long as the directory does not exist. When this
option is enabled, rsync will refuse to run if that path is a
directory or a symlink to a directory (though it only checks at
startup). See also the &#34;munge-symlinks&#34; python script in the support
directory of the source code for a way to munge/unmunge one or more
symlinks in-place.</dd>
<dt>
–copy-dirlinks, -k
</dt>
<dd>
<p>This option causes the sending side to treat a
symlink to a directory as though it were a real directory. This is
useful if you don&#39;t want symlinks to non-directories to be affected,
as they would be using <strong>–copy-links</strong>.</p>
<p>
Without this option, if the sending side has replaced a directory with
a symlink to a directory, the receiving side will delete anything that
is in the way of the new symlink, including a directory hierarchy (as
long as <strong>–force</strong> or <strong>–delete</strong> is in effect).</p>
<p>
See also <strong>–keep-dirlinks</strong> for an analogous option for the receiving
side.</p>
<p>
<strong>–copy-dirlinks</strong> applies to all symlinks to directories in the
source. If you want to follow only a few specified symlinks, a trick
you can use is to pass them as additional source args with a trailing
slash, using <strong>–relative</strong> to make the paths match up right. For
example:</p>
<pre class="example">
rsync -r --relative src/./ src/./follow-me/ dest/
</pre>
<p>
This works because rsync calls *lstat*(2) on the source arg as given,
and the trailing slash makes *lstat*(2) follow the symlink, giving
rise to a directory in the file-list which overrides the symlink found
during the scan of &#34;src/./&#34;.</p>
<p>
See the SYMBOLIC LINKS section for multi-option info.</p>
</dd>
<dt>
–keep-dirlinks, -K
</dt>
<dd>This option causes the receiving side to treat
a symlink to a directory as though it were a real directory, but only
if it matches a real directory from the sender. Without this option,
the receiver&#39;s symlink would be deleted and replaced with a real
directory.

For example, suppose you transfer a directory &#34;foo&#34; that contains a
file &#34;file&#34;, but &#34;foo&#34; is a symlink to directory &#34;bar&#34; on the
receiver. Without <strong>–keep-dirlinks</strong>, the receiver deletes symlink
&#34;foo&#34;, recreates it as a directory, and receives the file into the new
directory. With <strong>–keep-dirlinks</strong>, the receiver keeps the symlink and
&#34;file&#34; ends up in &#34;bar&#34;.

One note of caution: if you use <strong>–keep-dirlinks</strong>, you must trust all
the symlinks in the copy or enable the <strong>–munge-links</strong> option on the
receiving side! If it is possible for an untrusted user to create
their own symlink to any real directory, the user could then (on a
subsequent copy) replace the symlink with a real directory and affect
the content of whatever directory the symlink references. For backup
copies, you are better off using something like a bind mount instead
of a symlink to modify your receiving hierarchy.

See also <strong>–copy-dirlinks</strong> for an analogous option for the sending
side.

See the SYMBOLIC LINKS section for multi-option info.</dd>
<dt>
–hard-links, -H
</dt>
<dd>This tells rsync to look for hard-linked files in
the source and link together the corresponding files on the
destination. Without this option, hard-linked files in the source are
treated as though they were separate files.

This option does NOT necessarily ensure that the pattern of hard links
on the destination exactly matches that on the source. Cases in which
the destination may end up with extra hard links include the
following:</dd>
</dl>
<blockquote>
<ol>
<li value="15">If the destination contains extraneous hard-links (more
linking than what is present in the source file list), the copying
algorithm will not break them explicitly. However, if one or more of
the paths have content differences, the normal file-update process
will break those extra links (unless you are using the <strong>–inplace</strong>
option).</li>
<li>If you specify a <strong>–link-dest</strong> directory that contains hard links,
the linking of the destination files against the <strong>–link-dest</strong> files
can cause some paths in the destination to become linked together
due to the <strong>–link-dest</strong> associations.</li>
</ol>
</blockquote>
<blockquote>
<p>Note that rsync can only detect hard links between files that are inside
the transfer set. If rsync updates a file that has extra hard-link
connections to files outside the transfer, that linkage will be broken.
If you are tempted to use the <strong>–inplace</strong> option to avoid this breakage,
be very careful that you know how your files are being updated so that
you are certain that no unintended changes happen due to lingering hard
links (and see the <strong>–inplace</strong> option for more caveats).</p>
</blockquote>
<blockquote>
<p>If incremental recursion is active (see <strong>–inc-recursive</strong>), rsync may
transfer a missing hard-linked file before it finds that another link
for that contents exists elsewhere in the hierarchy. This does not
affect the accuracy of the transfer (i.e. which files are hard-linked
together), just its efficiency (i.e. copying the data for a new, early
copy of a hard-linked file that could have been found later in the
transfer in another member of the hard-linked set of files). One way to
avoid this inefficiency is to disable incremental recursion using the
<strong>–no-inc-recursive</strong> option.</p>
</blockquote>
<dl>
<dt>
–perms, -p
</dt>
<dd>This option causes the receiving rsync to set the
destination permissions to be the same as the source permissions. (See
also the <strong>–chmod</strong> option for a way to modify what rsync considers to
be the source permissions.)

When this option is <em>off</em>, permissions are set as follows:</dd>
</dl>
<blockquote>
<ol>
<li value="15">Existing files (including updated files) retain their existing
permissions, though the <strong>–executability</strong> option might change just
the execute permission for the file.</li>
<li>New files get their &#34;normal&#34; permission bits set to the source
file&#39;s permissions masked with the receiving directory&#39;s default
permissions (either the receiving process&#39;s umask, or the
permissions specified via the destination directory&#39;s default ACL),
and their special permission bits disabled except in the case where
a new directory inherits a setgid bit from its parent directory.</li>
</ol>
</blockquote>
<blockquote>
<p>Thus, when <strong>–perms</strong> and <strong>–executability</strong> are both disabled, rsync&#39;s
behavior is the same as that of other file-copy utilities, such as
*cp*(1) and *tar*(1).</p>
</blockquote>
<blockquote>
<p>In summary: to give destination files (both old and new) the source
permissions, use <strong>–perms</strong>. To give new files the destination-default
permissions (while leaving existing files unchanged), make sure that the
<strong>–perms</strong> option is off and use <strong>–chmod=ugo=rwX</strong> (which ensures that
all non-masked bits get enabled). If you&#39;d care to make this latter
behavior easier to type, you could define a popt alias for it, such as
putting this line in the file <strong>~/.popt</strong> (the following defines the <strong>-Z</strong>
option, and includes <strong>–no-g</strong> to use the default group of the
destination dir):</p>
</blockquote>
<blockquote>
<pre class="example">
rsync alias -Z --no-p --no-g --chmod=ugo=rwX
</pre>
</blockquote>
<blockquote>
<p>You could then use this new option in a command such as this one:</p>
</blockquote>
<blockquote>
<pre class="example">
rsync -avZ src/ dest/
</pre>
</blockquote>
<blockquote>
<p>(Caveat: make sure that <strong>-a</strong> does not follow <strong>-Z</strong>, or it will re-enable
the two <strong>–no-*</strong> options mentioned above.)</p>
</blockquote>
<blockquote>
<p>The preservation of the destination&#39;s setgid bit on newly-created
directories when <strong>–perms</strong> is off was added in rsync 2.6.7. Older rsync
versions erroneously preserved the three special permission bits for
newly-created files when <strong>–perms</strong> was off, while overriding the
destination&#39;s setgid bit setting on a newly-created directory. Default
ACL observance was added to the ACL patch for rsync 2.6.7, so older (or
non-ACL-enabled) rsyncs use the umask even if default ACLs are present.
(Keep in mind that it is the version of the receiving rsync that affects
these behaviors.)</p>
</blockquote>
<dl>
<dt>
–executability, -E
</dt>
<dd>This option causes rsync to preserve the
executability (or non-executability) of regular files when <strong>–perms</strong>
is not enabled. A regular file is considered to be executable if at
least one &#39;x&#39; is turned on in its permissions. When an existing
destination file&#39;s executability differs from that of the
corresponding source file, rsync modifies the destination file&#39;s
permissions as follows:</dd>
</dl>
<blockquote>
<ol>
<li value="15">To make a file non-executable, rsync turns off all its &#39;x&#39;
permissions.</li>
<li>To make a file executable, rsync turns on each &#39;x&#39; permission that
has a corresponding &#39;r&#39; permission enabled.</li>
</ol>
</blockquote>
<blockquote>
<p>If <strong>–perms</strong> is enabled, this option is ignored.</p>
</blockquote>
<dl>
<dt>
–acls, -A
</dt>
<dd>This option causes rsync to update the destination ACLs
to be the same as the source ACLs. The option also implies <strong>–perms</strong>.

The source and destination systems must have compatible ACL entries
for this option to work properly. See the <strong>–fake-super</strong> option for a
way to backup and restore ACLs that are not compatible.</dd>
<dt>
–xattrs, -X
</dt>
<dd>
<p>This option causes rsync to update the destination
extended attributes to be the same as the source ones.</p>
<p>
For systems that support extended-attribute namespaces, a copy being
done by a super-user copies all namespaces except system.*. A normal
user only copies the user.* namespace. To be able to backup and
restore non-user namespaces as a normal user, see the <strong>–fake-super</strong>
option.</p>
<p>
The above name filtering can be overridden by using one or more filter
options with the <strong>x</strong> modifier. When you specify an xattr-affecting
filter rule, rsync requires that you do your own system/user
filtering, as well as any additional filtering for what xattr names
are copied and what names are allowed to be deleted. For example, to
skip the system namespace, you could specify:</p>
<pre class="example">
--filter=&#39;-x system.*&#39;
</pre>
<p>
To skip all namespaces except the user namespace, you could specify a
negated-user match:</p>
<pre class="example">
--filter=&#39;-x! user.*&#39;
</pre>
<p>
To prevent any attributes from being deleted, you could specify a
receiver-only rule that excludes all names:</p>
<pre class="example">
--filter=&#39;-xr *&#39;
</pre>
<p>
Note that the <strong>-X</strong> option does not copy rsync&#39;s special xattr values
(e.g. those used by <strong>–fake-super</strong>) unless you repeat the option (e.g.
<strong>-XX</strong>). This &#34;copy all xattrs&#34; mode cannot be used with
<strong>–fake-super</strong>.</p>
</dd>
<dt>
–chmod=CHMOD
</dt>
<dd>
<p>This option tells rsync to apply one or more
comma-separated &#34;chmod&#34; modes to the permission of the files in the
transfer. The resulting value is treated as though it were the
permissions that the sending side supplied for the file, which means
that this option can seem to have no effect on existing files if
<strong>–perms</strong> is not enabled.</p>
<p>
In addition to the normal parsing rules specified in the *chmod*(1)
manpage, you can specify an item that should only apply to a directory
by prefixing it with a &#39;D&#39;, or specify an item that should only apply
to a file by prefixing it with a &#39;F&#39;. For example, the following will
ensure that all directories get marked set-gid, that no files are
other-writable, that both are user-writable and group-writable, and
that both have consistent executability across all bits:</p>
<pre class="example">
--chmod=Dg+s,ug+w,Fo-w,+X
</pre>
<p>
Using octal mode numbers is also allowed:</p>
<pre class="example">
--chmod=D2775,F664
</pre>
<p>
It is also legal to specify multiple <strong>–chmod</strong> options, as each
additional option is just appended to the list of changes to make.</p>
<p>
See the <strong>–perms</strong> and <strong>–executability</strong> options for how the resulting
permission value can be applied to the files in the transfer.</p>
</dd>
<dt>
–owner, -o
</dt>
<dd>This option causes rsync to set the owner of the
destination file to be the same as the source file, but only if the
receiving rsync is being run as the super-user (see also the <strong>–super</strong>
and <strong>–fake-super</strong> options). Without this option, the owner of new
and/or transferred files are set to the invoking user on the receiving
side.

The preservation of ownership will associate matching names by
default, but may fall back to using the ID number in some
circumstances (see also the <strong>–numeric-ids</strong> option for a full
discussion).</dd>
<dt>
–group, -g
</dt>
<dd>This option causes rsync to set the group of the
destination file to be the same as the source file. If the receiving
program is not running as the super-user (or if <strong>–no-super</strong> was
specified), only groups that the invoking user on the receiving side
is a member of will be preserved. Without this option, the group is
set to the default group of the invoking user on the receiving side.

The preservation of group information will associate matching names by
default, but may fall back to using the ID number in some
circumstances (see also the <strong>–numeric-ids</strong> option for a full
discussion).</dd>
<dt>
–devices
</dt>
<dd>This option causes rsync to transfer character and block
device files to the remote system to recreate these devices. If the
receiving rsync is not being run as the super-user, rsync silently
skips creating the device files (see also the <strong>–super</strong> and
<strong>–fake-super</strong> options).

By default, rsync generates a &#34;non-regular file&#34; warning for each
device file encountered when this option is not set. You can silence
the warning by specifying <strong>–info=nonreg0</strong>.</dd>
<dt>
–specials
</dt>
<dd>This option causes rsync to transfer special files, such
as named sockets and fifos. If the receiving rsync is not being run as
the super-user, rsync silently skips creating the special files (see
also the <strong>–super</strong> and <strong>–fake-super</strong> options).

By default, rsync generates a &#34;non-regular file&#34; warning for each
special file encountered when this option is not set. You can silence
the warning by specifying <strong>–info=nonreg0</strong>.</dd>
<dt>
-D
</dt>
<dd>The <strong>-D</strong> option is equivalent to &#34;<strong>–devices</strong> <strong>–specials</strong>&#34;.</dd>
<dt>
–copy-devices
</dt>
<dd>This tells rsync to treat a device on the sending
side as a regular file, allowing it to be copied to a normal
destination file (or another device if <strong>–write-devices</strong> was also
specified).

This option is refused by default by an rsync daemon.</dd>
<dt>
–write-devices
</dt>
<dd>This tells rsync to treat a device on the receiving
side as a regular file, allowing the writing of file data into a
device.

This option implies the <strong>–inplace</strong> option.

Be careful using this, as you should know what devices are present on
the receiving side of the transfer, especially when running rsync as
root.

This option is refused by default by an rsync daemon.</dd>
<dt>
–times, -t
</dt>
<dd>This tells rsync to transfer modification times along
with the files and update them on the remote system. Note that if this
option is not used, the optimization that excludes files that have not
been modified cannot be effective; in other words, a missing <strong>-t</strong> (or
<strong>-a</strong>) will cause the next transfer to behave as if it used
<strong>–ignore-times</strong> (<strong>-I</strong>), causing all files to be updated (though
rsync&#39;s delta-transfer algorithm will make the update fairly efficient
if the files haven&#39;t actually changed, you&#39;re much better off using
<strong>-t</strong>).

A modern rsync that is using transfer protocol 30 or 31 conveys a
modify time using up to 8-bytes. If rsync is forced to speak an older
protocol (perhaps due to the remote rsync being older than 3.0.0) a
modify time is conveyed using 4-bytes. Prior to 3.2.7, these shorter
values could convey a date range of 13-Dec-1901 to 19-Jan-2038.
Beginning with 3.2.7, these 4-byte values now convey a date range of
1-Jan-1970 to 7-Feb-2106. If you have files dated older than 1970,
make sure your rsync executables are upgraded so that the full range
of dates can be conveyed.</dd>
<dt>
–atimes, -U
</dt>
<dd>This tells rsync to set the access (use) times of the
destination files to the same value as the source files.

If repeated, it also sets the <strong>–open-noatime</strong> option, which can help
you to make the sending and receiving systems have the same access
times on the transferred files without needing to run rsync an extra
time after a file is transferred.

Note that some older rsync versions (prior to 3.2.0) may have been
built with a pre-release <strong>–atimes</strong> patch that does not imply
<strong>–open-noatime</strong> when this option is repeated.</dd>
<dt>
–open-noatime
</dt>
<dd>This tells rsync to open files with the O_NOATIME
flag (on systems that support it) to avoid changing the access time of
the files that are being transferred. If your OS does not support the
O_NOATIME flag then rsync will silently ignore this option. Note also
that some filesystems are mounted to avoid updating the atime on read
access even without the O_NOATIME flag being set.</dd>
<dt>
–crtimes, -N,
</dt>
<dd>This tells rsync to set the create times (newness)
of the destination files to the same value as the source files. Your
OS &amp; filesystem must support the setting of arbitrary creation (birth)
times for this option to be supported.</dd>
<dt>
–omit-dir-times, -O
</dt>
<dd>This tells rsync to omit directories when it
is preserving modification, access, and create times. If NFS is
sharing the directories on the receiving side, it is a good idea to
use <strong>-O</strong>. This option is inferred if you use <strong>–backup</strong> without
<strong>–backup-dir</strong>.

This option also has the side-effect of avoiding early creation of
missing sub-directories when incremental recursion is enabled, as
discussed in the <strong>–inc-recursive</strong> section.</dd>
<dt>
–omit-link-times, -J
</dt>
<dd>This tells rsync to omit symlinks when it is
preserving modification, access, and create times.</dd>
<dt>
–super
</dt>
<dd>This tells the receiving side to attempt super-user
activities even if the receiving rsync wasn&#39;t run by the super-user.
These activities include: preserving users via the <strong>–owner</strong> option,
preserving all groups (not just the current user&#39;s groups) via the
<strong>–group</strong> option, and copying devices via the <strong>–devices</strong> option. This
is useful for systems that allow such activities without being the
super-user, and also for ensuring that you will get errors if the
receiving side isn&#39;t being run as the super-user. To turn off
super-user activities, the super-user can use <strong>–no-super</strong>.</dd>
<dt>
–fake-super
</dt>
<dd>
<p>When this option is enabled, rsync simulates
super-user activities by saving/restoring the privileged attributes
via special extended attributes that are attached to each file (as
needed). This includes the file&#39;s owner and group (if it is not the
default), the file&#39;s device info (device &amp; special files are created
as empty text files), and any permission bits that we won&#39;t allow to
be set on the real file (e.g. the real file gets u-s,g-s,o-t for
safety) or that would limit the owner&#39;s access (since the real
super-user can always access/change a file, the files we create can
always be accessed/changed by the creating user). This option also
handles ACLs (if <strong>–acls</strong> was specified) and non-user extended
attributes (if <strong>–xattrs</strong> was specified).</p>
<p>
This is a good way to backup data without using a super-user, and to
store ACLs from incompatible systems.</p>
<p>
The <strong>–fake-super</strong> option only affects the side where the option is
used. To affect the remote side of a remote-shell connection, use the
<strong>–remote-option</strong> (<strong>-M</strong>) option:</p>
<pre class="example">
rsync -av -M--fake-super /src/ host:/dest/
</pre>
<p>
For a local copy, this option affects both the source and the
destination. If you wish a local copy to enable this option just for
the destination files, specify <strong>-M–fake-super</strong>. If you wish a local
copy to enable this option just for the source files, combine
<strong>–fake-super</strong> with <strong>-M–super</strong>.</p>
<p>
This option is overridden by both <strong>–super</strong> and <strong>–no-super</strong>.</p>
<p>
See also the <strong>fake super</strong> setting in the daemon&#39;s rsyncd.conf file.</p>
</dd>
<dt>
–sparse, -S
</dt>
<dd>Try to handle sparse files efficiently so they take up
less space on the destination. If combined with <strong>–inplace</strong> the file
created might not end up with sparse blocks with some combinations of
kernel version and/or filesystem type. If <strong>–whole-file</strong> is in effect
(e.g. for a local copy) then it will always work because rsync
truncates the file prior to writing out the updated version.

Note that versions of rsync older than 3.1.3 will reject the
combination of <strong>–sparse</strong> and <strong>–inplace</strong>.</dd>
<dt>
–preallocate
</dt>
<dd>This tells the receiver to allocate each destination
file to its eventual size before writing data to the file. Rsync will
only use the real filesystem-level preallocation support provided by
Linux&#39;s *fallocate*(2) system call or Cygwin&#39;s *posix_fallocate*(3),
not the slow glibc implementation that writes a null byte into each
block.

Without this option, larger files may not be entirely contiguous on
the filesystem, but with this option rsync will probably copy more
slowly. If the destination is not an extent-supporting filesystem
(such as ext4, xfs, NTFS, etc.), this option may have no positive
effect at all.

If combined with <strong>–sparse</strong>, the file will only have sparse blocks (as
opposed to allocated sequences of null bytes) if the kernel version
and filesystem type support creating holes in the allocated data.</dd>
<dt>
–dry-run, -n
</dt>
<dd>This makes rsync perform a trial run that doesn&#39;t
make any changes (and produces mostly the same output as a real run).
It is most commonly used in combination with the <strong>–verbose</strong> (<strong>-v</strong>)
and/or <strong>–itemize-changes</strong> (<strong>-i</strong>) options to see what an rsync command
is going to do before one actually runs it.

The output of <strong>–itemize-changes</strong> is supposed to be exactly the same
on a dry run and a subsequent real run (barring intentional trickery
and system call failures); if it isn&#39;t, that&#39;s a bug. Other output
should be mostly unchanged, but may differ in some areas. Notably, a
dry run does not send the actual data for file transfers, so
<strong>–progress</strong> has no effect, the &#34;bytes sent&#34;, &#34;bytes received&#34;,
&#34;literal data&#34;, and &#34;matched data&#34; statistics are too small, and the
&#34;speedup&#34; value is equivalent to a run where no file transfers were
needed.</dd>
<dt>
–whole-file, -W
</dt>
<dd>This option disables rsync&#39;s delta-transfer
algorithm, which causes all transferred files to be sent whole. The
transfer may be faster if this option is used when the bandwidth
between the source and destination machines is higher than the
bandwidth to disk (especially when the &#34;disk&#34; is actually a networked
filesystem). This is the default when both the source and destination
are specified as local paths, but only if no batch-writing option is
in effect.</dd>
<dt>
–no-whole-file, –no-W
</dt>
<dd>Disable whole-file updating when it is
enabled by default for a local transfer. This usually slows rsync
down, but it can be useful if you are trying to minimize the writes to
the destination file (if combined with <strong>–inplace</strong>) or for testing the
checksum-based update algorithm.

See also the <strong>–whole-file</strong> option.</dd>
<dt>
–checksum-choice=STR, –cc=STR
</dt>
<dd>This option overrides the checksum
algorithms. If one algorithm name is specified, it is used for both
the transfer checksums and (assuming <strong>–checksum</strong> is specified) the
pre-transfer checksums. If two comma-separated names are supplied, the
first name affects the transfer checksums, and the second name affects
the pre-transfer checksums (<strong>-c</strong>).

The checksum options that you may be able to use are:</dd>
</dl>
<blockquote>
<ol>
<li value="15"><strong>auto</strong> (the default automatic choice)</li>
<li><strong>xxh128</strong></li>
<li><strong>xxh3</strong></li>
<li><strong>xxh64</strong> (aka <strong>xxhash</strong>)</li>
<li><strong>md5</strong></li>
<li><strong>md4</strong></li>
<li><strong>sha1</strong></li>
<li><strong>none</strong></li>
</ol>
</blockquote>
<blockquote>
<p>Run <strong>rsync –version</strong> to see the default checksum list compiled into
your version (which may differ from the list above).</p>
</blockquote>
<blockquote>
<p>If &#34;none&#34; is specified for the first (or only) name, the <strong>–whole-file</strong>
option is forced on and no checksum verification is performed on the
transferred data. If &#34;none&#34; is specified for the second (or only) name,
the <strong>–checksum</strong> option cannot be used.</p>
</blockquote>
<blockquote>
<p>The &#34;auto&#34; option is the default, where rsync bases its algorithm choice
on a negotiation between the client and the server as follows:</p>
</blockquote>
<blockquote>
<p>When both sides of the transfer are at least 3.2.0, rsync chooses the
first algorithm in the client&#39;s list of choices that is also in the
server&#39;s list of choices. If no common checksum choice is found, rsync
exits with an error. If the remote rsync is too old to support checksum
negotiation, a value is chosen based on the protocol version (which
chooses between MD5 and various flavors of MD4 based on protocol age).</p>
</blockquote>
<blockquote>
<p>The default order can be customized by setting the environment variable
<strong>RSYNC_CHECKSUM_LIST</strong> to a space-separated list of acceptable checksum
names. If the string contains a &#34;<strong>&amp;</strong>&#34; character, it is separated into
the &#34;client string &amp; server string&#34;, otherwise the same string applies
to both. If the string (or string portion) contains no non-whitespace
characters, the default checksum list is used. This method does not
allow you to specify the transfer checksum separately from the
pre-transfer checksum, and it discards &#34;auto&#34; and all unknown checksum
names. A list with only invalid names results in a failed negotiation.</p>
</blockquote>
<blockquote>
<p>The use of the <strong>–checksum-choice</strong> option overrides this environment
list.</p>
</blockquote>
<dl>
<dt>
–one-file-system, -x
</dt>
<dd>This tells rsync to avoid crossing a
filesystem boundary when recursing. This does not limit the user&#39;s
ability to specify items to copy from multiple filesystems, just
rsync&#39;s recursion through the hierarchy of each directory that the
user specified, and also the analogous recursion on the receiving side
during deletion. Also keep in mind that rsync treats a &#34;bind&#34; mount to
the same device as being on the same filesystem.

If this option is repeated, rsync omits all mount-point directories
from the copy. Otherwise, it includes an empty directory at each
mount-point it encounters (using the attributes of the mounted
directory because those of the underlying mount-point directory are
inaccessible).

If rsync has been told to collapse symlinks (via <strong>–copy-links</strong> or
<strong>–copy-unsafe-links</strong>), a symlink to a directory on another device is
treated like a mount-point. Symlinks to non-directories are unaffected
by this option.</dd>
<dt>
–ignore-non-existing, –existing
</dt>
<dd>This tells rsync to skip creating
files (including directories) that do not exist yet on the
destination. If this option is combined with the <strong>–ignore-existing</strong>
option, no files will be updated (which can be useful if all you want
to do is delete extraneous files).

This option is a TRANSFER RULE, so don&#39;t expect any exclude side
effects.</dd>
<dt>
–ignore-existing
</dt>
<dd>This tells rsync to skip updating files that
already exist on the destination (this does <em>not</em> ignore existing
directories, or nothing would get done). See also
<strong>–ignore-non-existing</strong>.

This option is a TRANSFER RULE, so don&#39;t expect any exclude side
effects.

This option can be useful for those doing backups using the
<strong>–link-dest</strong> option when they need to continue a backup run that got
interrupted. Since a <strong>–link-dest</strong> run is copied into a new directory
hierarchy (when it is used properly), using [*–ignore-existing* will
ensure that the already-handled files don&#39;t get tweaked (which avoids
a change in permissions on the hard-linked files). This does mean that
this option is only looking at the existing files in the destination
hierarchy itself.

When <strong>–info=skip2</strong> is used rsync will output &#34;FILENAME exists (INFO)&#34;
messages where the INFO indicates one of &#34;type change&#34;, &#34;sum change&#34;
(requires <strong>-c</strong>), &#34;file change&#34; (based on the quick check), &#34;attr
change&#34;, or &#34;uptodate&#34;. Using <strong>–info=skip1</strong> (which is also implied by
2 <strong>-v</strong> options) outputs the exists message without the INFO suffix.</dd>
<dt>
–remove-source-files
</dt>
<dd>This tells rsync to remove from the sending
side the files (meaning non-directories) that are a part of the
transfer and have been successfully duplicated on the receiving side.

Note that you should only use this option on source files that are
quiescent. If you are using this to move files that show up in a
particular directory over to another host, make sure that the finished
files get renamed into the source directory, not directly written into
it, so that rsync can&#39;t possibly transfer a file that is not yet fully
written. If you can&#39;t first write the files into a different
directory, you should use a naming idiom that lets rsync avoid
transferring files that are not yet finished (e.g. name the file
&#34;foo.new&#34; when it is written, rename it to &#34;foo&#34; when it is done, and
then use the option <strong>–exclude=&#39;</strong>.new&#39;* for the rsync transfer).

Starting with 3.1.0, rsync will skip the sender-side removal (and
output an error) if the file&#39;s size or modify time has not stayed
unchanged.

Starting with 3.2.6, a local rsync copy will ensure that the sender
does not remove a file the receiver just verified, such as when the
user accidentally makes the source and destination directory the same
path.</dd>
<dt>
–delete
</dt>
<dd>This tells rsync to delete extraneous files from the
receiving side (ones that aren&#39;t on the sending side), but only for
the directories that are being synchronized. You must have asked rsync
to send the whole directory (e.g. &#34;<strong>dir</strong>&#34; or &#34;<strong>dir/</strong>&#34;) without using a
wildcard for the directory&#39;s contents (e.g. &#34;<strong>dir/*</strong>&#34;) since the
wildcard is expanded by the shell and rsync thus gets a request to
transfer individual files, not the files&#39; parent directory. Files that
are excluded from the transfer are also excluded from being deleted
unless you use the <strong>–delete-excluded</strong> option or mark the rules as
only matching on the sending side (see the include/exclude modifiers
in the FILTER RULES section).

Prior to rsync 2.6.7, this option would have no effect unless
<strong>–recursive</strong> was enabled. Beginning with 2.6.7, deletions will also
occur when <strong>–dirs</strong> (<strong>-d</strong>) is enabled, but only for directories whose
contents are being copied.

This option can be dangerous if used incorrectly! It is a very good
idea to first try a run using the <strong>–dry-run</strong> (<strong>-n</strong>) option to see
what files are going to be deleted.

If the sending side detects any I/O errors, then the deletion of any
files at the destination will be automatically disabled. This is to
prevent temporary filesystem failures (such as NFS errors) on the
sending side from causing a massive deletion of files on the
destination. You can override this with the <strong>–ignore-errors</strong> option.

The <strong>–delete</strong> option may be combined with one of the –delete-WHEN
options without conflict, as well as <strong>–delete-excluded</strong>. However, if
none of the <strong>–delete-WHEN</strong> options are specified, rsync will choose
the <strong>–delete-during</strong> algorithm when talking to rsync 3.0.0 or newer,
or the <strong>–delete-before</strong> algorithm when talking to an older rsync. See
also <strong>–delete-delay</strong> and <strong>–delete-after</strong>.</dd>
<dt>
–delete-before
</dt>
<dd>Request that the file-deletions on the receiving
side be done before the transfer starts. See <strong>–delete</strong> (which is
implied) for more details on file-deletion.

Deleting before the transfer is helpful if the filesystem is tight for
space and removing extraneous files would help to make the transfer
possible. However, it does introduce a delay before the start of the
transfer, and this delay might cause the transfer to timeout (if
<strong>–timeout</strong> was specified). It also forces rsync to use the old,
non-incremental recursion algorithm that requires rsync to scan all
the files in the transfer into memory at once (see <strong>–recursive</strong>).</dd>
<dt>
–delete-during, –del
</dt>
<dd>Request that the file-deletions on the
receiving side be done incrementally as the transfer happens. The
per-directory delete scan is done right before each directory is
checked for updates, so it behaves like a more efficient
<strong>–delete-before</strong>, including doing the deletions prior to any
per-directory filter files being updated. This option was first added
in rsync version 2.6.4. See <strong>–delete</strong> (which is implied) for more
details on file-deletion.</dd>
<dt>
–delete-delay
</dt>
<dd>Request that the file-deletions on the receiving
side be computed during the transfer (like <strong>–delete-during</strong>), and
then removed after the transfer completes. This is useful when
combined with <strong>–delay-updates</strong> and/or <strong>–fuzzy</strong>, and is more
efficient than using <strong>–delete-after</strong> (but can behave differently,
since <strong>–delete-after</strong> computes the deletions in a separate pass after
all updates are done). If the number of removed files overflows an
internal buffer, a temporary file will be created on the receiving
side to hold the names (it is removed while open, so you shouldn&#39;t see
it during the transfer). If the creation of the temporary file fails,
rsync will try to fall back to using <strong>–delete-after</strong> (which it cannot
do if <strong>–recursive</strong> is doing an incremental scan). See <strong>–delete</strong>
(which is implied) for more details on file-deletion.</dd>
<dt>
–delete-after
</dt>
<dd>Request that the file-deletions on the receiving
side be done after the transfer has completed. This is useful if you
are sending new per-directory merge files as a part of the transfer
and you want their exclusions to take effect for the delete phase of
the current transfer. It also forces rsync to use the old,
non-incremental recursion algorithm that requires rsync to scan all
the files in the transfer into memory at once (see <strong>–recursive</strong>). See
<strong>–delete</strong> (which is implied) for more details on file-deletion.

See also the <strong>–delete-delay</strong> option that might be a faster choice for
those that just want the deletions to occur at the end of the
transfer.</dd>
<dt>
–delete-excluded
</dt>
<dd>This option turns any unqualified exclude/include
rules into server-side rules that do not affect the receiver&#39;s
deletions.

By default, an exclude or include has both a server-side effect (to
&#34;hide&#34; and &#34;show&#34; files when building the server&#39;s file list) and a
receiver-side effect (to &#34;protect&#34; and &#34;risk&#34; files when deletions are
occurring). Any rule that has no modifier to specify what sides it is
executed on will be instead treated as if it were a server-side rule
only, avoiding any &#34;protect&#34; effects of the rules.

A rule can still apply to both sides even with this option specified
if the rule is given both the sender &amp; receiver modifier letters
(e.g., <strong>-f&#39;-sr foo&#39;</strong>). Receiver-side protect/risk rules can also be
explicitly specified to limit the deletions. This saves you from
having to edit a bunch of <strong>-f&#39;- foo&#39;</strong> rules into <strong>-f&#39;-s foo&#39;</strong> (aka
<strong>-f&#39;H foo&#39;</strong>) rules (not to mention the corresponding includes).

See the FILTER RULES section for more information. See <strong>–delete</strong>
(which is implied) for more details on deletion.</dd>
<dt>
–ignore-missing-args
</dt>
<dd>When rsync is first processing the explicitly
requested source files (e.g. command-line arguments or <strong>–files-from</strong>
entries), it is normally an error if the file cannot be found. This
option suppresses that error, and does not try to transfer the file.
This does not affect subsequent vanished-file errors if a file was
initially found to be present and later is no longer there.</dd>
<dt>
–delete-missing-args
</dt>
<dd>This option takes the behavior of the
(implied) <strong>–ignore-missing-args</strong> option a step farther: each missing
arg will become a deletion request of the corresponding destination
file on the receiving side (should it exist). If the destination file
is a non-empty directory, it will only be successfully deleted if
<strong>–force</strong> or <strong>–delete</strong> are in effect. Other than that, this option is
independent of any other type of delete processing.

The missing source files are represented by special file-list entries
which display as a &#34;<strong>*missing</strong>&#34; entry in the <strong>–list-only</strong> output.</dd>
<dt>
–ignore-errors
</dt>
<dd>Tells <strong>–delete</strong> to go ahead and delete files even
when there are I/O errors.</dd>
<dt>
–force
</dt>
<dd>This option tells rsync to delete a non-empty directory
when it is to be replaced by a non-directory. This is only relevant if
deletions are not active (see <strong>–delete</strong> for details).

Note for older rsync versions: <strong>–force</strong> used to still be required
when using <strong>–delete-after</strong>, and it used to be non-functional unless
the <strong>–recursive</strong> option was also enabled.</dd>
<dt>
–max-delete=NUM
</dt>
<dd>This tells rsync not to delete more than NUM files
or directories. If that limit is exceeded, all further deletions are
skipped through the end of the transfer. At the end, rsync outputs a
warning (including a count of the skipped deletions) and exits with an
error code of 25 (unless some more important error condition also
occurred).

Beginning with version 3.0.0, you may specify <strong>–max-delete=0</strong> to be
warned about any extraneous files in the destination without removing
any of them. Older clients interpreted this as &#34;unlimited&#34;, so if you
don&#39;t know what version the client is, you can use the less obvious
<strong>–max-delete=-1</strong> as a backward-compatible way to specify that no
deletions be allowed (though really old versions didn&#39;t warn when the
limit was exceeded).</dd>
<dt>
–max-size=SIZE
</dt>
<dd>This tells rsync to avoid transferring any file
that is larger than the specified SIZE. A numeric value can be
suffixed with a string to indicate the numeric units or left
unqualified to specify bytes. Feel free to use a fractional value
along with the units, such as <strong>–max-size=1.5m</strong>.

This option is a TRANSFER RULE, so don&#39;t expect any exclude side
effects.

The first letter of a units string can be <strong>B</strong> (bytes), <strong>K</strong> (kilo), <strong>M</strong>
(mega), <strong>G</strong> (giga), <strong>T</strong> (tera), or <strong>P</strong> (peta). If the string is a
single char or has &#34;ib&#34; added to it (e.g. &#34;G&#34; or &#34;GiB&#34;) then the units
are multiples of 1024. If you use a two-letter suffix that ends with a
&#34;B&#34; (e.g. &#34;kb&#34;) then you get units that are multiples of 1000. The
string&#39;s letters can be any mix of upper and lower-case that you want
to use.

Finally, if the string ends with either &#34;+1&#34; or &#34;-1&#34;, it is offset by
one byte in the indicated direction. The largest possible value is
usually <strong>8192P-1</strong>.

Examples: <strong>–max-size=1.5mb-1</strong> is 1499999 bytes, and <strong>–max-size=2g+1</strong>
is 2147483649 bytes.

Note that rsync versions prior to 3.1.0 did not allow <strong>–max-size=0</strong>.</dd>
<dt>
–min-size=SIZE
</dt>
<dd>This tells rsync to avoid transferring any file
that is smaller than the specified SIZE, which can help in not
transferring small, junk files. See the <strong>–max-size</strong> option for a
description of SIZE and other info.

Note that rsync versions prior to 3.1.0 did not allow <strong>–min-size=0</strong>.</dd>
<dt>
–max-alloc=SIZE
</dt>
<dd>By default rsync limits an individual
malloc/realloc to about 1GB in size. For most people this limit works
just fine and prevents a protocol error causing rsync to request
massive amounts of memory. However, if you have many millions of files
in a transfer, a large amount of server memory, and you don&#39;t want to
split up your transfer into multiple parts, you can increase the
per-allocation limit to something larger and rsync will consume more
memory.

Keep in mind that this is not a limit on the total size of allocated
memory. It is a sanity-check value for each individual allocation.

See the <strong>–max-size</strong> option for a description of how SIZE can be
specified. The default suffix if none is given is bytes.

Beginning in 3.2.7, a value of 0 is an easy way to specify SIZE_MAX
(the largest limit possible).

You can set a default value using the environment variable
<strong>RSYNC_MAX_ALLOC</strong> using the same SIZE values as supported by this
option. If the remote rsync doesn&#39;t understand the <strong>–max-alloc</strong>
option, you can override an environmental value by specifying
<strong>–max-alloc=1g</strong>, which will make rsync avoid sending the option to
the remote side (because &#34;1G&#34; is the default).</dd>
<dt>
–block-size=SIZE, -B
</dt>
<dd>This forces the block size used in rsync&#39;s
delta-transfer algorithm to a fixed value. It is normally selected
based on the size of each file being updated. See the technical report
for details.

Beginning in 3.2.3 the SIZE can be specified with a suffix as detailed
in the <strong>–max-size</strong> option. Older versions only accepted a byte count.</dd>
<dt>
–rsh=COMMAND, -e
</dt>
<dd>
<p>This option allows you to choose an alternative
remote shell program to use for communication between the local and
remote copies of rsync. Typically, rsync is configured to use ssh by
default, but you may prefer to use rsh on a local network.</p>
<p>
If this option is used with <strong>[user@]host::module/path</strong>, then the
remote shell <em>COMMAND</em> will be used to run an rsync daemon on the
remote host, and all data will be transmitted through that remote
shell connection, rather than through a direct socket connection to a
running rsync daemon on the remote host. See the USING RSYNC-DAEMON
FEATURES VIA A REMOTE-SHELL CONNECTION section above.</p>
<p>
Beginning with rsync 3.2.0, the <strong>RSYNC_PORT</strong> environment variable will
be set when a daemon connection is being made via a remote-shell
connection. It is set to 0 if the default daemon port is being
assumed, or it is set to the value of the rsync port that was
specified via either the <strong>–port</strong> option or a non-empty port value in
an <strong>rsync://</strong> URL. This allows the script to discern if a non-default
port is being requested, allowing for things such as an SSL or stunnel
helper script to connect to a default or alternate port.</p>
<p>
Command-line arguments are permitted in COMMAND provided that COMMAND
is presented to rsync as a single argument. You must use spaces (not
tabs or other whitespace) to separate the command and args from each
other, and you can use single- and/or double-quotes to preserve spaces
in an argument (but not backslashes). Note that doubling a
single-quote inside a single-quoted string gives you a single-quote;
likewise for double-quotes (though you need to pay attention to which
quotes your shell is parsing and which quotes rsync is parsing). Some
examples:</p>
<pre class="example">
-e &#39;ssh -p 2234&#39;
-e &#39;ssh -o &#34;ProxyCommand nohup ssh firewall nc -w1 %h %p&#34;&#39;
</pre>
<p>
(Note that ssh users can alternately customize site-specific connect
options in their .ssh/config file.)</p>
<p>
You can also choose the remote shell program using the <strong>RSYNC_RSH</strong>
environment variable, which accepts the same range of values as <strong>-e</strong>.</p>
<p>
See also the <strong>–blocking-io</strong> option which is affected by this option.</p>
</dd>
<dt>
–rsync-path=PROGRAM
</dt>
<dd>
<p>Use this to specify what program is to be run
on the remote machine to start-up rsync. Often used when rsync is not
in the default remote-shell&#39;s path (e.g.
<strong>–rsync-path=/usr/local/bin/rsync</strong>). Note that PROGRAM is run with
the help of a shell, so it can be any program, script, or command
sequence you&#39;d care to run, so long as it does not corrupt the
standard-in &amp; standard-out that rsync is using to communicate.</p>
<p>
One tricky example is to set a different default directory on the
remote machine for use with the <strong>–relative</strong> option. For instance:</p>
<pre class="example">
rsync -avR --rsync-path=&#34;cd /a/b &amp;&amp; rsync&#34; host:c/d /e/
</pre>
</dd>
<dt>
–remote-option=OPTION, -M
</dt>
<dd>
<p>This option is used for more advanced
situations where you want certain effects to be limited to one side of
the transfer only. For instance, if you want to pass <strong>–log-file=FILE</strong>
and <strong>–fake-super</strong> to the remote system, specify it like this:</p>
<pre class="example">
rsync -av -M --log-file=foo -M--fake-super src/ dest/
</pre>
<p>
If you want to have an option affect only the local side of a transfer
when it normally affects both sides, send its negation to the remote
side. Like this:</p>
<pre class="example">
rsync -av -x -M--no-x src/ dest/
</pre>
<p>
Be cautious using this, as it is possible to toggle an option that
will cause rsync to have a different idea about what data to expect
next over the socket, and that will make it fail in a cryptic fashion.</p>
<p>
Note that you should use a separate <strong>-M</strong> option for each remote option
you want to pass. On older rsync versions, the presence of any spaces
in the remote-option arg could cause it to be split into separate
remote args, but this requires the use of <strong>–old-args</strong> in a modern
rsync.</p>
<p>
When performing a local transfer, the &#34;local&#34; side is the sender and
the &#34;remote&#34; side is the receiver.</p>
<p>
Note some versions of the popt option-parsing library have a bug in
them that prevents you from using an adjacent arg with an equal in it
next to a short option letter (e.g. <strong>-M–log-file=/tmp/foo</strong>). If this
bug affects your version of popt, you can use the version of popt that
is included with rsync.</p>
</dd>
<dt>
–cvs-exclude, -C
</dt>
<dd>
<p>This is a useful shorthand for excluding a broad
range of files that you often don&#39;t want to transfer between systems.
It uses a similar algorithm to CVS to determine if a file should be
ignored.</p>
<p>
The exclude list is initialized to exclude the following items (these
initial items are marked as perishable – see the FILTER RULES
section):</p>
<blockquote>
<p><strong>RCS</strong> <strong>SCCS</strong> <strong>CVS</strong> <strong>CVS.adm</strong> <strong>RCSLOG</strong> <strong>cvslog.*</strong> <strong>tags</strong> <strong>TAGS</strong>
<strong>.make.state</strong> <strong>.nse_depinfo</strong> <strong>*~</strong> <strong>#*</strong> <strong>.#*</strong> <strong>,*</strong> <strong>_$*</strong> <strong>*$</strong> <strong>*.old</strong>
<strong>*.bak</strong> <strong>*.BAK</strong> <strong>*.orig</strong> <strong>*.rej</strong> <strong>.del-*</strong> <strong>*.a</strong> <strong>*.olb</strong> <strong>*.o</strong> <strong>*.obj</strong>
<strong>*.so</strong> <strong>*.exe</strong> <strong>*.Z</strong> <strong>*.elc</strong> <strong>*.ln</strong> <strong>core</strong> <strong>.svn/</strong> <strong>.git/</strong> <strong>.hg/</strong>
<strong>.bzr/</strong></p>
</blockquote>
<p>
then, files listed in a $HOME/.cvsignore are added to the list and any
files listed in the CVSIGNORE environment variable (all cvsignore
names are delimited by whitespace).</p>
<p>
Finally, any file is ignored if it is in the same directory as a
.cvsignore file and matches one of the patterns listed therein. Unlike
rsync&#39;s filter/exclude files, these patterns are split on whitespace.
See the *cvs*(1) manual for more information.</p>
<p>
If you&#39;re combining <strong>-C</strong> with your own <strong>–filter</strong> rules, you should
note that these CVS excludes are appended at the end of your own
rules, regardless of where the <strong>-C</strong> was placed on the command-line.
This makes them a lower priority than any rules you specified
explicitly. If you want to control where these CVS excludes get
inserted into your filter rules, you should omit the <strong>-C</strong> as a
command-line option and use a combination of <strong>–filter=:C</strong> and
<strong>–filter=-C</strong> (either on your command-line or by putting the &#34;:C&#34; and
&#34;-C&#34; rules into a filter file with your other rules). The first option
turns on the per-directory scanning for the .cvsignore file. The
second option does a one-time import of the CVS excludes mentioned
above.</p>
</dd>
<dt>
–filter=RULE, -f
</dt>
<dd>This option allows you to add rules to
selectively exclude certain files from the list of files to be
transferred. This is most useful in combination with a recursive
transfer.

You may use as many <strong>–filter</strong> options on the command line as you like
to build up the list of files to exclude. If the filter contains
whitespace, be sure to quote it so that the shell gives the rule to
rsync as a single argument. The text below also mentions that you can
use an underscore to replace the space that separates a rule from its
arg.

See the FILTER RULES section for detailed information on this option.</dd>
<dt>
-F
</dt>
<dd>
<p>The <strong>-F</strong> option is a shorthand for adding two <strong>–filter</strong> rules
to your command. The first time it is used is a shorthand for this
rule:</p>
<pre class="example">
--filter=&#39;dir-merge /.rsync-filter&#39;
</pre>
<p>
This tells rsync to look for per-directory .rsync-filter files that
have been sprinkled through the hierarchy and use their rules to
filter the files in the transfer. If <strong>-F</strong> is repeated, it is a
shorthand for this rule:</p>
<pre class="example">
--filter=&#39;exclude .rsync-filter&#39;
</pre>
<p>
This filters out the .rsync-filter files themselves from the transfer.</p>
<p>
See the FILTER RULES section for detailed information on how these
options work.</p>
</dd>
<dt>
–exclude=PATTERN
</dt>
<dd>This option is a simplified form of the
<strong>–filter</strong> option that specifies an exclude rule and does not allow
the full rule-parsing syntax of normal filter rules. This is
equivalent to specifying <strong>-f&#39;- PATTERN&#39;</strong>.

See the FILTER RULES section for detailed information on this option.</dd>
<dt>
–exclude-from=FILE
</dt>
<dd>This option is related to the <strong>–exclude</strong>
option, but it specifies a FILE that contains exclude patterns (one
per line). Blank lines in the file are ignored, as are whole-line
comments that start with &#39;<strong>;</strong>&#39; or &#39;<strong>#</strong>&#39; (filename rules that contain
those characters are unaffected).

If a line begins with &#34;*- *&#34; (dash, space) or &#34;*+ *&#34; (plus, space),
then the type of rule is being explicitly specified as an exclude or
an include (respectively). Any rules without such a prefix are taken
to be an exclude.

If a line consists of just &#34;<strong>!</strong>&#34;, then the current filter rules are
cleared before adding any further rules.

If <em>FILE</em> is &#39;<strong>-</strong>&#39;, the list will be read from standard input.</dd>
<dt>
–include=PATTERN
</dt>
<dd>This option is a simplified form of the
<strong>–filter</strong> option that specifies an include rule and does not allow
the full rule-parsing syntax of normal filter rules. This is
equivalent to specifying <strong>-f&#39;+ PATTERN&#39;</strong>.

See the FILTER RULES section for detailed information on this option.</dd>
<dt>
–include-from=FILE
</dt>
<dd>This option is related to the <strong>–include</strong>
option, but it specifies a FILE that contains include patterns (one
per line). Blank lines in the file are ignored, as are whole-line
comments that start with &#39;<strong>;</strong>&#39; or &#39;<strong>#</strong>&#39; (filename rules that contain
those characters are unaffected).

If a line begins with &#34;*- *&#34; (dash, space) or &#34;*+ *&#34; (plus, space),
then the type of rule is being explicitly specified as an exclude or
an include (respectively). Any rules without such a prefix are taken
to be an include.

If a line consists of just &#34;<strong>!</strong>&#34;, then the current filter rules are
cleared before adding any further rules.

If <em>FILE</em> is &#39;<strong>-</strong>&#39;, the list will be read from standard input.</dd>
<dt>
–files-from=FILE
</dt>
<dd>Using this option allows you to specify the exact
list of files to transfer (as read from the specified FILE or &#39;<strong>-</strong>&#39;
for standard input). It also tweaks the default behavior of rsync to
make transferring just the specified files and directories easier:</dd>
</dl>
<blockquote>
<ol>
<li value="15">The <strong>–relative</strong> (<strong>-R</strong>) option is implied, which preserves the
path information that is specified for each item in the file (use
<strong>–no-relative</strong> or <strong>–no-R</strong> if you want to turn that off).</li>
<li>The <strong>–dirs</strong> (<strong>-d</strong>) option is implied, which will create directories
specified in the list on the destination rather than noisily
skipping them (use <strong>–no-dirs</strong> or <strong>–no-d</strong> if you want to turn that
off).</li>
<li>The <strong>–archive</strong> (<strong>-a</strong>) option&#39;s behavior does not imply
<strong>–recursive</strong> (<strong>-r</strong>), so specify it explicitly, if you want it.</li>
<li>These side-effects change the default state of rsync, so the
position of the <strong>–files-from</strong> option on the command-line has no
bearing on how other options are parsed (e.g. <strong>-a</strong> works the same
before or after <strong>–files-from</strong>, as does <strong>–no-R</strong> and all other
options).</li>
</ol>
</blockquote>
<blockquote>
<p>The filenames that are read from the FILE are all relative to the source
dir – any leading slashes are removed and no &#34;..&#34; references are
allowed to go higher than the source dir. For example, take this
command:</p>
</blockquote>
<blockquote>
<pre class="example">
rsync -a --files-from=/tmp/foo /usr remote:/backup
</pre>
</blockquote>
<blockquote>
<p>If /tmp/foo contains the string &#34;bin&#34; (or even &#34;/bin&#34;), the /usr/bin
directory will be created as <em>backup/bin on the remote host. If it
contains &#34;bin</em>&#34; (note the trailing slash), the immediate contents of the
directory would also be sent (without needing to be explicitly mentioned
in the file – this began in version 2.6.4). In both cases, if the <strong>-r</strong>
option was enabled, that dir&#39;s entire hierarchy would also be
transferred (keep in mind that <strong>-r</strong> needs to be specified explicitly
with <strong>–files-from</strong>, since it is not implied by <strong>-a</strong>. Also note that the
effect of the (enabled by default) <strong>-r</strong> option is to duplicate only the
path info that is read from the file – it does not force the
duplication of the source-spec path (/usr in this case).</p>
</blockquote>
<blockquote>
<p>In addition, the <strong>–files-from</strong> file can be read from the remote host
instead of the local host if you specify a &#34;host:&#34; in front of the file
(the host must match one end of the transfer). As a short-cut, you can
specify just a prefix of &#34;:&#34; to mean &#34;use the remote end of the
transfer&#34;. For example:</p>
</blockquote>
<blockquote>
<pre class="example">
rsync -a --files-from=:/path/file-list src:/ /tmp/copy
</pre>
</blockquote>
<blockquote>
<p>This would copy all the files specified in the /path/file-list file that
was located on the remote &#34;src&#34; host.</p>
</blockquote>
<blockquote>
<p>If the <strong>–iconv</strong> and <strong>–secluded-args</strong> options are specified and the
<strong>–files-from</strong> filenames are being sent from one host to another, the
filenames will be translated from the sending host&#39;s charset to the
receiving host&#39;s charset.</p>
</blockquote>
<blockquote>
<p>NOTE: sorting the list of files in the <strong>–files-from</strong> input helps rsync
to be more efficient, as it will avoid re-visiting the path elements
that are shared between adjacent entries. If the input is not sorted,
some path elements (implied directories) may end up being scanned
multiple times, and rsync will eventually unduplicate them after they
get turned into file-list elements.</p>
</blockquote>
<dl>
<dt>
–from0, -0
</dt>
<dd>This tells rsync that the rules/filenames it reads from
a file are terminated by a null (&#39;\0&#39;) character, not a NL, CR, or
CR+LF. This affects <strong>–exclude-from</strong>, <strong>–include-from</strong>,
<strong>–files-from</strong>, and any merged files specified in a <strong>–filter</strong> rule.
It does not affect <strong>–cvs-exclude</strong> (since all names read from a
.cvsignore file are split on whitespace).</dd>
<dt>
–old-args
</dt>
<dd>This option tells rsync to stop trying to protect the
arg values on the remote side from unintended word-splitting or other
misinterpretation. It also allows the client to treat an empty arg as
a &#34;.&#34; instead of generating an error.

The default in a modern rsync is for &#34;shell-active&#34; characters
(including spaces) to be backslash-escaped in the args that are sent
to the remote shell. The wildcard characters <strong>*</strong>, <strong>?</strong>, <strong>[</strong>, &amp; <strong>]</strong> are
not escaped in filename args (allowing them to expand into multiple
filenames) while being protected in option args, such as <strong>–usermap</strong>.

If you have a script that wants to use old-style arg splitting in its
filenames, specify this option once. If the remote shell has a problem
with any backslash escapes at all, specify this option twice.

You may also control this setting via the <strong>RSYNC_OLD_ARGS</strong> environment
variable. If it has the value &#34;1&#34;, rsync will default to a
single-option setting. If it has the value &#34;2&#34; (or more), rsync will
default to a repeated-option setting. If it is &#34;0&#34;, you&#39;ll get the
default escaping behavior. The environment is always overridden by
manually specified positive or negative options (the negative is
<strong>–no-old-args</strong>).

Note that this option also disables the extra safety check added in
3.2.5 that ensures that a remote sender isn&#39;t including extra
top-level items in the file-list that you didn&#39;t request. This
side-effect is necessary because we can&#39;t know for sure what names to
expect when the remote shell is interpreting the args.

This option conflicts with the <strong>–secluded-args</strong> option.</dd>
<dt>
–secluded-args, -s
</dt>
<dd>This option sends all filenames and most
options to the remote rsync via the protocol (not the remote shell
command line) which avoids letting the remote shell modify them.
Wildcards are expanded on the remote host by rsync instead of a shell.

This is similar to the default backslash-escaping of args that was
added in 3.2.4 (see <strong>–old-args</strong>) in that it prevents things like
space splitting and unwanted special-character side-effects. However,
it has the drawbacks of being incompatible with older rsync versions
(prior to 3.0.0) and of being refused by restricted shells that want
to be able to inspect all the option values for safety.

This option is useful for those times that you need the argument&#39;s
character set to be converted for the remote host, if the remote shell
is incompatible with the default backslash-escpaing method, or there
is some other reason that you want the majority of the options and
arguments to bypass the command-line of the remote shell.

If you combine this option with <strong>–iconv</strong>, the args related to the
remote side will be translated from the local to the remote
character-set. The translation happens before wild-cards are expanded.
See also the <strong>–files-from</strong> option.

You may also control this setting via the <strong>RSYNC_PROTECT_ARGS</strong>
environment variable. If it has a non-zero value, this setting will be
enabled by default, otherwise it will be disabled by default. Either
state is overridden by a manually specified positive or negative
version of this option (note that <strong>–no-s</strong> and <strong>–no-secluded-args</strong>
are the negative versions). This environment variable is also
superseded by a non-zero <strong>RSYNC_OLD_ARGS</strong> export.

This option conflicts with the <strong>–old-args</strong> option.

This option used to be called <strong>–protect-args</strong> (before 3.2.6) and that
older name can still be used (though specifying it as <strong>-s</strong> is always
the easiest and most compatible choice).</dd>
<dt>
–trust-sender
</dt>
<dd>This option disables two extra validation checks
that a local client performs on the file list generated by a remote
sender. This option should only be used if you trust the sender to not
put something malicious in the file list (something that could
possibly be done via a modified rsync, a modified shell, or some other
similar manipulation).

Normally, the rsync client (as of version 3.2.5) runs two extra
validation checks when pulling files from a remote rsync:</dd>
</dl>
<blockquote>
<ol>
<li value="15">It verifies that additional arg items didn&#39;t get added at the
top of the transfer.</li>
<li>It verifies that none of the items in the file list are names that
should have been excluded (if filter rules were specified).</li>
</ol>
</blockquote>
<blockquote>
<p>Note that various options can turn off one or both of these checks if
the option interferes with the validation. For instance:</p>
</blockquote>
<blockquote>
<ol>
<li value="15">Using a per-directory filter file reads filter rules that only
the server knows about, so the filter checking is disabled.</li>
<li>Using the <strong>–old-args</strong> option allows the sender to manipulate the
requested args, so the arg checking is disabled.</li>
<li>Reading the files-from list from the server side means that the
client doesn&#39;t know the arg list, so the arg checking is disabled.</li>
<li>Using <strong>–read-batch</strong> disables both checks since the batch file&#39;s
contents will have been verified when it was created.</li>
</ol>
</blockquote>
<blockquote>
<p>This option may help an under-powered client server if the extra pattern
matching is slowing things down on a huge transfer. It can also be used
to work around a currently-unknown bug in the verification logic for a
transfer from a trusted sender.</p>
</blockquote>
<blockquote>
<p>When using this option it is a good idea to specify a dedicated
destination directory, as discussed in the MULTI-HOST SECURITY section.</p>
</blockquote>
<dl>
<dt>
–copy-as=USER[:GROUP]
</dt>
<dd>
<p>This option instructs rsync to use the USER
and (if specified after a colon) the GROUP for the copy operations.
This only works if the user that is running rsync has the ability to
change users. If the group is not specified then the user&#39;s default
groups are used.</p>
<p>
This option can help to reduce the risk of an rsync being run as root
into or out of a directory that might have live changes happening to
it and you want to make sure that root-level read or write actions of
system files are not possible. While you could alternatively run all
of rsync as the specified user, sometimes you need the root-level
host-access credentials to be used, so this allows rsync to drop root
for the copying part of the operation after the remote-shell or daemon
connection is established.</p>
<p>
The option only affects one side of the transfer unless the transfer
is local, in which case it affects both sides. Use the
<strong>–remote-option</strong> to affect the remote side, such as
<strong>-M–copy-as=joe</strong>. For a local transfer, the lsh (or lsh.sh) support
file provides a local-shell helper script that can be used to allow a
&#34;localhost:&#34; or &#34;lh:&#34; host-spec to be specified without needing to
setup any remote shells, allowing you to specify remote options that
affect the side of the transfer that is using the host-spec (and using
hostname &#34;lh&#34; avoids the overriding of the remote directory to the
user&#39;s home dir).</p>
<p>
For example, the following rsync writes the local files as user &#34;joe&#34;:</p>
<pre class="example">
sudo rsync -aiv --copy-as=joe host1:backups/joe/ /home/joe/
</pre>
<p>
This makes all files owned by user &#34;joe&#34;, limits the groups to those
that are available to that user, and makes it impossible for the joe
user to do a timed exploit of the path to induce a change to a file
that the joe user has no permissions to change.</p>
<p>
The following command does a local copy into the &#34;dest/&#34; dir as user
&#34;joe&#34; (assuming you&#39;ve installed support/lsh into a dir on your
$PATH):</p>
<pre class="example">
sudo rsync -aive lsh -M--copy-as=joe src/ lh:dest/
</pre>
</dd>
<dt>
–temp-dir=DIR, -T
</dt>
<dd>This option instructs rsync to use DIR as a
scratch directory when creating temporary copies of the files
transferred on the receiving side. The default behavior is to create
each temporary file in the same directory as the associated
destination file. Beginning with rsync 3.1.1, the temp-file names
inside the specified DIR will not be prefixed with an extra dot
(though they will still have a random suffix added).

This option is most often used when the receiving disk partition does
not have enough free space to hold a copy of the largest file in the
transfer. In this case (i.e. when the scratch directory is on a
different disk partition), rsync will not be able to rename each
received temporary file over the top of the associated destination
file, but instead must copy it into place. Rsync does this by copying
the file over the top of the destination file, which means that the
destination file will contain truncated data during this copy. If this
were not done this way (even if the destination file were first
removed, the data locally copied to a temporary file in the
destination directory, and then renamed into place) it would be
possible for the old file to continue taking up disk space (if someone
had it open), and thus there might not be enough room to fit the new
version on the disk at the same time.

If you are using this option for reasons other than a shortage of disk
space, you may wish to combine it with the <strong>–delay-updates</strong> option,
which will ensure that all copied files get put into subdirectories in
the destination hierarchy, awaiting the end of the transfer. If you
don&#39;t have enough room to duplicate all the arriving files on the
destination partition, another way to tell rsync that you aren&#39;t
overly concerned about disk space is to use the <strong>–partial-dir</strong> option
with a relative path; because this tells rsync that it is OK to stash
off a copy of a single file in a subdir in the destination hierarchy,
rsync will use the partial-dir as a staging area to bring over the
copied file, and then rename it into place from there. (Specifying a
<strong>–partial-dir</strong> with an absolute path does not have this side-effect.)</dd>
<dt>
–fuzzy, -y
</dt>
<dd>This option tells rsync that it should look for a basis
file for any destination file that is missing. The current algorithm
looks in the same directory as the destination file for either a file
that has an identical size and modified-time, or a similarly-named
file. If found, rsync uses the fuzzy basis file to try to speed up the
transfer.

If the option is repeated, the fuzzy scan will also be done in any
matching alternate destination directories that are specified via
<strong>–compare-dest</strong>, <strong>–copy-dest</strong>, or <strong>–link-dest</strong>.

Note that the use of the <strong>–delete</strong> option might get rid of any
potential fuzzy-match files, so either use <strong>–delete-after</strong> or specify
some filename exclusions if you need to prevent this.</dd>
<dt>
–compare-dest=DIR
</dt>
<dd>This option instructs rsync to use <em>DIR</em> on the
destination machine as an additional hierarchy to compare destination
files against doing transfers (if the files are missing in the
destination directory). If a file is found in <em>DIR</em> that is identical
to the sender&#39;s file, the file will NOT be transferred to the
destination directory. This is useful for creating a sparse backup of
just files that have changed from an earlier backup. This option is
typically used to copy into an empty (or newly created) directory.

Beginning in version 2.6.4, multiple <strong>–compare-dest</strong> directories may
be provided, which will cause rsync to search the list in the order
specified for an exact match. If a match is found that differs only in
attributes, a local copy is made and the attributes updated. If a
match is not found, a basis file from one of the <em>DIRs</em> will be
selected to try to speed up the transfer.

If <em>DIR</em> is a relative path, it is relative to the destination
directory. See also <strong>–copy-dest</strong> and <strong>–link-dest</strong>.

NOTE: beginning with version 3.1.0, rsync will remove a file from a
non-empty destination hierarchy if an exact match is found in one of
the compare-dest hierarchies (making the end result more closely match
a fresh copy).</dd>
<dt>
–copy-dest=DIR
</dt>
<dd>This option behaves like <strong>–compare-dest</strong>, but
rsync will also copy unchanged files found in <em>DIR</em> to the destination
directory using a local copy. This is useful for doing transfers to a
new destination while leaving existing files intact, and then doing a
flash-cutover when all files have been successfully transferred.

Multiple <strong>–copy-dest</strong> directories may be provided, which will cause
rsync to search the list in the order specified for an unchanged file.
If a match is not found, a basis file from one of the <em>DIRs</em> will be
selected to try to speed up the transfer.

If <em>DIR</em> is a relative path, it is relative to the destination
directory. See also <strong>–compare-dest</strong> and <strong>–link-dest</strong>.</dd>
<dt>
–link-dest=DIR
</dt>
<dd>
<p>This option behaves like <strong>–copy-dest</strong>, but
unchanged files are hard linked from <em>DIR</em> to the destination
directory. The files must be identical in all preserved attributes
(e.g. permissions, possibly ownership) in order for the files to be
linked together. An example:</p>
<pre class="example">
rsync -av --link-dest=$PWD/prior_dir host:src_dir/ new_dir/
</pre>
<p>
If files aren&#39;t linking, double-check their attributes. Also check if
some attributes are getting forced outside of rsync&#39;s control, such a
mount option that squishes root to a single user, or mounts a
removable drive with generic ownership (such as OS X&#39;s &#34;Ignore
ownership on this volume&#34; option).</p>
<p>
Beginning in version 2.6.4, multiple <strong>–link-dest</strong> directories may be
provided, which will cause rsync to search the list in the order
specified for an exact match (there is a limit of 20 such
directories). If a match is found that differs only in attributes, a
local copy is made and the attributes updated. If a match is not
found, a basis file from one of the <em>DIRs</em> will be selected to try to
speed up the transfer.</p>
<p>
This option works best when copying into an empty destination
hierarchy, as existing files may get their attributes tweaked, and
that can affect alternate destination files via hard-links. Also,
itemizing of changes can get a bit muddled. Note that prior to version
3.1.0, an alternate-directory exact match would never be found (nor
linked into the destination) when a destination file already exists.</p>
<p>
Note that if you combine this option with <strong>–ignore-times</strong>, rsync will
not link any files together because it only links identical files
together as a substitute for transferring the file, never as an
additional check after the file is updated.</p>
<p>
If <em>DIR</em> is a relative path, it is relative to the destination
directory. See also <strong>–compare-dest</strong> and <strong>–copy-dest</strong>.</p>
<p>
Note that rsync versions prior to 2.6.1 had a bug that could prevent
<strong>–link-dest</strong> from working properly for a non-super-user when
<strong>–owner</strong> (<strong>-o</strong>) was specified (or implied). You can work-around this
bug by avoiding the <strong>-o</strong> option (or using <strong>–no-o</strong>) when sending to an
old rsync.</p>
</dd>
<dt>
–compress, -z
</dt>
<dd>With this option, rsync compresses the file data as
it is sent to the destination machine, which reduces the amount of
data being transmitted – something that is useful over a slow
connection.

Rsync supports multiple compression methods and will choose one for
you unless you force the choice using the <strong>–compress-choice</strong> (<strong>–zc</strong>)
option.

Run <strong>rsync –version</strong> to see the default compress list compiled into
your version.

When both sides of the transfer are at least 3.2.0, rsync chooses the
first algorithm in the client&#39;s list of choices that is also in the
server&#39;s list of choices. If no common compress choice is found, rsync
exits with an error. If the remote rsync is too old to support
checksum negotiation, its list is assumed to be &#34;zlib&#34;.

The default order can be customized by setting the environment
variable <strong>RSYNC_COMPRESS_LIST</strong> to a space-separated list of acceptable
compression names. If the string contains a &#34;<strong>&amp;</strong>&#34; character, it is
separated into the &#34;client string &amp; server string&#34;, otherwise the same
string applies to both. If the string (or string portion) contains no
non-whitespace characters, the default compress list is used. Any
unknown compression names are discarded from the list, but a list with
only invalid names results in a failed negotiation.

There are some older rsync versions that were configured to reject a
<strong>-z</strong> option and require the use of <strong>-zz</strong> because their compression
library was not compatible with the default zlib compression method.
You can usually ignore this weirdness unless the rsync server
complains and tells you to specify <strong>-zz</strong>.</dd>
<dt>
–compress-choice=STR, –zc=STR
</dt>
<dd>This option can be used to override
the automatic negotiation of the compression algorithm that occurs
when <strong>–compress</strong> is used. The option implies <strong>–compress</strong> unless
&#34;none&#34; was specified, which instead implies <strong>–no-compress</strong>.

The compression options that you may be able to use are:</dd>
</dl>
<blockquote>
<ol>
<li value="15"><strong>zstd</strong></li>
<li><strong>lz4</strong></li>
<li><strong>zlibx</strong></li>
<li><strong>zlib</strong></li>
<li><strong>none</strong></li>
</ol>
</blockquote>
<blockquote>
<p>Run <strong>rsync –version</strong> to see the default compress list compiled into
your version (which may differ from the list above).</p>
</blockquote>
<blockquote>
<p>Note that if you see an error about an option named <strong>–old-compress</strong> or
<strong>–new-compress</strong>, this is rsync trying to send the
<strong>–compress-choice=zlib</strong> or <strong>–compress-choice=zlibx</strong> option in a
backward-compatible manner that more rsync versions understand. This
error indicates that the older rsync version on the server will not
allow you to force the compression type.</p>
</blockquote>
<blockquote>
<p>Note that the &#34;zlibx&#34; compression algorithm is just the &#34;zlib&#34; algorithm
with matched data excluded from the compression stream (to try to make
it more compatible with an external zlib implementation).</p>
</blockquote>
<dl>
<dt>
–compress-level=NUM, –zl=NUM
</dt>
<dd>
<p>Explicitly set the compression level
to use (see <strong>–compress</strong>, <strong>-z</strong>) instead of letting it default. The
<strong>–compress</strong> option is implied as long as the level chosen is not a
&#34;don&#39;t compress&#34; level for the compression algorithm that is in effect
(e.g. zlib compression treats level 0 as &#34;off&#34;).</p>
<p>
The level values vary depending on the checksum in effect. Because
rsync will negotiate a checksum choice by default (when the remote
rsync is new enough), it can be good to combine this option with a
<strong>–compress-choice</strong> (<strong>–zc</strong>) option unless you&#39;re sure of the choice
in effect. For example:</p>
<pre class="example">
rsync -aiv --zc=zstd --zl=22 host:src/ dest/
</pre>
<p>
For zlib &amp; zlibx compression the valid values are from 1 to 9 with 6
being the default. Specifying <strong>–zl=0</strong> turns compression off, and
specifying <strong>–zl=-1</strong> chooses the default level of 6.</p>
<p>
For zstd compression the valid values are from -131072 to 22 with 3
being the default. Specifying 0 chooses the default of 3.</p>
<p>
For lz4 compression there are no levels, so the value is always 0.</p>
<p>
If you specify a too-large or too-small value, the number is silently
limited to a valid value. This allows you to specify something like
<strong>–zl=999999999</strong> and be assured that you&#39;ll end up with the maximum
compression level no matter what algorithm was chosen.</p>
<p>
If you want to know the compression level that is in effect, specify
<strong>–debug=nstr</strong> to see the &#34;negotiated string&#34; results. This will
report something like &#34;<strong>Client compress: zstd (level 3)</strong>&#34; (along with
the checksum choice in effect).</p>
</dd>
<dt>
–skip-compress=LIST
</dt>
<dd>
<p><strong>NOTE:</strong> no compression method currently
supports per-file compression changes, so this option has no effect.</p>
<p>
Override the list of file suffixes that will be compressed as little
as possible. Rsync sets the compression level on a per-file basis
based on the file&#39;s suffix. If the compression algorithm has an &#34;off&#34;
level, then no compression occurs for those files. Other algorithms
that support changing the streaming level on-the-fly will have the
level minimized to reduces the CPU usage as much as possible for a
matching file.</p>
<p>
The <strong>LIST</strong> should be one or more file suffixes (without the dot)
separated by slashes (<strong>/</strong>). You may specify an empty string to
indicate that no files should be skipped.</p>
<p>
Simple character-class matching is supported: each must consist of a
list of letters inside the square brackets (e.g. no special classes,
such as &#34;[:alpha:]&#34;, are supported, and &#39;-&#39; has no special meaning).</p>
<p>
The characters asterisk (<strong>*</strong>) and question-mark (<strong>?</strong>) have no special
meaning.</p>
<p>
Here&#39;s an example that specifies 6 suffixes to skip (since 1 of the 5
rules matches 2 suffixes):</p>
<pre class="example">
--skip-compress=gz/jpg/mp[34]/7z/bz2
</pre>
<p>
The default file suffixes in the skip-compress list in this version of
rsync are:</p>
<blockquote>
<p>3g2 3gp 7z aac ace apk avi bz2 deb dmg ear f4v flac flv gpg gz iso jar
jpeg jpg lrz lz lz4 lzma lzo m1a m1v m2a m2ts m2v m4a m4b m4p m4r m4v
mka mkv mov mp1 mp2 mp3 mp4 mpa mpeg mpg mpv mts odb odf odg odi odm
odp ods odt oga ogg ogm ogv ogx opus otg oth otp ots ott oxt png qt
rar rpm rz rzip spx squashfs sxc sxd sxg sxm sxw sz tbz tbz2 tgz tlz
ts txz tzo vob war webm webp xz z zip zst</p>
</blockquote>
<p>
This list will be replaced by your <strong>–skip-compress</strong> list in all but
one situation: a copy from a daemon rsync will add your skipped
suffixes to its list of non-compressing files (and its list may be
configured to a different default).</p>
</dd>
<dt>
–numeric-ids
</dt>
<dd>With this option rsync will transfer numeric group
and user IDs rather than using user and group names and mapping them
at both ends.

By default rsync will use the username and groupname to determine what
ownership to give files. The special uid 0 and the special group 0 are
never mapped via user/group names even if the <strong>–numeric-ids</strong> option
is not specified.

If a user or group has no name on the source system or it has no match
on the destination system, then the numeric ID from the source system
is used instead. See also the <strong>use chroot</strong> setting in the rsyncd.conf
manpage for some comments on how the chroot setting affects rsync&#39;s
ability to look up the names of the users and groups and what you can
do about it.</dd>
<dt>
–usermap=STRING, –groupmap=STRING
</dt>
<dd>
<p>These options allow you to
specify users and groups that should be mapped to other values by the
receiving side. The <strong>STRING</strong> is one or more <strong>FROM</strong>:*TO* pairs of
values separated by commas. Any matching <strong>FROM</strong> value from the sender
is replaced with a <strong>TO</strong> value from the receiver. You may specify
usernames or user IDs for the <strong>FROM</strong> and <strong>TO</strong> values, and the <strong>FROM</strong>
value may also be a wild-card string, which will be matched against
the sender&#39;s names (wild-cards do NOT match against ID numbers, though
see below for why a &#39;<strong>*</strong>&#39; matches everything). You may instead specify
a range of ID numbers via an inclusive range: LOW-HIGH. For example:</p>
<pre class="example">
--usermap=0-99:nobody,wayne:admin,*:normal --groupmap=usr:1,1:usr
</pre>
<p>
The first match in the list is the one that is used. You should
specify all your user mappings using a single <strong>–usermap</strong> option,
and/or all your group mappings using a single <strong>–groupmap</strong> option.</p>
<p>
Note that the sender&#39;s name for the 0 user and group are not
transmitted to the receiver, so you should either match these values
using a 0, or use the names in effect on the receiving side (typically
&#34;root&#34;). All other <strong>FROM</strong> names match those in use on the sending
side. All <strong>TO</strong> names match those in use on the receiving side.</p>
<p>
Any IDs that do not have a name on the sending side are treated as
having an empty name for the purpose of matching. This allows them to
be matched via a &#34;<strong>*</strong>&#34; or using an empty name. For instance:</p>
<pre class="example">
--usermap=:nobody --groupmap=*:nobody
</pre>
<p>
When the <strong>–numeric-ids</strong> option is used, the sender does not send any
names, so all the IDs are treated as having an empty name. This means
that you will need to specify numeric <strong>FROM</strong> values if you want to map
these nameless IDs to different values.</p>
<p>
For the <strong>–usermap</strong> option to work, the receiver will need to be
running as a super-user (see also the <strong>–super</strong> and <strong>–fake-super</strong>
options). For the <strong>–groupmap</strong> option to work, the receiver will need
to have permissions to set that group.</p>
<p>
Starting with rsync 3.2.4, the <strong>–usermap</strong> option implies the
<strong>–owner</strong> (<strong>-o</strong>) option while the <strong>–groupmap</strong> option implies the
<strong>–group</strong> (<strong>-g</strong>) option (since rsync needs to have those options
enabled for the mapping options to work).</p>
<p>
An older rsync client may need to use <strong>-s</strong> to avoid a complaint about
wildcard characters, but a modern rsync handles this automatically.</p>
</dd>
<dt>
–chown=USER:GROUP
</dt>
<dd>This option forces all files to be owned by USER
with group GROUP. This is a simpler interface than using <strong>–usermap</strong> &amp;
<strong>–groupmap</strong> directly, but it is implemented using those options
internally so they cannot be mixed. If either the USER or GROUP is
empty, no mapping for the omitted user/group will occur. If GROUP is
empty, the trailing colon may be omitted, but if USER is empty, a
leading colon must be supplied.

If you specify &#34;<strong>–chown=foo:bar</strong>&#34;, this is exactly the same as
specifying &#34;<strong>–usermap=</strong>:foo –groupmap=*:bar*&#34;, only easier (and with
the same implied <strong>–owner</strong> and/or <strong>–group</strong> options).

An older rsync client may need to use <strong>-s</strong> to avoid a complaint about
wildcard characters, but a modern rsync handles this automatically.</dd>
<dt>
–timeout=SECONDS
</dt>
<dd>This option allows you to set a maximum I/O
timeout in seconds. If no data is transferred for the specified time
then rsync will exit. The default is 0, which means no timeout.</dd>
<dt>
–contimeout=SECONDS
</dt>
<dd>This option allows you to set the amount of
time that rsync will wait for its connection to an rsync daemon to
succeed. If the timeout is reached, rsync exits with an error.</dd>
<dt>
–address=ADDRESS
</dt>
<dd>By default rsync will bind to the wildcard
address when connecting to an rsync daemon. The <strong>–address</strong> option
allows you to specify a specific IP address (or hostname) to bind to.

See also the daemon version of the <strong>–address</strong> option.</dd>
<dt>
–port=PORT
</dt>
<dd>This specifies an alternate TCP port number to use
rather than the default of 873. This is only needed if you are using
the double-colon (::) syntax to connect with an rsync daemon (since
the URL syntax has a way to specify the port as a part of the URL).

See also the daemon version of the <strong>–port</strong> option.</dd>
<dt>
–sockopts=OPTIONS
</dt>
<dd>This option can provide endless fun for people
who like to tune their systems to the utmost degree. You can set all
sorts of socket options which may make transfers faster (or slower!).
Read the manpage for the <strong>setsockopt()</strong> system call for details on
some of the options you may be able to set. By default no special
socket options are set. This only affects direct socket connections to
a remote rsync daemon.

See also the daemon version of the <strong>–sockopts</strong> option.</dd>
<dt>
–blocking-io
</dt>
<dd>This tells rsync to use blocking I/O when launching a
remote shell transport. If the remote shell is either rsh or remsh,
rsync defaults to using blocking I/O, otherwise it defaults to using
non-blocking I/O. (Note that ssh prefers non-blocking I/O.)</dd>
<dt>
–outbuf=MODE
</dt>
<dd>This sets the output buffering mode. The mode can be
None (aka Unbuffered), Line, or Block (aka Full). You may specify as
little as a single letter for the mode, and use upper or lower case.

The main use of this option is to change Full buffering to Line
buffering when rsync&#39;s output is going to a file or pipe.</dd>
<dt>
–itemize-changes, -i
</dt>
<dd>Requests a simple itemized list of the
changes that are being made to each file, including attribute changes.
This is exactly the same as specifying <strong>–out-format=&#39;%i %n%L&#39;</strong>. If
you repeat the option, unchanged files will also be output, but only
if the receiving rsync is at least version 2.6.7 (you can use <strong>-vv</strong>
with older versions of rsync, but that also turns on the output of
other verbose messages).

The &#34;%i&#34; escape has a cryptic output that is 11 letters long. The
general format is like the string <strong>YXcstpoguax</strong>, where <strong>Y</strong> is replaced
by the type of update being done, <strong>X</strong> is replaced by the file-type,
and the other letters represent attributes that may be output if they
are being modified.

The update types that replace the <strong>Y</strong> are as follows:</dd>
</dl>
<blockquote>
<ol>
<li value="15">A <strong>&lt;</strong> means that a file is being transferred to the remote
host (sent).</li>
<li>A <strong>&gt;</strong> means that a file is being transferred to the local host
(received).</li>
<li>A <strong>c</strong> means that a local change/creation is occurring for the item
(such as the creation of a directory or the changing of a symlink,
etc.).</li>
<li>A <strong>h</strong> means that the item is a hard link to another item (requires
<strong>–hard-links</strong>).</li>
<li>A <strong>.</strong> means that the item is not being updated (though it might have
attributes that are being modified).</li>
<li>A <strong>*</strong> means that the rest of the itemized-output area contains a
message (e.g. &#34;deleting&#34;).</li>
</ol>
</blockquote>
<blockquote>
<p>The file-types that replace the <strong>X</strong> are: <strong>f</strong> for a file, a <strong>d</strong> for a
directory, an <strong>L</strong> for a symlink, a <strong>D</strong> for a device, and a <strong>S</strong> for a
special file (e.g. named sockets and fifos).</p>
</blockquote>
<blockquote>
<p>The other letters in the string indicate if some attributes of the file
have changed, as follows:</p>
</blockquote>
<blockquote>
<ol>
<li value="15">&#34;<strong>.</strong>&#34; - the attribute is unchanged.</li>
<li>&#34;<strong>+</strong>&#34; - the file is newly created.</li>
<li>&#34;* *&#34; - all the attributes are unchanged (all dots turn to spaces).</li>
<li>&#34;<strong>?</strong>&#34; - the change is unknown (when the remote rsync is old).</li>
<li>A letter indicates an attribute is being updated.</li>
</ol>
</blockquote>
<blockquote>
<p>The attribute that is associated with each letter is as follows:</p>
</blockquote>
<blockquote>
<ol>
<li value="15">A <strong>c</strong> means either that a regular file has a different
checksum (requires <strong>–checksum</strong>) or that a symlink, device, or
special file has a changed value. Note that if you are sending files
to an rsync prior to 3.0.1, this change flag will be present only
for checksum-differing regular files.</li>
<li>A <strong>s</strong> means the size of a regular file is different and will be
updated by the file transfer.</li>
<li>A <strong>t</strong> means the modification time is different and is being updated
to the sender&#39;s value (requires <strong>–times</strong>). An alternate value of
<strong>T</strong> means that the modification time will be set to the transfer
time, which happens when a file/symlink/device is updated without
<strong>–times</strong> and when a symlink is changed and the receiver can&#39;t set
its time. (Note: when using an rsync 3.0.0 client, you might see the
<strong>s</strong> flag combined with <strong>t</strong> instead of the proper <strong>T</strong> flag for this
time-setting failure.)</li>
<li>A <strong>p</strong> means the permissions are different and are being updated to
the sender&#39;s value (requires <strong>–perms</strong>).</li>
<li>An <strong>o</strong> means the owner is different and is being updated to the
sender&#39;s value (requires <strong>–owner</strong> and super-user privileges).</li>
<li>A <strong>g</strong> means the group is different and is being updated to the
sender&#39;s value (requires <strong>–group</strong> and the authority to set the
group).</li>
<li></li>
</ol>
<blockquote>
<ol>
<li value="15">A <strong>u*|*n*|*b</strong> indicates the following information:</li>
</ol>
<p><strong>u</strong> means the access (use) time is different and is being updated to the
sender&#39;s value (requires <strong>–atimes</strong>)</p>
<ol>
<li value="15"><strong>n</strong> means the create time (newness) is different and is being
updated to the sender&#39;s value (requires <strong>–crtimes</strong>)</li>
<li><strong>b</strong> means that both the access and create times are being updated</li>
</ol>
</blockquote>
<ol>
<li value="15">The <strong>a</strong> means that the ACL information is being changed.</li>
<li>The <strong>x</strong> means that the extended attribute information is being
changed.</li>
</ol>
</blockquote>
<blockquote>
<p>One other output is possible: when deleting files, the &#34;%i&#34; will output
the string &#34;<strong>*deleting</strong>&#34; for each item that is being removed (assuming
that you are talking to a recent enough rsync that it logs deletions
instead of outputting them as a verbose message).</p>
</blockquote>
<dl>
<dt>
–out-format=FORMAT
</dt>
<dd>This allows you to specify exactly what the
rsync client outputs to the user on a per-update basis. The format is
a text string containing embedded single-character escape sequences
prefixed with a percent (%) character. A default format of &#34;%n%L&#34; is
assumed if either <strong>–info=name</strong> or <strong>-v</strong> is specified (this tells you
just the name of the file and, if the item is a link, where it
points). For a full list of the possible escape characters, see the
<strong>log format</strong> setting in the rsyncd.conf manpage.

Specifying the <strong>–out-format</strong> option implies the <strong>–info=name</strong> option,
which will mention each file, dir, etc. that gets updated in a
significant way (a transferred file, a recreated symlink/device, or a
touched directory). In addition, if the itemize-changes escape (%i) is
included in the string (e.g. if the <strong>–itemize-changes</strong> option was
used), the logging of names increases to mention any item that is
changed in any way (as long as the receiving side is at least 2.6.4).
See the <strong>–itemize-changes</strong> option for a description of the output of
&#34;%i&#34;.

Rsync will output the out-format string prior to a file&#39;s transfer
unless one of the transfer-statistic escapes is requested, in which
case the logging is done at the end of the file&#39;s transfer. When this
late logging is in effect and <strong>–progress</strong> is also specified, rsync
will also output the name of the file being transferred prior to its
progress information (followed, of course, by the out-format output).</dd>
<dt>
–log-file=FILE
</dt>
<dd>
<p>This option causes rsync to log what it is doing to
a file. This is similar to the logging that a daemon does, but can be
requested for the client side and/or the server side of a non-daemon
transfer. If specified as a client option, transfer logging will be
enabled with a default format of &#34;%i %n%L&#34;. See the
<strong>–log-file-format</strong> option if you wish to override this.</p>
<p>
Here&#39;s an example command that requests the remote side to log what is
happening:</p>
<pre class="example">
rsync -av --remote-option=--log-file=/tmp/rlog src/ dest/
</pre>
<p>
This is very useful if you need to debug why a connection is closing
unexpectedly.</p>
<p>
See also the daemon version of the <strong>–log-file</strong> option.</p>
</dd>
<dt>
–log-file-format=FORMAT
</dt>
<dd>This allows you to specify exactly what
per-update logging is put into the file specified by the <strong>–log-file</strong>
option (which must also be specified for this option to have any
effect). If you specify an empty string, updated files will not be
mentioned in the log file. For a list of the possible escape
characters, see the <strong>log format</strong> setting in the rsyncd.conf manpage.

The default FORMAT used if <strong>–log-file</strong> is specified and this option
is not is &#39;%i %n%L&#39;.

See also the daemon version of the <strong>–log-file-format</strong> option.</dd>
<dt>
–stats
</dt>
<dd>This tells rsync to print a verbose set of statistics on
the file transfer, allowing you to tell how effective rsync&#39;s
delta-transfer algorithm is for your data. This option is equivalent
to <strong>–info=stats2</strong> if combined with 0 or 1 <strong>-v</strong> options, or
<strong>–info=stats3</strong> if combined with 2 or more <strong>-v</strong> options.

The current statistics are as follows:</dd>
</dl>
<blockquote>
<ol>
<li value="15"><strong>Number of files</strong> is the count of all &#34;files&#34; (in the generic
sense), which includes directories, symlinks, etc. The total count
will be followed by a list of counts by filetype (if the total is
non-zero). For example: &#34;(reg: 5, dir: 3, link: 2, dev: 1, special:
1)&#34; lists the totals for regular files, directories, symlinks,
devices, and special files. If any of value is 0, it is completely
omitted from the list.</li>
<li><strong>Number of created files</strong> is the count of how many &#34;files&#34; (generic
sense) were created (as opposed to updated). The total count will be
followed by a list of counts by filetype (if the total is non-zero).</li>
<li><strong>Number of deleted files</strong> is the count of how many &#34;files&#34; (generic
sense) were deleted. The total count will be followed by a list of
counts by filetype (if the total is non-zero). Note that this line
is only output if deletions are in effect, and only if protocol 31
is being used (the default for rsync 3.1.x).</li>
<li><strong>Number of regular files transferred</strong> is the count of normal files
that were updated via rsync&#39;s delta-transfer algorithm, which does
not include dirs, symlinks, etc. Note that rsync 3.1.0 added the
word &#34;regular&#34; into this heading.</li>
<li><strong>Total file size</strong> is the total sum of all file sizes in the
transfer. This does not count any size for directories or special
files, but does include the size of symlinks.</li>
<li><strong>Total transferred file size</strong> is the total sum of all files sizes
for just the transferred files.</li>
<li><strong>Literal data</strong> is how much unmatched file-update data we had to send
to the receiver for it to recreate the updated files.</li>
<li><strong>Matched data</strong> is how much data the receiver got locally when
recreating the updated files.</li>
<li><strong>File list size</strong> is how big the file-list data was when the sender
sent it to the receiver. This is smaller than the in-memory size for
the file list due to some compressing of duplicated data when rsync
sends the list.</li>
<li><strong>File list generation time</strong> is the number of seconds that the sender
spent creating the file list. This requires a modern rsync on the
sending side for this to be present.</li>
<li><strong>File list transfer time</strong> is the number of seconds that the sender
spent sending the file list to the receiver.</li>
<li><strong>Total bytes sent</strong> is the count of all the bytes that rsync sent
from the client side to the server side.</li>
<li><strong>Total bytes received</strong> is the count of all non-message bytes that
rsync received by the client side from the server side.
&#34;Non-message&#34; bytes means that we don&#39;t count the bytes for a
verbose message that the server sent to us, which makes the stats
more consistent.</li>
</ol>
</blockquote>
<dl>
<dt>
–8-bit-output, -8
</dt>
<dd>This tells rsync to leave all high-bit
characters unescaped in the output instead of trying to test them to
see if they&#39;re valid in the current locale and escaping the invalid
ones. All control characters (but never tabs) are always escaped,
regardless of this option&#39;s setting.

The escape idiom that started in 2.6.7 is to output a literal
backslash (<strong>\</strong>) and a hash (<strong>#</strong>), followed by exactly 3 octal digits.
For example, a newline would output as &#34;<strong>\#012</strong>&#34;. A literal backslash
that is in a filename is not escaped unless it is followed by a hash
and 3 digits (0-9).</dd>
<dt>
–human-readable, -h
</dt>
<dd>
<p>Output numbers in a more human-readable
format. There are 3 possible levels:</p>
<ol>
<li>output numbers with a separator between each set of 3 digits
(either a comma or a period, depending on if the decimal point is
represented by a period or a comma).</li>
<li>output numbers in units of 1000 (with a character suffix for larger
units – see below).</li>
<li>output numbers in units of 1024.</li>
</ol>
<p>The default is human-readable level 1. Each <strong>-h</strong> option increases the
level by one. You can take the level down to 0 (to output numbers as
pure digits) by specifying the <strong>–no-human-readable</strong> (<strong>–no-h</strong>)
option.</p>
<p>
The unit letters that are appended in levels 2 and 3 are: <strong>K</strong> (kilo),
<strong>M</strong> (mega), <strong>G</strong> (giga), <strong>T</strong> (tera), or <strong>P</strong> (peta). For example, a
1234567-byte file would output as 1.23M in level-2 (assuming that a
period is your local decimal point).</p>
<p>
Backward compatibility note: versions of rsync prior to 3.1.0 do not
support human-readable level 1, and they default to level 0. Thus,
specifying one or two <strong>-h</strong> options will behave in a comparable manner
in old and new versions as long as you didn&#39;t specify a <strong>–no-h</strong>
option prior to one or more <strong>-h</strong> options. See the <strong>–list-only</strong> option
for one difference.</p>
</dd>
<dt>
–partial
</dt>
<dd>By default, rsync will delete any partially transferred
file if the transfer is interrupted. In some circumstances it is more
desirable to keep partially transferred files. Using the <strong>–partial</strong>
option tells rsync to keep the partial file which should make a
subsequent transfer of the rest of the file much faster.</dd>
<dt>
–partial-dir=DIR
</dt>
<dd>
<p>This option modifies the behavior of the
<strong>–partial</strong> option while also implying that it be enabled. This
enhanced partial-file method puts any partially transferred files into
the specified <em>DIR</em> instead of writing the partial file out to the
destination file. On the next transfer, rsync will use a file found in
this dir as data to speed up the resumption of the transfer and then
delete it after it has served its purpose.</p>
<p>
Note that if <strong>–whole-file</strong> is specified (or implied), any partial-dir
files that are found for a file that is being updated will simply be
removed (since rsync is sending files without using rsync&#39;s
delta-transfer algorithm).</p>
<p>
Rsync will create the <em>DIR</em> if it is missing, but just the last dir –
not the whole path. This makes it easy to use a relative path (such as
&#34;<strong>–partial-dir=.rsync-partial</strong>&#34;) to have rsync create the
partial-directory in the destination file&#39;s directory when it is
needed, and then remove it again when the partial file is deleted.
Note that this directory removal is only done for a relative pathname,
as it is expected that an absolute path is to a directory that is
reserved for partial-dir work.</p>
<p>
If the partial-dir value is not an absolute path, rsync will add an
exclude rule at the end of all your existing excludes. This will
prevent the sending of any partial-dir files that may exist on the
sending side, and will also prevent the untimely deletion of
partial-dir items on the receiving side. An example: the above
<strong>–partial-dir</strong> option would add the equivalent of this &#34;perishable&#34;
exclude at the end of any other filter rules: <strong>-f &#39;-p
.rsync-partial/&#39;</strong></p>
<p>
If you are supplying your own exclude rules, you may need to add your
own exclude/hide/protect rule for the partial-dir because:</p>
<ol>
<li>the auto-added rule may be ineffective at the end of your other
rules, or</li>
<li>you may wish to override rsync&#39;s exclude choice.</li>
</ol>
<p>For instance, if you want to make rsync clean-up any left-over
partial-dirs that may be lying around, you should specify
<strong>–delete-after</strong> and add a &#34;risk&#34; filter rule, e.g. <strong>-f &#39;R
.rsync-partial/&#39;</strong>. Avoid using <strong>–delete-before</strong> or <strong>–delete-during</strong>
unless you don&#39;t need rsync to use any of the left-over partial-dir
data during the current run.</p>
<p>
IMPORTANT: the <strong>–partial-dir</strong> should not be writable by other users
or it is a security risk! E.g. AVOID &#34;/tmp&#34;!</p>
<p>
You can also set the partial-dir value the <strong>RSYNC_PARTIAL_DIR</strong>
environment variable. Setting this in the environment does not force
<strong>–partial</strong> to be enabled, but rather it affects where partial files
go when <strong>–partial</strong> is specified. For instance, instead of using
<strong>–partial-dir=.rsync-tmp</strong> along with <strong>–progress</strong>, you could set
<strong>RSYNC_PARTIAL_DIR=.rsync-tmp</strong> in your environment and then use the
<strong>-P</strong> option to turn on the use of the .rsync-tmp dir for partial
transfers. The only times that the <strong>–partial</strong> option does not look
for this environment value are:</p>
<ol>
<li>when <strong>–inplace</strong> was specified (since <strong>–inplace</strong> conflicts with
<strong>–partial-dir</strong>), and</li>
<li>when <strong>–delay-updates</strong> was specified (see below).</li>
</ol>
<p>When a modern rsync resumes the transfer of a file in the partial-dir,
that partial file is now updated in-place instead of creating yet
another tmp-file copy (so it maxes out at dest + tmp instead of dest +
partial + tmp). This requires both ends of the transfer to be at least
version 3.2.0.</p>
<p>
For the purposes of the daemon-config&#39;s &#34;<strong>refuse options</strong>&#34; setting,
<strong>–partial-dir</strong> does <em>not</em> imply <strong>–partial</strong>. This is so that a
refusal of the <strong>–partial</strong> option can be used to disallow the
overwriting of destination files with a partial transfer, while still
allowing the safer idiom provided by <strong>–partial-dir</strong>.</p>
</dd>
<dt>
–delay-updates
</dt>
<dd>
<p>This option puts the temporary file from each
updated file into a holding directory until the end of the transfer,
at which time all the files are renamed into place in rapid
succession. This attempts to make the updating of the files a little
more atomic. By default the files are placed into a directory named
<strong>.~tmp~</strong> in each file&#39;s destination directory, but if you&#39;ve specified
the <strong>–partial-dir</strong> option, that directory will be used instead. See
the comments in the <strong>–partial-dir</strong> section for a discussion of how
this <strong>.~tmp~</strong> dir will be excluded from the transfer, and what you can
do if you want rsync to cleanup old <strong>.~tmp~</strong> dirs that might be lying
around. Conflicts with <strong>–inplace</strong> and <strong>–append</strong>.</p>
<p>
This option implies <strong>–no-inc-recursive</strong> since it needs the full file
list in memory in order to be able to iterate over it at the end.</p>
<p>
This option uses more memory on the receiving side (one bit per file
transferred) and also requires enough free disk space on the receiving
side to hold an additional copy of all the updated files. Note also
that you should not use an absolute path to <strong>–partial-dir</strong> unless:</p>
<ol>
<li>there is no chance of any of the files in the transfer having the
same name (since all the updated files will be put into a single
directory if the path is absolute), and</li>
<li>there are no mount points in the hierarchy (since the delayed
updates will fail if they can&#39;t be renamed into place).</li>
</ol>
<p>See also the &#34;atomic-rsync&#34; python script in the &#34;support&#34; subdir for
an update algorithm that is even more atomic (it uses <strong>–link-dest</strong>
and a parallel hierarchy of files).</p>
</dd>
<dt>
–prune-empty-dirs, -m
</dt>
<dd>
<p>This option tells the receiving rsync to get
rid of empty directories from the file-list, including nested
directories that have no non-directory children. This is useful for
avoiding the creation of a bunch of useless directories when the
sending rsync is recursively scanning a hierarchy of files using
include/exclude/filter rules.</p>
<p>
This option can still leave empty directories on the receiving side if
you make use of TRANSFER_RULES.</p>
<p>
Because the file-list is actually being pruned, this option also
affects what directories get deleted when a delete is active. However,
keep in mind that excluded files and directories can prevent existing
items from being deleted due to an exclude both hiding source files
and protecting destination files. See the perishable filter-rule
option for how to avoid this.</p>
<p>
You can prevent the pruning of certain empty directories from the
file-list by using a global &#34;protect&#34; filter. For instance, this
option would ensure that the directory &#34;emptydir&#34; was kept in the
file-list:</p>
<pre class="example">
--filter &#39;protect emptydir/&#39;
</pre>
<p>
Here&#39;s an example that copies all .pdf files in a hierarchy, only
creating the necessary destination directories to hold the .pdf files,
and ensures that any superfluous files and directories in the
destination are removed (note the hide filter of non-directories being
used instead of an exclude):</p>
<pre class="example">
rsync -avm --del --include=&#39;*.pdf&#39; -f &#39;hide,! */&#39; src/ dest
</pre>
<p>
If you didn&#39;t want to remove superfluous destination files, the more
time-honored options of <strong>–include=&#39;*/&#39; –exclude=&#39;</strong>&#39;* would work fine
in place of the hide-filter (if that is more natural to you).</p>
</dd>
<dt>
–progress
</dt>
<dd>
<p>This option tells rsync to print information showing the
progress of the transfer. This gives a bored user something to watch.
With a modern rsync this is the same as specifying
<strong>–info=flist2,name,progress</strong>, but any user-supplied settings for
those info flags takes precedence (e.g. <strong>–info=flist0 –progress</strong>).</p>
<p>
While rsync is transferring a regular file, it updates a progress line
that looks like this:</p>
<pre class="example">
782448  63%  110.64kB/s    0:00:04
</pre>
<p>
In this example, the receiver has reconstructed 782448 bytes or 63% of
the sender&#39;s file, which is being reconstructed at a rate of 110.64
kilobytes per second, and the transfer will finish in 4 seconds if the
current rate is maintained until the end.</p>
<p>
These statistics can be misleading if rsync&#39;s delta-transfer algorithm
is in use. For example, if the sender&#39;s file consists of the basis
file followed by additional data, the reported rate will probably drop
dramatically when the receiver gets to the literal data, and the
transfer will probably take much longer to finish than the receiver
estimated as it was finishing the matched part of the file.</p>
<p>
When the file transfer finishes, rsync replaces the progress line with
a summary line that looks like this:</p>
<pre class="example">
1,238,099 100%  146.38kB/s    0:00:08  (xfr#5, to-chk=169/396)
</pre>
<p>
In this example, the file was 1,238,099 bytes long in total, the
average rate of transfer for the whole file was 146.38 kilobytes per
second over the 8 seconds that it took to complete, it was the 5th
transfer of a regular file during the current rsync session, and there
are 169 more files for the receiver to check (to see if they are
up-to-date or not) remaining out of the 396 total files in the
file-list.</p>
<p>
In an incremental recursion scan, rsync won&#39;t know the total number of
files in the file-list until it reaches the ends of the scan, but
since it starts to transfer files during the scan, it will display a
line with the text &#34;ir-chk&#34; (for incremental recursion check) instead
of &#34;to-chk&#34; until the point that it knows the full size of the list,
at which point it will switch to using &#34;to-chk&#34;. Thus, seeing &#34;ir-chk&#34;
lets you know that the total count of files in the file list is still
going to increase (and each time it does, the count of files left to
check will increase by the number of the files added to the list).</p>
</dd>
<dt>
-P
</dt>
<dd>The <strong>-P</strong> option is equivalent to &#34;<strong>–partial</strong> <strong>–progress</strong>&#34;. Its
purpose is to make it much easier to specify these two options for a
long transfer that may be interrupted.

There is also a <strong>–info=progress2</strong> option that outputs statistics
based on the whole transfer, rather than individual files. Use this
flag without outputting a filename (e.g. avoid <strong>-v</strong> or specify
<strong>–info=name0</strong>) if you want to see how the transfer is doing without
scrolling the screen with a lot of names. (You don&#39;t need to specify
the <strong>–progress</strong> option in order to use <strong>–info=progress2</strong>.)

Finally, you can get an instant progress report by sending rsync a
signal of either SIGINFO or SIGVTALRM. On BSD systems, a SIGINFO is
generated by typing a Ctrl+T (Linux doesn&#39;t currently support a
SIGINFO signal). When the client-side process receives one of those
signals, it sets a flag to output a single progress report which is
output when the current file transfer finishes (so it may take a
little time if a big file is being handled when the signal arrives). A
filename is output (if needed) followed by the <strong>–info=progress2</strong>
format of progress info. If you don&#39;t know which of the 3 rsync
processes is the client process, it&#39;s OK to signal all of them (since
the non-client processes ignore the signal).

CAUTION: sending SIGVTALRM to an older rsync (pre-3.2.0) will kill it.</dd>
<dt>
–password-file=FILE
</dt>
<dd>This option allows you to provide a password
for accessing an rsync daemon via a file or via standard input if
<strong>FILE</strong> is <strong>-</strong>. The file should contain just the password on the first
line (all other lines are ignored). Rsync will exit with an error if
<strong>FILE</strong> is world readable or if a root-run rsync command finds a
non-root-owned file.

This option does not supply a password to a remote shell transport
such as ssh; to learn how to do that, consult the remote shell&#39;s
documentation. When accessing an rsync daemon using a remote shell as
the transport, this option only comes into effect after the remote
shell finishes its authentication (i.e. if you have also specified a
password in the daemon&#39;s config file).</dd>
<dt>
–early-input=FILE
</dt>
<dd>This option allows rsync to send up to 5K of
data to the &#34;early exec&#34; script on its stdin. One possible use of this
data is to give the script a secret that can be used to mount an
encrypted filesystem (which you should unmount in the the &#34;post-xfer
exec&#34; script).

The daemon must be at least version 3.2.1.</dd>
<dt>
–list-only
</dt>
<dd>
<p>This option will cause the source files to be listed
instead of transferred. This option is inferred if there is a single
source arg and no destination specified, so its main uses are:</p>
<ol>
<li>to turn a copy command that includes a destination arg into a
file-listing command, or</li>
<li>to be able to specify more than one source arg. Note: be sure to
include the destination.</li>
</ol>
<p>CAUTION: keep in mind that a source arg with a wild-card is expanded
by the shell into multiple args, so it is never safe to try to specify
a single wild-card arg to try to infer this option. A safe example is:</p>
<pre class="example">
rsync -av --list-only foo* dest/
</pre>
<p>
This option always uses an output format that looks similar to this:</p>
<pre class="example">
drwxrwxr-x          4,096 2022/09/30 12:53:11 support
-rw-rw-r--             80 2005/01/11 10:37:37 support/Makefile
</pre>
<p>
The only option that affects this output style is (as of 3.1.0) the
<strong>–human-readable</strong> (<strong>-h</strong>) option. The default is to output sizes as
byte counts with digit separators (in a 14-character-width column).
Specifying at least one <strong>-h</strong> option makes the sizes output with unit
suffixes. If you want old-style bytecount sizes without digit
separators (and an 11-character-width column) use <strong>–no-h</strong>.</p>
<p>
Compatibility note: when requesting a remote listing of files from an
rsync that is version 2.6.3 or older, you may encounter an error if
you ask for a non-recursive listing. This is because a file listing
implies the <strong>–dirs</strong> option w/o <strong>–recursive</strong>, and older rsyncs don&#39;t
have that option. To avoid this problem, either specify the
<strong>–no-dirs</strong> option (if you don&#39;t need to expand a directory&#39;s
content), or turn on recursion and exclude the content of
subdirectories: <strong>-r –exclude=&#39;<em>*</em></strong>&#39;*.</p>
</dd>
<dt>
–bwlimit=RATE
</dt>
<dd>This option allows you to specify the maximum
transfer rate for the data sent over the socket, specified in units
per second. The RATE value can be suffixed with a string to indicate a
size multiplier, and may be a fractional value (e.g.
<strong>–bwlimit=1.5m</strong>). If no suffix is specified, the value will be
assumed to be in units of 1024 bytes (as if &#34;K&#34; or &#34;KiB&#34; had been
appended). See the <strong>–max-size</strong> option for a description of all the
available suffixes. A value of 0 specifies no limit.

For backward-compatibility reasons, the rate limit will be rounded to
the nearest KiB unit, so no rate smaller than 1024 bytes per second is
possible.

Rsync writes data over the socket in blocks, and this option both
limits the size of the blocks that rsync writes, and tries to keep the
average transfer rate at the requested limit. Some burstiness may be
seen where rsync writes out a block of data and then sleeps to bring
the average rate into compliance.

Due to the internal buffering of data, the <strong>–progress</strong> option may not
be an accurate reflection on how fast the data is being sent. This is
because some files can show up as being rapidly sent when the data is
quickly buffered, while other can show up as very slow when the
flushing of the output buffer occurs. This may be fixed in a future
version.

See also the daemon version of the <strong>–bwlimit</strong> option.</dd>
<dt>
–stop-after=MINS, (–time-limit=MINS)
</dt>
<dd>This option tells rsync to
stop copying when the specified number of minutes has elapsed.

For maximal flexibility, rsync does not communicate this option to the
remote rsync since it is usually enough that one side of the
connection quits as specified. This allows the option&#39;s use even when
only one side of the connection supports it. You can tell the remote
side about the time limit using <strong>–remote-option</strong> (<strong>-M</strong>), should the
need arise.

The <strong>–time-limit</strong> version of this option is deprecated.</dd>
<dt>
–stop-at=y-m-dTh:m
</dt>
<dd>This option tells rsync to stop copying when
the specified point in time has been reached. The date &amp; time can be
fully specified in a numeric format of year-month-dayThour:minute
(e.g. 2000-12-31T23:59) in the local timezone. You may choose to
separate the date numbers using slashes instead of dashes.

The value can also be abbreviated in a variety of ways, such as
specifying a 2-digit year and/or leaving off various values. In all
cases, the value will be taken to be the next possible point in time
where the supplied information matches. If the value specifies the
current time or a past time, rsync exits with an error.

For example, &#34;1-30&#34; specifies the next January 30th (at midnight local
time), &#34;14:00&#34; specifies the next 2 P.M., &#34;1&#34; specifies the next 1st
of the month at midnight, &#34;31&#34; specifies the next month where we can
stop on its 31st day, and &#34;:59&#34; specifies the next 59th minute after
the hour.

For maximal flexibility, rsync does not communicate this option to the
remote rsync since it is usually enough that one side of the
connection quits as specified. This allows the option&#39;s use even when
only one side of the connection supports it. You can tell the remote
side about the time limit using <strong>–remote-option</strong> (<strong>-M</strong>), should the
need arise. Do keep in mind that the remote host may have a different
default timezone than your local host.</dd>
<dt>
–fsync
</dt>
<dd>Cause the receiving side to fsync each finished file. This
may slow down the transfer, but can help to provide peace of mind when
updating critical files.</dd>
<dt>
–write-batch=FILE
</dt>
<dd>Record a file that can later be applied to
another identical destination with <strong>–read-batch</strong>. See the &#34;BATCH
MODE&#34; section for details, and also the <strong>–only-write-batch</strong> option.

This option overrides the negotiated checksum &amp; compress lists and
always negotiates a choice based on old-school md5/md4/zlib choices.
If you want a more modern choice, use the <strong>–checksum-choice</strong> (<strong>–cc</strong>)
and/or <strong>–compress-choice</strong> (<strong>–zc</strong>) options.</dd>
<dt>
–only-write-batch=FILE
</dt>
<dd>Works like <strong>–write-batch</strong>, except that no
updates are made on the destination system when creating the batch.
This lets you transport the changes to the destination system via some
other means and then apply the changes via <strong>–read-batch</strong>.

Note that you can feel free to write the batch directly to some
portable media: if this media fills to capacity before the end of the
transfer, you can just apply that partial transfer to the destination
and repeat the whole process to get the rest of the changes (as long
as you don&#39;t mind a partially updated destination system while the
multi-update cycle is happening).

Also note that you only save bandwidth when pushing changes to a
remote system because this allows the batched data to be diverted from
the sender into the batch file without having to flow over the wire to
the receiver (when pulling, the sender is remote, and thus can&#39;t write
the batch).</dd>
<dt>
–read-batch=FILE
</dt>
<dd>Apply all of the changes stored in FILE, a file
previously generated by <strong>–write-batch</strong>. If <em>FILE</em> is <strong>-</strong>, the batch
data will be read from standard input. See the &#34;BATCH MODE&#34; section
for details.</dd>
<dt>
–protocol=NUM
</dt>
<dd>Force an older protocol version to be used. This is
useful for creating a batch file that is compatible with an older
version of rsync. For instance, if rsync 2.6.4 is being used with the
<strong>–write-batch</strong> option, but rsync 2.6.3 is what will be used to run
the <strong>–read-batch</strong> option, you should use &#34;–protocol=28&#34; when
creating the batch file to force the older protocol version to be used
in the batch file (assuming you can&#39;t upgrade the rsync on the reading
system).</dd>
<dt>
–iconv=CONVERT_SPEC
</dt>
<dd>Rsync can convert filenames between character
sets using this option. Using a CONVERT_SPEC of &#34;.&#34; tells rsync to
look up the default character-set via the locale setting. Alternately,
you can fully specify what conversion to do by giving a local and a
remote charset separated by a comma in the order
<strong>–iconv=LOCAL,REMOTE</strong>, e.g. <strong>–iconv=utf8,iso88591</strong>. This order
ensures that the option will stay the same whether you&#39;re pushing or
pulling files. Finally, you can specify either <strong>–no-iconv</strong> or a
CONVERT_SPEC of &#34;-&#34; to turn off any conversion. The default setting of
this option is site-specific, and can also be affected via the
<strong>RSYNC_ICONV</strong> environment variable.

For a list of what charset names your local iconv library supports,
you can run &#34;<strong>iconv –list</strong>&#34;.

If you specify the <strong>–secluded-args</strong> (<strong>-s</strong>) option, rsync will
translate the filenames you specify on the command-line that are being
sent to the remote host. See also the <strong>–files-from</strong> option.

Note that rsync does not do any conversion of names in filter files
(including include/exclude files). It is up to you to ensure that
you&#39;re specifying matching rules that can match on both sides of the
transfer. For instance, you can specify extra include/exclude rules if
there are filename differences on the two sides that need to be
accounted for.

When you pass an <strong>–iconv</strong> option to an rsync daemon that allows it,
the daemon uses the charset specified in its &#34;charset&#34; configuration
parameter regardless of the remote charset you actually pass. Thus,
you may feel free to specify just the local charset for a daemon
transfer (e.g. <strong>–iconv=utf8</strong>).</dd>
<dt>
–ipv4, -4 or –ipv6, -6
</dt>
<dd>Tells rsync to prefer IPv4/IPv6 when
creating sockets or running ssh. This affects sockets that rsync has
direct control over, such as the outgoing socket when directly
contacting an rsync daemon, as well as the forwarding of the <strong>-4</strong> or
<strong>-6</strong> option to ssh when rsync can deduce that ssh is being used as the
remote shell. For other remote shells you&#39;ll need to specify the
&#34;<strong>–rsh SHELL -4</strong>&#34; option directly (or whatever IPv4/IPv6 hint options
it uses).

See also the daemon version of these options.

If rsync was compiled without support for IPv6, the <strong>–ipv6</strong> option
will have no effect. The <strong>rsync –version</strong> output will contain &#34;<strong>no
IPv6</strong>&#34; if is the case.</dd>
<dt>
–checksum-seed=NUM
</dt>
<dd>Set the checksum seed to the integer NUM. This
4 byte checksum seed is included in each block and MD4 file checksum
calculation (the more modern MD5 file checksums don&#39;t use a seed). By
default the checksum seed is generated by the server and defaults to
the current *time*(). This option is used to set a specific checksum
seed, which is useful for applications that want repeatable block
checksums, or in the case where the user wants a more random checksum
seed. Setting NUM to 0 causes rsync to use the default of *time*() for
checksum seed.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-17" class="outline-2">
<h2 id="headline-17">
DAEMON OPTIONS
</h2>
<div id="outline-text-headline-17" class="outline-text-2">
<p>The options allowed when starting an rsync daemon are as follows:</p>
<dl>
<dt>
–daemon
</dt>
<dd>This tells rsync that it is to run as a daemon. The daemon
you start running may be accessed using an rsync client using the
<strong>host::module</strong> or <strong>rsync://host/module/</strong> syntax.

If standard input is a socket then rsync will assume that it is being
run via inetd, otherwise it will detach from the current terminal and
become a background daemon. The daemon will read the config file
(rsyncd.conf) on each connect made by a client and respond to requests
accordingly.

See the *rsyncd.conf*(5) manpage for more details.</dd>
<dt>
–address=ADDRESS
</dt>
<dd>By default rsync will bind to the wildcard
address when run as a daemon with the <strong>–daemon</strong> option. The
<strong>–address</strong> option allows you to specify a specific IP address (or
hostname) to bind to. This makes virtual hosting possible in
conjunction with the <strong>–config</strong> option.

See also the address global option in the rsyncd.conf manpage and the
client version of the <strong>–address</strong> option.</dd>
<dt>
–bwlimit=RATE
</dt>
<dd>This option allows you to specify the maximum
transfer rate for the data the daemon sends over the socket. The
client can still specify a smaller <strong>–bwlimit</strong> value, but no larger
value will be allowed.

See the client version of the <strong>–bwlimit</strong> option for some extra
details.</dd>
<dt>
–config=FILE
</dt>
<dd>This specifies an alternate config file than the
default. This is only relevant when <strong>–daemon</strong> is specified. The
default is /etc/rsyncd.conf unless the daemon is running over a remote
shell program and the remote user is not the super-user; in that case
the default is rsyncd.conf in the current directory (typically $HOME).</dd>
<dt>
–dparam=OVERRIDE, -M
</dt>
<dd>
<p>This option can be used to set a
daemon-config parameter when starting up rsync in daemon mode. It is
equivalent to adding the parameter at the end of the global settings
prior to the first module&#39;s definition. The parameter names can be
specified without spaces, if you so desire. For instance:</p>
<pre class="example">
rsync --daemon -M pidfile=/path/rsync.pid
</pre>
</dd>
<dt>
–no-detach
</dt>
<dd>When running as a daemon, this option instructs rsync
to not detach itself and become a background process. This option is
required when running as a service on Cygwin, and may also be useful
when rsync is supervised by a program such as <strong>daemontools</strong> or AIX&#39;s
<strong>System Resource Controller</strong>. <strong>–no-detach</strong> is also recommended when
rsync is run under a debugger. This option has no effect if rsync is
run from inetd or sshd.</dd>
<dt>
–port=PORT
</dt>
<dd>This specifies an alternate TCP port number for the
daemon to listen on rather than the default of 873.

See also the client version of the <strong>–port</strong> option and the port global
setting in the rsyncd.conf manpage.</dd>
<dt>
–log-file=FILE
</dt>
<dd>This option tells the rsync daemon to use the given
log-file name instead of using the &#34;<strong>log file</strong>&#34; setting in the config
file.

See also the client version of the <strong>–log-file</strong> option.</dd>
<dt>
–log-file-format=FORMAT
</dt>
<dd>This option tells the rsync daemon to use
the given FORMAT string instead of using the &#34;<strong>log format</strong>&#34; setting in
the config file. It also enables &#34;<strong>transfer logging</strong>&#34; unless the
string is empty, in which case transfer logging is turned off.

See also the client version of the <strong>–log-file-format</strong> option.</dd>
<dt>
–sockopts
</dt>
<dd>This overrides the <strong>socket options</strong> setting in the
rsyncd.conf file and has the same syntax.

See also the client version of the <strong>–sockopts</strong> option.</dd>
<dt>
–verbose, -v
</dt>
<dd>This option increases the amount of information the
daemon logs during its startup phase. After the client connects, the
daemon&#39;s verbosity level will be controlled by the options that the
client used and the &#34;<strong>max verbosity</strong>&#34; setting in the module&#39;s config
section.

See also the client version of the <strong>–verbose</strong> option.</dd>
<dt>
–ipv4, -4 or –ipv6, -6
</dt>
<dd>Tells rsync to prefer IPv4/IPv6 when
creating the incoming sockets that the rsync daemon will use to listen
for connections. One of these options may be required in older
versions of Linux to work around an IPv6 bug in the kernel (if you see
an &#34;address already in use&#34; error when nothing else is using the port,
try specifying <strong>–ipv6</strong> or <strong>–ipv4</strong> when starting the daemon).

See also the client version of these options.

If rsync was compiled without support for IPv6, the <strong>–ipv6</strong> option
will have no effect. The <strong>rsync –version</strong> output will contain &#34;<strong>no
IPv6</strong>&#34; if is the case.</dd>
<dt>
–help, -h
</dt>
<dd>When specified after <strong>–daemon</strong>, print a short help page
describing the options available for starting an rsync daemon.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-18" class="outline-2">
<h2 id="headline-18">
FILTER RULES
</h2>
<div id="outline-text-headline-18" class="outline-text-2">
<p>The filter rules allow for custom control of several aspects of how
files are handled:</p>
<ol>
<li value="15">Control which files the sending side puts into the file list
that describes the transfer hierarchy</li>
<li>Control which files the receiving side protects from deletion when
the file is not in the sender&#39;s file list</li>
<li>Control which extended attribute names are skipped when copying
xattrs</li>
</ol>
<p>The rules are either directly specified via option arguments or they can
be read in from one or more files. The filter-rule files can even be a
part of the hierarchy of files being copied, affecting different parts
of the tree in different ways.</p>
<div id="outline-container-headline-19" class="outline-3">
<h3 id="headline-19">
SIMPLE INCLUDE/EXCLUDE RULES
</h3>
<div id="outline-text-headline-19" class="outline-text-3">
<p>We will first cover the basics of how include &amp; exclude rules affect
what files are transferred, ignoring any deletion side-effects. Filter
rules mainly affect the contents of directories that rsync is
&#34;recursing&#34; into, but they can also affect a top-level item in the
transfer that was specified as a argument.</p>
<p>
The default for any unmatched file/dir is for it to be included in the
transfer, which puts the file/dir into the sender&#39;s file list. The use
of an exclude rule causes one or more matching files/dirs to be left out
of the sender&#39;s file list. An include rule can be used to limit the
effect of an exclude rule that is matching too many files.</p>
<p>
The order of the rules is important because the first rule that matches
is the one that takes effect. Thus, if an early rule excludes a file, no
include rule that comes after it can have any effect. This means that
you must place any include overrides somewhere prior to the exclude that
it is intended to limit.</p>
<p>
When a directory is excluded, all its contents and sub-contents are also
excluded. The sender doesn&#39;t scan through any of it at all, which can
save a lot of time when skipping large unneeded sub-trees.</p>
<p>
It is also important to understand that the include/exclude rules are
applied to every file and directory that the sender is recursing into.
Thus, if you want a particular deep file to be included, you have to
make sure that none of the directories that must be traversed on the way
down to that file are excluded or else the file will never be discovered
to be included. As an example, if the directory &#34;<strong>a/path</strong>&#34; was given as
a transfer argument and you want to ensure that the file
&#34;<strong>a/path/down/deep/wanted.txt</strong>&#34; is a part of the transfer, then the
sender must not exclude the directories &#34;<strong>a/path</strong>&#34;, &#34;<strong>a/path/down</strong>&#34;, or
&#34;<strong>a/path/down/deep</strong>&#34; as it makes it way scanning through the file tree.</p>
<p>
When you are working on the rules, it can be helpful to ask rsync to
tell you what is being excluded/included and why. Specifying
<strong>–debug=FILTER</strong> or (when pulling files) <strong>-M–debug=FILTER</strong> turns on
level 1 of the FILTER debug information that will output a message any
time that a file or directory is included or excluded and which rule it
matched. Beginning in 3.2.4 it will also warn if a filter rule has
trailing whitespace, since an exclude of &#34;foo &#34; (with a trailing space)
will not exclude a file named &#34;foo&#34;.</p>
<p>
Exclude and include rules can specify wildcard PATTERN MATCHING RULES
(similar to shell wildcards) that allow you to match things like a file
suffix or a portion of a filename.</p>
<p>
A rule can be limited to only affecting a directory by putting a
trailing slash onto the filename.</p>
</div>
</div>
<div id="outline-container-headline-20" class="outline-3">
<h3 id="headline-20">
SIMPLE INCLUDE/EXCLUDE EXAMPLE
</h3>
<div id="outline-text-headline-20" class="outline-text-3">
<p>With the following file tree created on the sending side:</p>
<blockquote>
<pre class="example">
mkdir x/
touch x/file.txt
mkdir x/y/
touch x/y/file.txt
touch x/y/zzz.txt
mkdir x/z/
touch x/z/file.txt
</pre>
</blockquote>
<p>
Then the following rsync command will transfer the file &#34;<strong>x/y/file.txt</strong>&#34;
and the directories needed to hold it, resulting in the path
&#34;<strong>/tmp/x/y/file.txt</strong>&#34; existing on the remote host:</p>
<blockquote>
<pre class="example">
rsync -ai -f&#39;+ x/&#39; -f&#39;+ x/y/&#39; -f&#39;+ x/y/file.txt&#39; -f&#39;- *&#39; x host:/tmp/
</pre>
</blockquote>
<p>
Aside: this copy could also have been accomplished using the <strong>-R</strong> option
(though the 2 commands behave differently if deletions are enabled):</p>
<blockquote>
<pre class="example">
rsync -aiR x/y/file.txt host:/tmp/
</pre>
</blockquote>
<p>
The following command does not need an include of the &#34;x&#34; directory
because it is not a part of the transfer (note the traililng slash).
Running this command would copy just &#34;<strong>/tmp/x/file.txt</strong>&#34; because the &#34;y&#34;
and &#34;z&#34; dirs get excluded:</p>
<blockquote>
<pre class="example">
rsync -ai -f&#39;+ file.txt&#39; -f&#39;- *&#39; x/ host:/tmp/x/
</pre>
</blockquote>
<p>
This command would omit the zzz.txt file while copying &#34;x&#34; and
everything else it contains:</p>
<blockquote>
<pre class="example">
rsync -ai -f&#39;- zzz.txt&#39; x host:/tmp/
</pre>
</blockquote>
</div>
</div>
<div id="outline-container-headline-21" class="outline-3">
<h3 id="headline-21">
FILTER RULES WHEN DELETING
</h3>
<div id="outline-text-headline-21" class="outline-text-3">
<p>By default the include &amp; exclude filter rules affect both the sender (as
it creates its file list) and the receiver (as it creates its file lists
for calculating deletions). If no delete option is in effect, the
receiver skips creating the delete-related file lists. This two-sided
default can be manually overridden so that you are only specifying
sender rules or receiver rules, as described in the FILTER RULES IN
DEPTH section.</p>
<p>
When deleting, an exclude protects a file from being removed on the
receiving side while an include overrides that protection (putting the
file at risk of deletion). The default is for a file to be at risk –
its safety depends on it matching a corresponding file from the sender.</p>
<p>
An example of the two-sided exclude effect can be illustrated by the
copying of a C development directory between 2 systems. When doing a
touch-up copy, you might want to skip copying the built executable and
the <strong>.o</strong> files (sender hide) so that the receiving side can build their
own and not lose any object files that are already correct (receiver
protect). For instance:</p>
<blockquote>
<pre class="example">
rsync -ai --del -f&#39;- *.o&#39; -f&#39;- cmd&#39; src host:/dest/
</pre>
</blockquote>
<p>
Note that using <strong>-f&#39;-p *.o&#39;</strong> is even better than <strong>-f&#39;- *.o&#39;</strong> if there is
a chance that the directory structure may have changed. The &#34;p&#34; modifier
is discussed in FILTER RULE MODIFIERS.</p>
<p>
One final note, if your shell doesn&#39;t mind unexpanded wildcards, you
could simplify the typing of the filter options by using an underscore
in place of the space and leaving off the quotes. For instance, <strong>-f
-_</strong>.o -f -_cmd* (and similar) could be used instead of the filter
options above.</p>
</div>
</div>
<div id="outline-container-headline-22" class="outline-3">
<h3 id="headline-22">
FILTER RULES IN DEPTH
</h3>
<div id="outline-text-headline-22" class="outline-text-3">
<p>Rsync supports old-style include/exclude rules and new-style filter
rules. The older rules are specified using <strong>–include</strong> and <strong>–exclude</strong>
as well as the <strong>–include-from</strong> and <strong>–exclude-from</strong>. These are limited
in behavior but they don&#39;t require a &#34;-&#34; or &#34;+&#34; prefix. An old-style
exclude rule is turned into a &#34;<strong>- name</strong>&#34; filter rule (with no modifiers)
and an old-style include rule is turned into a &#34;<strong>+ name</strong>&#34; filter rule
(with no modifiers).</p>
<p>
Rsync builds an ordered list of filter rules as specified on the
command-line and/or read-in from files. New style filter rules have the
following syntax:</p>
<blockquote>
<pre class="example">
RULE [PATTERN_OR_FILENAME]
RULE,MODIFIERS [PATTERN_OR_FILENAME]
</pre>
</blockquote>
<p>
You have your choice of using either short or long RULE names, as
described below. If you use a short-named rule, the &#39;,&#39; separating the
RULE from the MODIFIERS is optional. The PATTERN or FILENAME that
follows (when present) must come after either a single space or an
underscore (_). Any additional spaces and/or underscores are considered
to be a part of the pattern name. Here are the available rule prefixes:</p>
<dl>
<dt>
exclude, &#39;-&#39;
</dt>
<dd>specifies an exclude pattern that (by default) is both
a <strong>hide</strong> and a <strong>protect</strong>.</dd>
<dt>
include, &#39;+&#39;
</dt>
<dd>specifies an include pattern that (by default) is both
a <strong>show</strong> and a <strong>risk</strong>.</dd>
<dt>
merge, &#39;.&#39;
</dt>
<dd>specifies a merge-file on the client side to read for
more rules.</dd>
<dt>
dir-merge, &#39;:&#39;
</dt>
<dd>specifies a per-directory merge-file. Using this
kind of filter rule requires that you trust the sending side&#39;s filter
checking, so it has the side-effect mentioned under the
<strong>–trust-sender</strong> option.</dd>
<dt>
hide, &#39;H&#39;
</dt>
<dd>specifies a pattern for hiding files from the transfer.
Equivalent to a sender-only exclude, so <strong>-f&#39;H foo&#39;</strong> could also be
specified as <strong>-f&#39;-s foo&#39;</strong>.</dd>
<dt>
show, &#39;S&#39;
</dt>
<dd>files that match the pattern are not hidden. Equivalent
to a sender-only include, so <strong>-f&#39;S foo&#39;</strong> could also be specified as
<strong>-f&#39;+s foo&#39;</strong>.</dd>
<dt>
protect, &#39;P&#39;
</dt>
<dd>specifies a pattern for protecting files from
deletion. Equivalent to a receiver-only exclude, so <strong>-f&#39;P foo&#39;</strong> could
also be specified as <strong>-f&#39;-r foo&#39;</strong>.</dd>
<dt>
risk, &#39;R&#39;
</dt>
<dd>files that match the pattern are not protected.
Equivalent to a receiver-only include, so <strong>-f&#39;R foo&#39;</strong> could also be
specified as <strong>-f&#39;+r foo&#39;</strong>.</dd>
<dt>
clear, &#39;!&#39;
</dt>
<dd>clears the current include/exclude list (takes no arg)</dd>
</dl>
<p>When rules are being read from a file (using merge or dir-merge), empty
lines are ignored, as are whole-line comments that start with a &#39;<strong>#</strong>&#39;
(filename rules that contain a hash character are unaffected).</p>
<p>
Note also that the <strong>–filter</strong>, <strong>–include</strong>, and <strong>–exclude</strong> options take
one rule/pattern each. To add multiple ones, you can repeat the options
on the command-line, use the merge-file syntax of the <strong>–filter</strong> option,
or the <strong>–include-from</strong> / <strong>–exclude-from</strong> options.</p>
</div>
</div>
<div id="outline-container-headline-23" class="outline-3">
<h3 id="headline-23">
PATTERN MATCHING RULES
</h3>
<div id="outline-text-headline-23" class="outline-text-3">
<p>Most of the rules mentioned above take an argument that specifies what
the rule should match. If rsync is recursing through a directory
hierarchy, keep in mind that each pattern is matched against the name of
every directory in the descent path as rsync finds the filenames to
send.</p>
<p>
The matching rules for the pattern argument take several forms:</p>
<ol>
<li value="15">If a pattern contains a <strong>/</strong> (not counting a trailing slash) or
a &#34;<strong>**</strong>&#34; (which can match a slash), then the pattern is matched
against the full pathname, including any leading directories within
the transfer. If the pattern doesn&#39;t contain a (non-trailing) <strong>/</strong> or
a &#34;<strong>**</strong>&#34;, then it is matched only against the final component of the
filename or pathname. For example, <strong>foo</strong> means that the final path
component must be &#34;foo&#34; while <strong>foo/bar</strong> would match the last 2
elements of the path (as long as both elements are within the
transfer).</li>
<li>A pattern that ends with a <strong>/</strong> only matches a directory, not a
regular file, symlink, or device.</li>
<li>A pattern that starts with a <strong>/</strong> is anchored to the start of the
transfer path instead of the end. For example, <strong>/foo/**</strong> or
<strong>/foo/bar/**</strong> match only leading elements in the path. If the rule
is read from a per-directory filter file, the transfer path being
matched will begin at the level of the filter file instead of the
top of the transfer. See the section on ANCHORING INCLUDE/EXCLUDE
PATTERNS for a full discussion of how to specify a pattern that
matches at the root of the transfer.</li>
</ol>
<p>Rsync chooses between doing a simple string match and wildcard matching
by checking if the pattern contains one of these three wildcard
characters: &#39;<strong>*</strong>&#39;, &#39;<strong>?</strong>&#39;, and &#39;<strong>[</strong>&#39; :</p>
<ol>
<li value="15">a &#39;<strong>?</strong>&#39; matches any single character except a slash (<strong>/</strong>).</li>
<li>a &#39;<strong>*</strong>&#39; matches zero or more non-slash characters.</li>
<li>a &#39;<strong>**</strong>&#39; matches zero or more characters, including slashes.</li>
<li>a &#39;<strong>[</strong>&#39; introduces a character class, such as <strong>[a-z]</strong> or
<strong><a href=":alpha:">:alpha:</a></strong>, that must match one character.</li>
<li>a trailing <strong><strong>*</strong></strong> in the pattern is a shorthand that allows you to
match a directory and all its contents using a single rule. For
example, specifying &#34;<strong>dir_name/***</strong>&#34; will match both the &#34;dir_name&#34;
directory (as if &#34;<strong>dir_name/</strong>&#34; had been specified) and everything in
the directory (as if &#34;<strong>dir_name/**</strong>&#34; had been specified).</li>
<li>a backslash can be used to escape a wildcard character, but it is
only interpreted as an escape character if at least one wildcard
character is present in the match pattern. For instance, the pattern
&#34;<strong>foo\bar</strong>&#34; matches that single backslash literally, while the
pattern &#34;<strong>foo\bar*</strong>&#34; would need to be changed to &#34;<strong>foo\\bar*</strong>&#34; to
avoid the &#34;<strong>\b</strong>&#34; becoming just &#34;b&#34;.</li>
</ol>
<p>Here are some examples of exclude/include matching:</p>
<ol>
<li value="15">Option <strong>-f&#39;- *.o&#39;</strong> would exclude all filenames ending with
<strong>.o</strong></li>
<li>Option <strong>-f&#39;- /foo&#39;</strong> would exclude a file (or directory) named foo in
the transfer-root directory</li>
<li>Option <strong>-f&#39;- foo/&#39;</strong> would exclude any directory named foo</li>
<li>Option <strong>-f&#39;- foo/*/bar&#39;</strong> would exclude any file/dir named bar which
is at two levels below a directory named foo (if foo is in the
transfer)</li>
<li>Option <strong>-f&#39;- /foo/**/bar&#39;</strong> would exclude any file/dir named bar that
was two or more levels below a top-level directory named foo (note
that /foo/bar is <strong>not</strong> excluded by this)</li>
<li>Options <strong>-f&#39;+ */&#39; -f&#39;+ *.c&#39; -f&#39;- *&#39;</strong> would include all directories
and .c source files but nothing else</li>
<li>Options <strong>-f&#39;+ foo/&#39; -f&#39;+ foo/bar.c&#39; -f&#39;- *&#39;</strong> would include only the
foo directory and foo/bar.c (the foo directory must be explicitly
included or it would be excluded by the &#34;<strong>- *</strong>&#34;)</li>
</ol>
</div>
</div>
<div id="outline-container-headline-24" class="outline-3">
<h3 id="headline-24">
FILTER RULE MODIFIERS
</h3>
<div id="outline-text-headline-24" class="outline-text-3">
<p>The following modifiers are accepted after an include (+) or exclude (-)
rule:</p>
<ol>
<li value="15">A <strong>/</strong> specifies that the include/exclude rule should be
matched against the absolute pathname of the current item. For
example, <strong>-f&#39;-/ /etc/passwd&#39;</strong> would exclude the passwd file any time
the transfer was sending files from the &#34;<em>etc&#34; directory, and &#34;-</em>
subdir/foo&#34; would always exclude &#34;foo&#34; when it is in a dir named
&#34;subdir&#34;, even if &#34;foo&#34; is at the root of the current transfer.</li>
<li>A <strong>!</strong> specifies that the include/exclude should take effect if the
pattern fails to match. For instance, <strong>-f&#39;-! */&#39;</strong> would exclude all
non-directories.</li>
<li>A <strong>C</strong> is used to indicate that all the global CVS-exclude rules
should be inserted as excludes in place of the &#34;-C&#34;. No arg should
follow.</li>
<li>An <strong>s</strong> is used to indicate that the rule applies to the sending
side. When a rule affects the sending side, it affects what files
are put into the sender&#39;s file list. The default is for a rule to
affect both sides unless <strong>–delete-excluded</strong> was specified, in which
case default rules become sender-side only. See also the hide (H)
and show (S) rules, which are an alternate way to specify
sending-side includes/excludes.</li>
<li>An <strong>r</strong> is used to indicate that the rule applies to the receiving
side. When a rule affects the receiving side, it prevents files from
being deleted. See the <strong>s</strong> modifier for more info. See also the
protect (P) and risk (R) rules, which are an alternate way to
specify receiver-side includes/excludes.</li>
<li>A <strong>p</strong> indicates that a rule is perishable, meaning that it is
ignored in directories that are being deleted. For instance, the
<strong>–cvs-exclude</strong> (<strong>-C</strong>) option&#39;s default rules that exclude things
like &#34;CVS&#34; and &#34;<strong>*.o</strong>&#34; are marked as perishable, and will not
prevent a directory that was removed on the source from being
deleted on the destination.</li>
<li>An <strong>x</strong> indicates that a rule affects xattr names in xattr
copy/delete operations (and is thus ignored when matching file/dir
names). If no xattr-matching rules are specified, a default xattr
filtering rule is used (see the <strong>–xattrs</strong> option).</li>
</ol>
</div>
</div>
<div id="outline-container-headline-25" class="outline-3">
<h3 id="headline-25">
MERGE-FILE FILTER RULES
</h3>
<div id="outline-text-headline-25" class="outline-text-3">
<p>You can merge whole files into your filter rules by specifying either a
merge (.) or a dir-merge (:) filter rule (as introduced in the FILTER
RULES section above).</p>
<p>
There are two kinds of merged files – single-instance (&#39;.&#39;) and
per-directory (&#39;:&#39;). A single-instance merge file is read one time, and
its rules are incorporated into the filter list in the place of the &#34;.&#34;
rule. For per-directory merge files, rsync will scan every directory
that it traverses for the named file, merging its contents when the file
exists into the current list of inherited rules. These per-directory
rule files must be created on the sending side because it is the sending
side that is being scanned for the available files to transfer. These
rule files may also need to be transferred to the receiving side if you
want them to affect what files don&#39;t get deleted (see PER-DIRECTORY
RULES AND DELETE below).</p>
<p>
Some examples:</p>
<blockquote>
<pre class="example">
merge /etc/rsync/default.rules
. /etc/rsync/default.rules
dir-merge .per-dir-filter
dir-merge,n- .non-inherited-per-dir-excludes
:n- .non-inherited-per-dir-excludes
</pre>
</blockquote>
<p>
The following modifiers are accepted after a merge or dir-merge rule:</p>
<ol>
<li value="15">A <strong>-</strong> specifies that the file should consist of only exclude
patterns, with no other rule-parsing except for in-file comments.</li>
<li>A <strong>+</strong> specifies that the file should consist of only include
patterns, with no other rule-parsing except for in-file comments.</li>
<li>A <strong>C</strong> is a way to specify that the file should be read in a
CVS-compatible manner. This turns on &#39;n&#39;, &#39;w&#39;, and &#39;-&#39;, but also
allows the list-clearing token (!) to be specified. If no filename
is provided, &#34;.cvsignore&#34; is assumed.</li>
<li>A <strong>e</strong> will exclude the merge-file name from the transfer; e.g.
&#34;dir-merge,e .rules&#34; is like &#34;dir-merge .rules&#34; and &#34;- .rules&#34;.</li>
<li>An <strong>n</strong> specifies that the rules are not inherited by subdirectories.</li>
<li>A <strong>w</strong> specifies that the rules are word-split on whitespace instead
of the normal line-splitting. This also turns off comments. Note:
the space that separates the prefix from the rule is treated
specially, so &#34;- foo + bar&#34; is parsed as two rules (assuming that
prefix-parsing wasn&#39;t also disabled).</li>
<li>You may also specify any of the modifiers for the &#34;+&#34; or &#34;-&#34; rules
(above) in order to have the rules that are read in from the file
default to having that modifier set (except for the <strong>!</strong> modifier,
which would not be useful). For instance, &#34;merge,-/ .excl&#34; would
treat the contents of .excl as absolute-path excludes, while
&#34;dir-merge,s .filt&#34; and &#34;:sC&#34; would each make all their
per-directory rules apply only on the sending side. If the merge
rule specifies sides to affect (via the <strong>s</strong> or <strong>r</strong> modifier or
both), then the rules in the file must not specify sides (via a
modifier or a rule prefix such as <strong>hide</strong>).</li>
</ol>
<p>Per-directory rules are inherited in all subdirectories of the directory
where the merge-file was found unless the &#39;n&#39; modifier was used. Each
subdirectory&#39;s rules are prefixed to the inherited per-directory rules
from its parents, which gives the newest rules a higher priority than
the inherited rules. The entire set of dir-merge rules are grouped
together in the spot where the merge-file was specified, so it is
possible to override dir-merge rules via a rule that got specified
earlier in the list of global rules. When the list-clearing rule (&#34;!&#34;)
is read from a per-directory file, it only clears the inherited rules
for the current merge file.</p>
<p>
Another way to prevent a single rule from a dir-merge file from being
inherited is to anchor it with a leading slash. Anchored rules in a
per-directory merge-file are relative to the merge-file&#39;s directory, so
a pattern &#34;/foo&#34; would only match the file &#34;foo&#34; in the directory where
the dir-merge filter file was found.</p>
<p>
Here&#39;s an example filter file which you&#39;d specify via <strong>–filter=&#34;.
file&#34;:</strong></p>
<blockquote>
<pre class="example">
merge /home/user/.global-filter
- *.gz
dir-merge .rules
+ *.[ch]
- *.o
- foo*
</pre>
</blockquote>
<p>
This will merge the contents of the <em>home/user</em>.global-filter file at
the start of the list and also turns the &#34;.rules&#34; filename into a
per-directory filter file. All rules read in prior to the start of the
directory scan follow the global anchoring rules (i.e. a leading slash
matches at the root of the transfer).</p>
<p>
If a per-directory merge-file is specified with a path that is a parent
directory of the first transfer directory, rsync will scan all the
parent dirs from that starting point to the transfer directory for the
indicated per-directory file. For instance, here is a common filter (see
<strong>-F</strong>):</p>
<blockquote>
<pre class="example">
--filter=&#39;: /.rsync-filter&#39;
</pre>
</blockquote>
<p>
That rule tells rsync to scan for the file .rsync-filter in all
directories from the root down through the parent directory of the
transfer prior to the start of the normal directory scan of the file in
the directories that are sent as a part of the transfer. (Note: for an
rsync daemon, the root is always the same as the module&#39;s &#34;path&#34;.)</p>
<p>
Some examples of this pre-scanning for per-directory files:</p>
<blockquote>
<pre class="example">
rsync -avF /src/path/ /dest/dir
rsync -av --filter=&#39;: ../../.rsync-filter&#39; /src/path/ /dest/dir
rsync -av --filter=&#39;: .rsync-filter&#39; /src/path/ /dest/dir
</pre>
</blockquote>
<p>
The first two commands above will look for &#34;.rsync-filter&#34; in &#34;/&#34; and
&#34;/src&#34; before the normal scan begins looking for the file in &#34;/src/path&#34;
and its subdirectories. The last command avoids the parent-dir scan and
only looks for the &#34;.rsync-filter&#34; files in each directory that is a
part of the transfer.</p>
<p>
If you want to include the contents of a &#34;.cvsignore&#34; in your patterns,
you should use the rule &#34;:C&#34;, which creates a dir-merge of the
.cvsignore file, but parsed in a CVS-compatible manner. You can use this
to affect where the <strong>–cvs-exclude</strong> (<strong>-C</strong>) option&#39;s inclusion of the
per-directory .cvsignore file gets placed into your rules by putting the
&#34;:C&#34; wherever you like in your filter rules. Without this, rsync would
add the dir-merge rule for the .cvsignore file at the end of all your
other rules (giving it a lower priority than your command-line rules).
For example:</p>
<blockquote>
<pre class="example">
cat &lt;&lt;EOT | rsync -avC --filter=&#39;. -&#39; a/ b
+ foo.o
:C
- *.old
EOT
rsync -avC --include=foo.o -f :C --exclude=&#39;*.old&#39; a/ b
</pre>
</blockquote>
<p>
Both of the above rsync commands are identical. Each one will merge all
the per-directory .cvsignore rules in the middle of the list rather than
at the end. This allows their dir-specific rules to supersede the rules
that follow the :C instead of being subservient to all your rules. To
affect the other CVS exclude rules (i.e. the default list of exclusions,
the contents of $HOME/.cvsignore, and the value of $CVSIGNORE) you
should omit the <strong>-C</strong> command-line option and instead insert a &#34;-C&#34; rule
into your filter rules; e.g. &#34;<strong>–filter=-C</strong>&#34;.</p>
</div>
</div>
<div id="outline-container-headline-26" class="outline-3">
<h3 id="headline-26">
LIST-CLEARING FILTER RULE
</h3>
<div id="outline-text-headline-26" class="outline-text-3">
<p>You can clear the current include/exclude list by using the &#34;!&#34; filter
rule (as introduced in the FILTER RULES section above). The &#34;current&#34;
list is either the global list of rules (if the rule is encountered
while parsing the filter options) or a set of per-directory rules (which
are inherited in their own sub-list, so a subdirectory can use this to
clear out the parent&#39;s rules).</p>
</div>
</div>
<div id="outline-container-headline-27" class="outline-3">
<h3 id="headline-27">
ANCHORING INCLUDE/EXCLUDE PATTERNS
</h3>
<div id="outline-text-headline-27" class="outline-text-3">
<p>As mentioned earlier, global include/exclude patterns are anchored at
the &#34;root of the transfer&#34; (as opposed to per-directory patterns, which
are anchored at the merge-file&#39;s directory). If you think of the
transfer as a subtree of names that are being sent from sender to
receiver, the transfer-root is where the tree starts to be duplicated in
the destination directory. This root governs where patterns that start
with a / match.</p>
<p>
Because the matching is relative to the transfer-root, changing the
trailing slash on a source path or changing your use of the <strong>–relative</strong>
option affects the path you need to use in your matching (in addition to
changing how much of the file tree is duplicated on the destination
host). The following examples demonstrate this.</p>
<p>
Let&#39;s say that we want to match two source files, one with an absolute
path of &#34;/home/me/foo/bar&#34;, and one with a path of &#34;/home/you/bar/baz&#34;.
Here is how the various command choices differ for a 2-source transfer:</p>
<blockquote>
<pre class="example">
Example cmd: rsync -a /home/me /home/you /dest
+/- pattern: /me/foo/bar
+/- pattern: /you/bar/baz
Target file: /dest/me/foo/bar
Target file: /dest/you/bar/baz
</pre>
</blockquote>
<blockquote>
<pre class="example">
Example cmd: rsync -a /home/me/ /home/you/ /dest
+/- pattern: /foo/bar               (note missing &#34;me&#34;)
+/- pattern: /bar/baz               (note missing &#34;you&#34;)
Target file: /dest/foo/bar
Target file: /dest/bar/baz
</pre>
</blockquote>
<blockquote>
<pre class="example">
Example cmd: rsync -a --relative /home/me/ /home/you /dest
+/- pattern: /home/me/foo/bar       (note full path)
+/- pattern: /home/you/bar/baz      (ditto)
Target file: /dest/home/me/foo/bar
Target file: /dest/home/you/bar/baz
</pre>
</blockquote>
<blockquote>
<pre class="example">
Example cmd: cd /home; rsync -a --relative me/foo you/ /dest
+/- pattern: /me/foo/bar      (starts at specified path)
+/- pattern: /you/bar/baz     (ditto)
Target file: /dest/me/foo/bar
Target file: /dest/you/bar/baz
</pre>
</blockquote>
<p>
The easiest way to see what name you should filter is to just look at
the output when using <strong>–verbose</strong> and put a / in front of the name (use
the <strong>–dry-run</strong> option if you&#39;re not yet ready to copy any files).</p>
</div>
</div>
<div id="outline-container-headline-28" class="outline-3">
<h3 id="headline-28">
PER-DIRECTORY RULES AND DELETE
</h3>
<div id="outline-text-headline-28" class="outline-text-3">
<p>Without a delete option, per-directory rules are only relevant on the
sending side, so you can feel free to exclude the merge files themselves
without affecting the transfer. To make this easy, the &#39;e&#39; modifier adds
this exclude for you, as seen in these two equivalent commands:</p>
<blockquote>
<pre class="example">
rsync -av --filter=&#39;: .excl&#39; --exclude=.excl host:src/dir /dest
rsync -av --filter=&#39;:e .excl&#39; host:src/dir /dest
</pre>
</blockquote>
<p>
However, if you want to do a delete on the receiving side AND you want
some files to be excluded from being deleted, you&#39;ll need to be sure
that the receiving side knows what files to exclude. The easiest way is
to include the per-directory merge files in the transfer and use
<strong>–delete-after</strong>, because this ensures that the receiving side gets all
the same exclude rules as the sending side before it tries to delete
anything:</p>
<blockquote>
<pre class="example">
rsync -avF --delete-after host:src/dir /dest
</pre>
</blockquote>
<p>
However, if the merge files are not a part of the transfer, you&#39;ll need
to either specify some global exclude rules (i.e. specified on the
command line), or you&#39;ll need to maintain your own per-directory merge
files on the receiving side. An example of the first is this (assume
that the remote .rules files exclude themselves):</p>
<blockquote>
<pre class="example">
rsync -av --filter=&#39;: .rules&#39; --filter=&#39;. /my/extra.rules&#39;
   --delete host:src/dir /dest
</pre>
</blockquote>
<p>
In the above example the extra.rules file can affect both sides of the
transfer, but (on the sending side) the rules are subservient to the
rules merged from the .rules files because they were specified after the
per-directory merge rule.</p>
<p>
In one final example, the remote side is excluding the .rsync-filter
files from the transfer, but we want to use our own .rsync-filter files
to control what gets deleted on the receiving side. To do this we must
specifically exclude the per-directory merge files (so that they don&#39;t
get deleted) and then put rules into the local files to control what
else should not get deleted. Like one of these commands:</p>
<blockquote>
<pre class="example">
rsync -av --filter=&#39;:e /.rsync-filter&#39; --delete \
    host:src/dir /dest
rsync -avFF --delete host:src/dir /dest
</pre>
</blockquote>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-29" class="outline-2">
<h2 id="headline-29">
TRANSFER RULES
</h2>
<div id="outline-text-headline-29" class="outline-text-2">
<p>In addition to the FILTER RULES that affect the recursive file scans
that generate the file list on the sending and (when deleting) receiving
sides, there are transfer rules. These rules affect which files the
generator decides need to be transferred without the side effects of an
exclude filter rule. Transfer rules affect only files and never
directories.</p>
<p>
Because a transfer rule does not affect what goes into the sender&#39;s (and
receiver&#39;s) file list, it cannot have any effect on which files get
deleted on the receiving side. For example, if the file &#34;foo&#34; is present
in the sender&#39;s list but its size is such that it is omitted due to a
transfer rule, the receiving side does not request the file. However,
its presence in the file list means that a delete pass will not remove a
matching file named &#34;foo&#34; on the receiving side. On the other hand, a
server-side exclude (hide) of the file &#34;foo&#34; leaves the file out of the
server&#39;s file list, and absent a receiver-side exclude (protect) the
receiver will remove a matching file named &#34;foo&#34; if deletions are
requested.</p>
<p>
Given that the files are still in the sender&#39;s file list, the
<strong>–prune-empty-dirs</strong> option will not judge a directory as being empty
even if it contains only files that the transfer rules omitted.</p>
<p>
Similarly, a transfer rule does not have any extra effect on which files
are deleted on the receiving side, so setting a maximum file size for
the transfer does not prevent big files from being deleted.</p>
<p>
Examples of transfer rules include the default &#34;quick check&#34; algorithm
(which compares size &amp; modify time), the <strong>–update</strong> option, the
<strong>–max-size</strong> option, the <strong>–ignore-non-existing</strong> option, and a few
others.</p>
</div>
</div>
<div id="outline-container-headline-30" class="outline-2">
<h2 id="headline-30">
BATCH MODE
</h2>
<div id="outline-text-headline-30" class="outline-text-2">
<p>Batch mode can be used to apply the same set of updates to many
identical systems. Suppose one has a tree which is replicated on a
number of hosts. Now suppose some changes have been made to this source
tree and those changes need to be propagated to the other hosts. In
order to do this using batch mode, rsync is run with the write-batch
option to apply the changes made to the source tree to one of the
destination trees. The write-batch option causes the rsync client to
store in a &#34;batch file&#34; all the information needed to repeat this
operation against other, identical destination trees.</p>
<p>
Generating the batch file once saves having to perform the file status,
checksum, and data block generation more than once when updating
multiple destination trees. Multicast transport protocols can be used to
transfer the batch update files in parallel to many hosts at once,
instead of sending the same data to every host individually.</p>
<p>
To apply the recorded changes to another destination tree, run rsync
with the read-batch option, specifying the name of the same batch file,
and the destination tree. Rsync updates the destination tree using the
information stored in the batch file.</p>
<p>
For your convenience, a script file is also created when the write-batch
option is used: it will be named the same as the batch file with &#34;.sh&#34;
appended. This script file contains a command-line suitable for updating
a destination tree using the associated batch file. It can be executed
using a Bourne (or Bourne-like) shell, optionally passing in an
alternate destination tree pathname which is then used instead of the
original destination path. This is useful when the destination tree path
on the current host differs from the one used to create the batch file.</p>
<p>
Examples:</p>
<blockquote>
<pre class="example">
$ rsync --write-batch=foo -a host:/source/dir/ /adest/dir/
$ scp foo* remote:
$ ssh remote ./foo.sh /bdest/dir/
</pre>
</blockquote>
<blockquote>
<pre class="example">
$ rsync --write-batch=foo -a /source/dir/ /adest/dir/
$ ssh remote rsync --read-batch=- -a /bdest/dir/ &lt;foo
</pre>
</blockquote>
<p>
In these examples, rsync is used to update <em>adest/dir</em> from <em>source/dir</em>
and the information to repeat this operation is stored in &#34;foo&#34; and
&#34;foo.sh&#34;. The host &#34;remote&#34; is then updated with the batched data going
into the directory /bdest/dir. The differences between the two examples
reveals some of the flexibility you have in how you deal with batches:</p>
<ol>
<li value="15">The first example shows that the initial copy doesn&#39;t have to
be local – you can push or pull data to/from a remote host using
either the remote-shell syntax or rsync daemon syntax, as desired.</li>
<li>The first example uses the created &#34;foo.sh&#34; file to get the right
rsync options when running the read-batch command on the remote
host.</li>
<li>The second example reads the batch data via standard input so that
the batch file doesn&#39;t need to be copied to the remote machine
first. This example avoids the foo.sh script because it needed to
use a modified <strong>–read-batch</strong> option, but you could edit the script
file if you wished to make use of it (just be sure that no other
option is trying to use standard input, such as the
<strong>–exclude-from=-</strong> option).</li>
</ol>
<p>Caveats:</p>
<p>
The read-batch option expects the destination tree that it is updating
to be identical to the destination tree that was used to create the
batch update fileset. When a difference between the destination trees is
encountered the update might be discarded with a warning (if the file
appears to be up-to-date already) or the file-update may be attempted
and then, if the file fails to verify, the update discarded with an
error. This means that it should be safe to re-run a read-batch
operation if the command got interrupted. If you wish to force the
batched-update to always be attempted regardless of the file&#39;s size and
date, use the <strong>-I</strong> option (when reading the batch). If an error occurs,
the destination tree will probably be in a partially updated state. In
that case, rsync can be used in its regular (non-batch) mode of
operation to fix up the destination tree.</p>
<p>
The rsync version used on all destinations must be at least as new as
the one used to generate the batch file. Rsync will die with an error if
the protocol version in the batch file is too new for the batch-reading
rsync to handle. See also the <strong>–protocol</strong> option for a way to have the
creating rsync generate a batch file that an older rsync can understand.
(Note that batch files changed format in version 2.6.3, so mixing
versions older than that with newer versions will not work.)</p>
<p>
When reading a batch file, rsync will force the value of certain options
to match the data in the batch file if you didn&#39;t set them to the same
as the batch-writing command. Other options can (and should) be changed.
For instance <strong>–write-batch</strong> changes to <strong>–read-batch</strong>, <strong>–files-from</strong>
is dropped, and the <strong>–filter</strong> / <strong>–include</strong> / <strong>–exclude</strong> options are
not needed unless one of the <strong>–delete</strong> options is specified.</p>
<p>
The code that creates the BATCH.sh file transforms any
filter/include/exclude options into a single list that is appended as a
&#34;here&#34; document to the shell script file. An advanced user can use this
to modify the exclude list if a change in what gets deleted by
<strong>–delete</strong> is desired. A normal user can ignore this detail and just use
the shell script as an easy way to run the appropriate <strong>–read-batch</strong>
command for the batched data.</p>
<p>
The original batch mode in rsync was based on &#34;rsync+&#34;, but the latest
version uses a new implementation.</p>
</div>
</div>
<div id="outline-container-headline-31" class="outline-2">
<h2 id="headline-31">
SYMBOLIC LINKS
</h2>
<div id="outline-text-headline-31" class="outline-text-2">
<p>Three basic behaviors are possible when rsync encounters a symbolic link
in the source directory.</p>
<p>
By default, symbolic links are not transferred at all. A message
&#34;skipping non-regular&#34; file is emitted for any symlinks that exist.</p>
<p>
If <strong>–links</strong> is specified, then symlinks are added to the transfer
(instead of being noisily ignored), and the default handling is to
recreate them with the same target on the destination. Note that
<strong>–archive</strong> implies <strong>–links</strong>.</p>
<p>
If <strong>–copy-links</strong> is specified, then symlinks are &#34;collapsed&#34; by copying
their referent, rather than the symlink.</p>
<p>
Rsync can also distinguish &#34;safe&#34; and &#34;unsafe&#34; symbolic links. An
example where this might be used is a web site mirror that wishes to
ensure that the rsync module that is copied does not include symbolic
links to <strong>/etc/passwd</strong> in the public section of the site. Using
<strong>–copy-unsafe-links</strong> will cause any links to be copied as the file they
point to on the destination. Using <strong>–safe-links</strong> will cause unsafe
links to be omitted by the receiver. (Note that you must specify or
imply <strong>–links</strong> for <strong>–safe-links</strong> to have any effect.)</p>
<p>
Symbolic links are considered unsafe if they are absolute symlinks
(start with <strong>/</strong>), empty, or if they contain enough &#34;..&#34; components to
ascend from the top of the transfer.</p>
<p>
Here&#39;s a summary of how the symlink options are interpreted. The list is
in order of precedence, so if your combination of options isn&#39;t
mentioned, use the first line that is a complete subset of your options:</p>
<dl>
<dt>
–copy-links
</dt>
<dd>Turn all symlinks into normal files and directories
(leaving no symlinks in the transfer for any other options to affect).</dd>
<dt>
–copy-dirlinks
</dt>
<dd>Turn just symlinks to directories into real
directories, leaving all other symlinks to be handled as described
below.</dd>
<dt>
–links –copy-unsafe-links
</dt>
<dd>Turn all unsafe symlinks into files and
create all safe symlinks.</dd>
<dt>
–copy-unsafe-links
</dt>
<dd>Turn all unsafe symlinks into files, noisily
skip all safe symlinks.</dd>
<dt>
–links –safe-links
</dt>
<dd>The receiver skips creating unsafe symlinks
found in the transfer and creates the safe ones.</dd>
<dt>
–links
</dt>
<dd>Create all symlinks.</dd>
</dl>
<p>For the effect of <strong>–munge-links</strong>, see the discussion in that option&#39;s
section.</p>
<p>
Note that the <strong>–keep-dirlinks</strong> option does not effect symlinks in the
transfer but instead affects how rsync treats a symlink to a directory
that already exists on the receiving side. See that option&#39;s section for
a warning.</p>
</div>
</div>
<div id="outline-container-headline-32" class="outline-2">
<h2 id="headline-32">
DIAGNOSTICS
</h2>
<div id="outline-text-headline-32" class="outline-text-2">
<p>Rsync occasionally produces error messages that may seem a little
cryptic. The one that seems to cause the most confusion is &#34;protocol
version mismatch – is your shell clean?&#34;.</p>
<p>
This message is usually caused by your startup scripts or remote shell
facility producing unwanted garbage on the stream that rsync is using
for its transport. The way to diagnose this problem is to run your
remote shell like this:</p>
<blockquote>
<pre class="example">
ssh remotehost /bin/true &gt; out.dat
</pre>
</blockquote>
<p>
then look at out.dat. If everything is working correctly then out.dat
should be a zero length file. If you are getting the above error from
rsync then you will probably find that out.dat contains some text or
data. Look at the contents and try to work out what is producing it. The
most common cause is incorrectly configured shell startup scripts (such
as .cshrc or .profile) that contain output statements for
non-interactive logins.</p>
<p>
If you are having trouble debugging filter patterns, then try specifying
the <strong>-vv</strong> option. At this level of verbosity rsync will show why each
individual file is included or excluded.</p>
</div>
</div>
<div id="outline-container-headline-33" class="outline-2">
<h2 id="headline-33">
EXIT VALUES
</h2>
<div id="outline-text-headline-33" class="outline-text-2">
<ol>
<li value="15"><strong>0</strong> - Success</li>
<li><strong>1</strong> - Syntax or usage error</li>
<li><strong>2</strong> - Protocol incompatibility</li>
<li><strong>3</strong> - Errors selecting input/output files, dirs</li>
<li></li>
</ol>
<blockquote>
<ol>
<li value="15"><strong>4</strong> - Requested action not supported. Either:</li>
</ol>
<p>an attempt was made to manipulate 64-bit files on a platform that cannot
support them</p>
<ol>
<li value="15">an option was specified that is supported by the client and
not by the server</li>
</ol>
</blockquote>
<ol>
<li value="15"><strong>5</strong> - Error starting client-server protocol</li>
<li><strong>6</strong> - Daemon unable to append to log-file</li>
<li><strong>10</strong> - Error in socket I/O</li>
<li><strong>11</strong> - Error in file I/O</li>
<li><strong>12</strong> - Error in rsync protocol data stream</li>
<li><strong>13</strong> - Errors with program diagnostics</li>
<li><strong>14</strong> - Error in IPC code</li>
<li><strong>20</strong> - Received SIGUSR1 or SIGINT</li>
<li><strong>21</strong> - Some error returned by <strong>waitpid()</strong></li>
<li><strong>22</strong> - Error allocating core memory buffers</li>
<li><strong>23</strong> - Partial transfer due to error</li>
<li><strong>24</strong> - Partial transfer due to vanished source files</li>
<li><strong>25</strong> - The –max-delete limit stopped deletions</li>
<li><strong>30</strong> - Timeout in data send/receive</li>
<li><strong>35</strong> - Timeout waiting for daemon connection</li>
</ol>
</div>
</div>
<div id="outline-container-headline-34" class="outline-2">
<h2 id="headline-34">
ENVIRONMENT VARIABLES
</h2>
<div id="outline-text-headline-34" class="outline-text-2">
<dl>
<dt>
CVSIGNORE
</dt>
<dd>The CVSIGNORE environment variable supplements any ignore
patterns in .cvsignore files. See the <strong>–cvs-exclude</strong> option for more
details.</dd>
<dt>
RSYNC_ICONV
</dt>
<dd>Specify a default <strong>–iconv</strong> setting using this
environment variable. First supported in 3.0.0.</dd>
<dt>
RSYNC_OLD_ARGS
</dt>
<dd>Specify a &#34;1&#34; if you want the <strong>–old-args</strong> option to
be enabled by default, a &#34;2&#34; (or more) if you want it to be enabled in
the repeated-option state, or a &#34;0&#34; to make sure that it is disabled
by default. When this environment variable is set to a non-zero value,
it supersedes the <strong>RSYNC_PROTECT_ARGS</strong> variable.

This variable is ignored if <strong>–old-args</strong>, <strong>–no-old-args</strong>, or
<strong>–secluded-args</strong> is specified on the command line.

First supported in 3.2.4.</dd>
<dt>
RSYNC_PROTECT_ARGS
</dt>
<dd>Specify a non-zero numeric value if you want the
<strong>–secluded-args</strong> option to be enabled by default, or a zero value to
make sure that it is disabled by default.

This variable is ignored if <strong>–secluded-args</strong>, <strong>–no-secluded-args</strong>,
or <strong>–old-args</strong> is specified on the command line.

First supported in 3.1.0. Starting in 3.2.4, this variable is ignored
if <strong>RSYNC_OLD_ARGS</strong> is set to a non-zero value.</dd>
<dt>
RSYNC_RSH
</dt>
<dd>This environment variable allows you to override the
default shell used as the transport for rsync. Command line options
are permitted after the command name, just as in the <strong>–rsh</strong> (<strong>-e</strong>)
option.</dd>
<dt>
RSYNC_PROXY
</dt>
<dd>This environment variable allows you to redirect your
rsync client to use a web proxy when connecting to an rsync daemon.
You should set <strong>RSYNC_PROXY</strong> to a hostname:port pair.</dd>
<dt>
RSYNC_PASSWORD
</dt>
<dd>This environment variable allows you to set the
password for an rsync <strong>daemon</strong> connection, which avoids the password
prompt. Note that this does <strong>not</strong> supply a password to a remote shell
transport such as ssh (consult its documentation for how to do that).</dd>
<dt>
USER or LOGNAME
</dt>
<dd>The USER or LOGNAME environment variables are used
to determine the default username sent to an rsync daemon. If neither
is set, the username defaults to &#34;nobody&#34;. If both are set, <strong>USER</strong>
takes precedence.</dd>
<dt>
RSYNC_PARTIAL_DIR
</dt>
<dd>This environment variable specifies the directory
to use for a <strong>–partial</strong> transfer without implying that partial
transfers be enabled. See the <strong>–partial-dir</strong> option for full details.</dd>
<dt>
RSYNC_COMPRESS_LIST
</dt>
<dd>This environment variable allows you to
customize the negotiation of the compression algorithm by specifying
an alternate order or a reduced list of names. Use the command <strong>rsync
–version</strong> to see the available compression names. See the
<strong>–compress</strong> option for full details.</dd>
<dt>
RSYNC_CHECKSUM_LIST
</dt>
<dd>This environment variable allows you to
customize the negotiation of the checksum algorithm by specifying an
alternate order or a reduced list of names. Use the command <strong>rsync
–version</strong> to see the available checksum names. See the
<strong>–checksum-choice</strong> option for full details.</dd>
<dt>
RSYNC_MAX_ALLOC
</dt>
<dd>This environment variable sets an allocation
maximum as if you had used the <strong>–max-alloc</strong> option.</dd>
<dt>
RSYNC_PORT
</dt>
<dd>This environment variable is not read by rsync, but is
instead set in its sub-environment when rsync is running the remote
shell in combination with a daemon connection. This allows a script
such as <strong>rsync-ssl</strong> to be able to know the port number that the user
specified on the command line.</dd>
<dt>
HOME
</dt>
<dd>This environment variable is used to find the user&#39;s default
.cvsignore file.</dd>
<dt>
RSYNC_CONNECT_PROG
</dt>
<dd>This environment variable is mainly used in
debug setups to set the program to use when making a daemon
connection. See CONNECTING TO AN RSYNC DAEMON for full details.</dd>
<dt>
RSYNC_SHELL
</dt>
<dd>This environment variable is mainly used in debug
setups to set the program to use to run the program specified by
<strong>RSYNC_CONNECT_PROG</strong>. See CONNECTING TO AN RSYNC DAEMON for full
details.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-35" class="outline-2">
<h2 id="headline-35">
FILES
</h2>
<div id="outline-text-headline-35" class="outline-text-2">
<p>/etc/rsyncd.conf or rsyncd.conf</p>
</div>
</div>
<div id="outline-container-headline-36" class="outline-2">
<h2 id="headline-36">
SEE ALSO
</h2>
<div id="outline-text-headline-36" class="outline-text-2">
<p>*rsync-ssl*(1), *rsyncd.conf*(5), *rrsync*(1)</p>
</div>
</div>
<div id="outline-container-headline-37" class="outline-2">
<h2 id="headline-37">
BUGS
</h2>
<div id="outline-text-headline-37" class="outline-text-2">
<ol>
<li value="15">Times are transferred as *nix time_t values.</li>
<li>When transferring to FAT filesystems rsync may re-sync unmodified
files. See the comments on the <strong>–modify-window</strong> option.</li>
<li>File permissions, devices, etc. are transferred as native numerical
values.</li>
<li>See also the comments on the <strong>–delete</strong> option.</li>
</ol>
<p>Please report bugs! See the web site at <a href="https://rsync.samba.org/">https://rsync.samba.org/</a>.</p>
</div>
</div>
<div id="outline-container-headline-38" class="outline-2">
<h2 id="headline-38">
VERSION
</h2>
<div id="outline-text-headline-38" class="outline-text-2">
<p>This manpage is current for version 3.3.0 of rsync.</p>
</div>
</div>
<div id="outline-container-headline-39" class="outline-2">
<h2 id="headline-39">
INTERNAL OPTIONS
</h2>
<div id="outline-text-headline-39" class="outline-text-2">
<p>The options <strong>–server</strong> and <strong>–sender</strong> are used internally by rsync, and
should never be typed by a user under normal circumstances. Some
awareness of these options may be needed in certain scenarios, such as
when setting up a login that can only run an rsync command. For
instance, the support directory of the rsync distribution has an example
script named rrsync (for restricted rsync) that can be used with a
restricted ssh login.</p>
</div>
</div>
<div id="outline-container-headline-40" class="outline-2">
<h2 id="headline-40">
CREDITS
</h2>
<div id="outline-text-headline-40" class="outline-text-2">
<p>Rsync is distributed under the GNU General Public License. See the file
COPYING for details.</p>
<p>
An rsync web site is available at <a href="https://rsync.samba.org/">https://rsync.samba.org/</a>. The
site includes an FAQ-O-Matic which may cover questions unanswered by
this manual page.</p>
<p>
The rsync github project is <a href="https://github.com/WayneD/rsync">https://github.com/WayneD/rsync</a>.</p>
<p>
We would be delighted to hear from you if you like this program. Please
contact the mailing-list at
<a href="mailto:rsync@lists.samba.org">rsync@lists.samba.org</a>.</p>
<p>
This program uses the excellent zlib compression library written by
Jean-loup Gailly and Mark Adler.</p>
</div>
</div>
<div id="outline-container-headline-41" class="outline-2">
<h2 id="headline-41">
THANKS
</h2>
<div id="outline-text-headline-41" class="outline-text-2">
<p>Special thanks go out to: John Van Essen, Matt McCutchen, Wesley W.
Terpstra, David Dykstra, Jos Backus, Sebastian Krahmer, Martin Pool, and
our gone-but-not-forgotten compadre, J.W. Schultz.</p>
<p>
Thanks also to Richard Brent, Brendan Mackay, Bill Waite, Stephen
Rothwell and David Bell. I&#39;ve probably missed some people, my apologies
if I have.</p>
</div>
</div>
<div id="outline-container-headline-42" class="outline-2">
<h2 id="headline-42">
AUTHOR
</h2>
<div id="outline-text-headline-42" class="outline-text-2">
<p>Rsync was originally written by Andrew Tridgell and Paul Mackerras. Many
people have later contributed to it. It is currently maintained by Wayne
Davison.</p>
<p>
Mailing lists for support and development are available at
<a href="https://lists.samba.org/">https://lists.samba.org/</a>.</p>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.js"></script>
    </body>
</html>
