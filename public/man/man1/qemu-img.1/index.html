<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - qemu-img.1 | Technical Notes</title>

    <link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - qemu-img.1</h1>
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
NAME
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>qemu-img - QEMU disk image utility</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
SYNOPSIS
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p><strong>qemu-img</strong> [/standard options/] <em>command</em> [/command options/]</p>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
DESCRIPTION
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p>qemu-img allows you to create, convert and modify images offline. It can
handle all image formats supported by QEMU.</p>
<p>
<strong>Warning:</strong> Never use qemu-img to modify images in use by a running
virtual machine or any other process; this may destroy the image. Also,
be aware that querying an image that is being modified by another
process may encounter inconsistent state.</p>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
OPTIONS
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<p>Standard options:</p>
<blockquote>
<dl>
<dt>
<strong>-h, –help</strong>
</dt>
<dd>Display this help and exit</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-V, –version</strong>
</dt>
<dd>Display version information and exit</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-T, –trace [[enable=]PATTERN][,events=FILE][,file=FILE]</strong>
</dt>
<dd>
<p>Specify
tracing options.</p>
<p>
<strong>[enable=]PATTERN</strong></p>
<blockquote>
<p>Immediately enable events matching <em>PATTERN</em> (either event name or a
globbing pattern). This option is only available if QEMU has been
compiled with the <strong>simple</strong>, <strong>log</strong> or <strong>ftrace</strong> tracing backend. To
specify multiple events or patterns, specify the <strong>-trace</strong> option
multiple times.</p>
<p>
Use <strong>-trace help</strong> to print a list of names of trace points.</p>
</blockquote>
</dd>
</dl>
<p><strong>events=FILE</strong></p>
<blockquote>
<blockquote>
<p>Immediately enable events listed in <em>FILE</em>. The file must contain one
event name (as listed in the <strong>trace-events-all</strong> file) per line; globbing
patterns are accepted too. This option is only available if QEMU has
been compiled with the <strong>simple</strong>, <strong>log</strong> or <strong>ftrace</strong> tracing backend.</p>
</blockquote>
</blockquote>
<p>
<strong>file=FILE</strong></p>
<blockquote>
<blockquote>
<p>Log output traces to <em>FILE</em>. This option is only available if QEMU has
been compiled with the <strong>simple</strong> tracing backend.</p>
</blockquote>
</blockquote>
</blockquote>
<p>
The following commands are supported:</p>
<blockquote>
<ul>
<li><strong>amend [–object OBJECTDEF] [–image-opts] [-p] [-q] [-f FMT] [-t
CACHE] [–force] -o OPTIONS FILENAME</strong> :: </li>
</ul>
<blockquote>
<ul>
<li>*bench [-c COUNT] [-d DEPTH] [-f FMT]
[–flush-interval=FLUSH_INTERVAL] [-i AIO] [-n] [–no-drain] [-o
OFFSET] [–pattern=PATTERN] [-q] [-s BUFFER_SIZE] [-S STEP_SIZE] [-t
CACHE] [-w] [-U] FILENAME* :: </li>
</ul>
<blockquote>
<ul>
<li>*bitmap (–merge SOURCE | –add | –remove | –clear | –enable |
–disable)… [-b SOURCE_FILE [-F SOURCE_FMT]] [-g GRANULARITY]
[–object OBJECTDEF] [–image-opts | -f FMT] FILENAME BITMAP* :: </li>
</ul>
<blockquote>
<ul>
<li><strong>check [–object OBJECTDEF] [–image-opts] [-q] [-f FMT]
[–output=OFMT] [-r [leaks | all]] [-T SRC_CACHE] [-U] FILENAME</strong> :: </li>
</ul>
<blockquote>
<ul>
<li><strong>commit [–object OBJECTDEF] [–image-opts] [-q] [-f FMT] [-t CACHE]
[-b BASE] [-r RATE_LIMIT] [-d] [-p] FILENAME</strong> :: </li>
</ul>
<blockquote>
<ul>
<li><strong>compare [–object OBJECTDEF] [–image-opts] [-f FMT] [-F FMT] [-T
SRC_CACHE] [-p] [-q] [-s] [-U] FILENAME1 FILENAME2</strong> :: </li>
</ul>
<blockquote>
<ul>
<li>*convert [–object OBJECTDEF] [–image-opts] [–target-image-opts]
[–target-is-zero] [–bitmaps] [-U] [-C] [-c] [-p] [-q] [-n] [-f FMT]
[-t CACHE] [-T SRC_CACHE] [-O OUTPUT_FMT] [-B BACKING_FILE [-F
BACKING_FMT]] [-o OPTIONS] [-l SNAPSHOT_PARAM] [-S SPARSE_SIZE] [-r
RATE_LIMIT] [-m NUM_COROUTINES] [-W] [–salvage] FILENAME [FILENAME2
[…]] OUTPUT_FILENAME* :: </li>
</ul>
<blockquote>
<ul>
<li><strong>create [–object OBJECTDEF] [-q] [-f FMT] [-b BACKING_FILE [-F
BACKING_FMT]] [-u] [-o OPTIONS] FILENAME [SIZE]</strong> :: </li>
</ul>
<blockquote>
<ul>
<li><strong>dd [–image-opts] [-U] [-f FMT] [-O OUTPUT_FMT] [bs=BLOCK_SIZE]
[count=BLOCKS] [skip=BLOCKS] if=INPUT of=OUTPUT</strong> :: </li>
</ul>
<blockquote>
<ul>
<li><strong>info [–object OBJECTDEF] [–image-opts] [-f FMT] [–output=OFMT]
[–backing-chain] [-U] FILENAME</strong> :: </li>
</ul>
<blockquote>
<ul>
<li>*map [–object OBJECTDEF] [–image-opts] [-f FMT]
[–start-offset=OFFSET] [–max-length=LEN] [–output=OFMT] [-U]
FILENAME* :: </li>
</ul>
<blockquote>
<ul>
<li>*measure [–output=OFMT] [-O OUTPUT_FMT] [-o OPTIONS] [–size N |
[–object OBJECTDEF] [–image-opts] [-f FMT] [-l SNAPSHOT_PARAM]
FILENAME]* :: </li>
</ul>
<blockquote>
<ul>
<li><strong>snapshot [–object OBJECTDEF] [–image-opts] [-U] [-q] [-l | -a
SNAPSHOT | -c SNAPSHOT | -d SNAPSHOT] FILENAME</strong> :: </li>
</ul>
<blockquote>
<ul>
<li>*rebase [–object OBJECTDEF] [–image-opts] [-U] [-q] [-f FMT] [-t
CACHE] [-T SRC_CACHE] [-p] [-u] [-c] -b BACKING_FILE [-F BACKING_FMT]
FILENAME* :: </li>
</ul>
<blockquote>
<ul>
<li><strong>resize [–object OBJECTDEF] [–image-opts] [-f FMT]
[–preallocation=PREALLOC] [-q] [–shrink] FILENAME [+ | -]SIZE</strong> :: </li>
</ul>
<p>Command parameters:</p>
<p>
<em>FILENAME</em> is a disk image filename.</p>
<p>
<em>FMT</em> is the disk image format. It is guessed automatically in most
cases. See below for a description of the supported disk formats.</p>
<p>
<em>SIZE</em> is the disk image size in bytes. Optional suffixes <strong>k</strong> or <strong>K</strong>
(kilobyte, 1024) <strong>M</strong> (megabyte, 1024k) and <strong>G</strong> (gigabyte, 1024M) and T
(terabyte, 1024G) are supported. <strong>b</strong> is ignored.</p>
<p>
<em>OUTPUT_FILENAME</em> is the destination disk image filename.</p>
<p>
<em>OUTPUT_FMT</em> is the destination format.</p>
<p>
<em>OPTIONS</em> is a comma separated list of format specific options in a
name=value format. Use <strong>-o help</strong> for an overview of the options
supported by the used format or see the format descriptions below for
details.</p>
<p>
<em>SNAPSHOT_PARAM</em> is param used for internal snapshot, format is
&#39;snapshot.id=[ID],snapshot.name=[NAME]&#39; or &#39;[ID_OR_NAME]&#39;.</p>
<blockquote>
<dl>
<dt>
<strong>–object OBJECTDEF</strong>
</dt>
<dd>is a QEMU user creatable object definition.
See the <strong>qemu(1)</strong> manual page for a description of the object
properties. The most common object type is a <strong>secret</strong>, which is used
to supply passwords and/or encryption keys.</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>–image-opts</strong>
</dt>
<dd>Indicates that the source <em>FILENAME</em> parameter is to
be interpreted as a full option string, not a plain filename. This
parameter is mutually exclusive with the <em>-f</em> parameter.</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>–target-image-opts</strong>
</dt>
<dd>Indicates that the OUTPUT_FILENAME
parameter(s) are to be interpreted as a full option string, not a
plain filename. This parameter is mutually exclusive with the <em>-O</em>
parameters. It is currently required to also use the <em>-n</em> parameter to
skip image creation. This restriction may be relaxed in a future
release.</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>–force-share (-U)</strong>
</dt>
<dd>If specified, <strong>qemu-img</strong> will open the image
in shared mode, allowing other QEMU processes to open it in write
mode. For example, this can be used to get the image information (with
&#39;info&#39; subcommand) when the image is used by a running guest. Note
that this could produce inconsistent results because of concurrent
metadata changes, etc. This option is only allowed when opening images
in read-only mode.</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>–backing-chain</strong>
</dt>
<dd>Will enumerate information about backing files in
a disk image chain. Refer below for further description.</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-c</strong>
</dt>
<dd>Indicates that target image must be compressed (qcow/qcow2 and
vmdk with streamOptimized subformat only).

For qcow2, the compression algorithm can be specified with the <strong>-o</strong>
compression_type=… option (see below).</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-h</strong>
</dt>
<dd>With or without a command, shows help and lists the supported
formats.</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-p</strong>
</dt>
<dd>Display progress bar (compare, convert and rebase commands
only). If the <em>-p</em> option is not used for a command that supports it,
the progress is reported when the process receives a <strong>SIGUSR1</strong> or
<strong>SIGINFO</strong> signal.</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-q</strong>
</dt>
<dd>Quiet mode - do not print any output (except errors). There&#39;s
no progress bar in case both <em>-q</em> and <em>-p</em> options are used.</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-S SIZE</strong>
</dt>
<dd>Indicates the consecutive number of bytes that must
contain only zeros for <strong>qemu-img</strong> to create a sparse image during
conversion. This value is rounded down to the nearest 512 bytes. You
may use the common size suffixes like <strong>k</strong> for kilobytes.</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-t CACHE</strong>
</dt>
<dd>Specifies the cache mode that should be used with the
(destination) file. See the documentation of the emulator&#39;s <strong>-drive
cache=…</strong> option for allowed values.</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-T SRC_CACHE</strong>
</dt>
<dd>Specifies the cache mode that should be used with
the source file(s). See the documentation of the emulator&#39;s <strong>-drive
cache=…</strong> option for allowed values.</dd>
</dl>
</blockquote>
<p>
Parameters to compare subcommand:</p>
<blockquote>
<dl>
<dt>
<strong>-f</strong>
</dt>
<dd>First image format</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-F</strong>
</dt>
<dd>Second image format</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-s</strong>
</dt>
<dd>Strict mode - fail on different image size or sector
allocation</dd>
</dl>
</blockquote>
<p>
Parameters to convert subcommand:</p>
<blockquote>
<dl>
<dt>
<strong>–bitmaps</strong>
</dt>
<dd>Additionally copy all persistent bitmaps from the top
layer of the source</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-n</strong>
</dt>
<dd>Skip the creation of the target volume</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-m</strong>
</dt>
<dd>Number of parallel coroutines for the convert process</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-W</strong>
</dt>
<dd>Allow out-of-order writes to the destination. This option
improves performance, but is only recommended for preallocated devices
like host devices or other raw block devices.</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-C</strong>
</dt>
<dd>Try to use copy offloading to move data from source image to
target. This may improve performance if the data is remote, such as
with NFS or iSCSI backends, but will not automatically sparsify zero
sectors, and may result in a fully allocated target image depending on
the host support for getting allocation information.</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-r</strong>
</dt>
<dd>Rate limit for the convert process</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>–salvage</strong>
</dt>
<dd>Try to ignore I/O errors when reading. Unless in quiet
mode (<strong>-q</strong>), errors will still be printed. Areas that cannot be read
from the source will be treated as containing only zeroes.</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>–target-is-zero</strong>
</dt>
<dd>Assume that reading the destination image will
always return zeros. This parameter is mutually exclusive with a
destination image that has a backing file. It is required to also use
the <strong>-n</strong> parameter to skip image creation.</dd>
</dl>
</blockquote>
<p>
Parameters to dd subcommand:</p>
<blockquote>
<dl>
<dt>
<strong>bs=BLOCK_SIZE</strong>
</dt>
<dd>Defines the block size</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>count=BLOCKS</strong>
</dt>
<dd>Sets the number of input blocks to copy</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>if=INPUT</strong>
</dt>
<dd>Sets the input file</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>of=OUTPUT</strong>
</dt>
<dd>Sets the output file</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>skip=BLOCKS</strong>
</dt>
<dd>Sets the number of input blocks to skip</dd>
</dl>
</blockquote>
<p>
Parameters to snapshot subcommand:</p>
<blockquote>
<dl>
<dt>
<strong>snapshot</strong>
</dt>
<dd>Is the name of the snapshot to create, apply or delete</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-a</strong>
</dt>
<dd>Applies a snapshot (revert disk to saved state)</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-c</strong>
</dt>
<dd>Creates a snapshot</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-d</strong>
</dt>
<dd>Deletes a snapshot</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>-l</strong>
</dt>
<dd>Lists all snapshots in the given image</dd>
</dl>
</blockquote>
<p>
Command description:</p>
<blockquote>
<ul>
<li><strong>amend [–object OBJECTDEF] [–image-opts] [-p] [-q] [-f FMT] [-t
CACHE] [–force] -o OPTIONS FILENAME</strong> :: Amends the image format
specific <em>OPTIONS</em> for the image file <em>FILENAME</em>. Not all file formats
support this operation.

The set of options that can be amended are dependent on the image
format, but note that amending the backing chain relationship should
instead be performed with <strong>qemu-img rebase</strong>.

–force allows some unsafe operations. Currently for -f luks, it
allows to erase the last encryption key, and to overwrite an active
encryption key.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>*bench [-c COUNT] [-d DEPTH] [-f FMT]
[–flush-interval=FLUSH_INTERVAL] [-i AIO] [-n] [–no-drain] [-o
OFFSET] [–pattern=PATTERN] [-q] [-s BUFFER_SIZE] [-S STEP_SIZE] [-t
CACHE] [-w] [-U] FILENAME* :: Run a simple sequential I/O benchmark on
the specified image. If <strong>-w</strong> is specified, a write test is performed,
otherwise a read test is performed.

A total number of <em>COUNT</em> I/O requests is performed, each
<em>BUFFER_SIZE</em> bytes in size, and with <em>DEPTH</em> requests in parallel.
The first request starts at the position given by <em>OFFSET</em>, each
following request increases the current position by <em>STEP_SIZE</em>. If
<em>STEP_SIZE</em> is not given, <em>BUFFER_SIZE</em> is used for its value.

If <em>FLUSH_INTERVAL</em> is specified for a write test, the request queue
is drained and a flush is issued before new writes are made whenever
the number of remaining requests is a multiple of <em>FLUSH_INTERVAL</em>. If
additionally <strong>–no-drain</strong> is specified, a flush is issued without
draining the request queue first.

if <strong>-i</strong> is specified, <em>AIO</em> option can be used to specify different
AIO backends: <strong>threads</strong>, <strong>native</strong> or <strong>io_uring</strong>.

If <strong>-n</strong> is specified, the native AIO backend is used if possible. On
Linux, this option only works if <strong>-t none</strong> or <strong>-t directsync</strong> is
specified as well.

For write tests, by default a buffer filled with zeros is written.
This can be overridden with a pattern byte specified by <em>PATTERN</em>.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>*bitmap (–merge SOURCE | –add | –remove | –clear | –enable |
–disable)… [-b SOURCE_FILE [-F SOURCE_FMT]] [-g GRANULARITY]
[–object OBJECTDEF] [–image-opts | -f FMT] FILENAME
BITMAP* :: Perform one or more modifications of the persistent bitmap
<em>BITMAP</em> in the disk image <em>FILENAME</em>. The various modifications are:

<strong>–add</strong> to create <em>BITMAP</em>, enabled to record future edits.

<strong>–remove</strong> to remove <em>BITMAP</em>.

<strong>–clear</strong> to clear <em>BITMAP</em>.

<strong>–enable</strong> to change <em>BITMAP</em> to start recording future edits.

<strong>–disable</strong> to change <em>BITMAP</em> to stop recording future edits.

<strong>–merge</strong> to merge the contents of the <em>SOURCE</em> bitmap into <em>BITMAP</em>.

Additional options include <strong>-g</strong> which sets a non-default <em>GRANULARITY</em>
for <strong>–add</strong>, and <strong>-b</strong> and <strong>-F</strong> which select an alternative source file
for all <em>SOURCE</em> bitmaps used by <strong>–merge</strong>.

To see what bitmaps are present in an image, use <strong>qemu-img info</strong>.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>
<p>*check [–object OBJECTDEF] [–image-opts] [-q] [-f FMT]
[–output=OFMT] [-r [leaks | all]] [-T SRC_CACHE] [-U]
FILENAME* :: Perform a consistency check on the disk image <em>FILENAME</em>.
The command can output in the format <em>OFMT</em> which is either <strong>human</strong> or
<strong>json</strong>. The JSON output is an object of QAPI type <strong>ImageCheck</strong>.</p>
<p>
If <strong>-r</strong> is specified, qemu-img tries to repair any inconsistencies
found during the check. <strong>-r leaks</strong> repairs only cluster leaks, whereas
<strong>-r all</strong> fixes all kinds of errors, with a higher risk of choosing the
wrong fix or hiding corruption that has already occurred.</p>
<p>
Only the formats <strong>qcow2</strong>, <strong>qed</strong>, <strong>parallels</strong>, <strong>vhdx</strong>, <strong>vmdk</strong> and <strong>vdi</strong>
support consistency checks.</p>
<p>
In case the image does not have any inconsistencies, check exits with
<strong>0</strong>. Other exit codes indicate the kind of inconsistency found or if
another error occurred. The following table summarizes all exit codes
of the check subcommand:</p>
<dl>
<dt>
<strong>0</strong>
</dt>
<dd>Check completed, the image is (now) consistent</dd>
<dt>
<strong>1</strong>
</dt>
<dd>Check not completed because of internal errors</dd>
<dt>
<strong>2</strong>
</dt>
<dd>Check completed, image is corrupted</dd>
<dt>
<strong>3</strong>
</dt>
<dd>Check completed, image has leaked clusters, but is not
corrupted</dd>
<dt>
<strong>63</strong>
</dt>
<dd>Checks are not supported by the image format</dd>
</dl>
</li>
</ul>
<p>If <strong>-r</strong> is specified, exit codes representing the image state refer to
the state after (the attempt at) repairing it. That is, a successful <strong>-r
all</strong> will yield the exit code 0, independently of the image state
before.</p>
</blockquote>
<blockquote>
<ul>
<li><strong>commit [–object OBJECTDEF] [–image-opts] [-q] [-f FMT] [-t CACHE]
[-b BASE] [-r RATE_LIMIT] [-d] [-p] FILENAME</strong> :: Commit the changes
recorded in <em>FILENAME</em> in its base image or backing file. If the
backing file is smaller than the snapshot, then the backing file will
be resized to be the same size as the snapshot. If the snapshot is
smaller than the backing file, the backing file will not be truncated.
If you want the backing file to match the size of the smaller
snapshot, you can safely truncate it yourself once the commit
operation successfully completes.

The image <em>FILENAME</em> is emptied after the operation has succeeded. If
you do not need <em>FILENAME</em> afterwards and intend to drop it, you may
skip emptying <em>FILENAME</em> by specifying the <strong>-d</strong> flag.

If the backing chain of the given image file <em>FILENAME</em> has more than
one layer, the backing file into which the changes will be committed
may be specified as <em>BASE</em> (which has to be part of <em>FILENAME</em>&#39;s
backing chain). If <em>BASE</em> is not specified, the immediate backing file
of the top image (which is <em>FILENAME</em>) will be used. Note that after a
commit operation all images between <em>BASE</em> and the top image will be
invalid and may return garbage data when read. For this reason, <strong>-b</strong>
implies <strong>-d</strong> (so that the top image stays valid).

The rate limit for the commit process is specified by <strong>-r</strong>.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>
<p><strong>compare [–object OBJECTDEF] [–image-opts] [-f FMT] [-F FMT] [-T
SRC_CACHE] [-p] [-q] [-s] [-U] FILENAME1 FILENAME2</strong> :: Check if two
images have the same content. You can compare images with different
format or settings.</p>
<p>
The format is probed unless you specify it by <strong>-f</strong> (used for
<em>FILENAME1</em>) and/or <strong>-F</strong> (used for <em>FILENAME2</em>) option.</p>
<p>
By default, images with different size are considered identical if the
larger image contains only unallocated and/or zeroed sectors in the
area after the end of the other image. In addition, if any sector is
not allocated in one image and contains only zero bytes in the second
one, it is evaluated as equal. You can use Strict mode by specifying
the <strong>-s</strong> option. When compare runs in Strict mode, it fails in case
image size differs or a sector is allocated in one image and is not
allocated in the second one.</p>
<p>
By default, compare prints out a result message. This message displays
information that both images are same or the position of the first
different byte. In addition, result message can report different image
size in case Strict mode is used.</p>
<p>
Compare exits with <strong>0</strong> in case the images are equal and with <strong>1</strong> in
case the images differ. Other exit codes mean an error occurred during
execution and standard error output should contain an error message.
The following table summarizes all exit codes of the compare
subcommand:</p>
<dl>
<dt>
<strong>0</strong>
</dt>
<dd>Images are identical (or requested help was printed)</dd>
<dt>
<strong>1</strong>
</dt>
<dd>Images differ</dd>
<dt>
<strong>2</strong>
</dt>
<dd>Error on opening an image</dd>
<dt>
<strong>3</strong>
</dt>
<dd>Error on checking a sector allocation</dd>
<dt>
<strong>4</strong>
</dt>
<dd>Error on reading data</dd>
</dl>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>*convert [–object OBJECTDEF] [–image-opts] [–target-image-opts]
[–target-is-zero] [–bitmaps [–skip-broken-bitmaps]] [-U] [-C] [-c]
[-p] [-q] [-n] [-f FMT] [-t CACHE] [-T SRC_CACHE] [-O OUTPUT_FMT] [-B
BACKING_FILE [-F BACKING_FMT]] [-o OPTIONS] [-l SNAPSHOT_PARAM] [-S
SPARSE_SIZE] [-r RATE_LIMIT] [-m NUM_COROUTINES] [-W] FILENAME
[FILENAME2 […]] OUTPUT_FILENAME* :: Convert the disk image
<em>FILENAME</em> or a snapshot <em>SNAPSHOT_PARAM</em> to disk image
<em>OUTPUT_FILENAME</em> using format <em>OUTPUT_FMT</em>. It can be optionally
compressed (<strong>-c</strong> option) or use any format specific options like
encryption (<strong>-o</strong> option).

Only the formats <strong>qcow</strong> and <strong>qcow2</strong> support compression. The
compression is read-only. It means that if a compressed sector is
rewritten, then it is rewritten as uncompressed data.

Image conversion is also useful to get smaller image when using a
growable format such as <strong>qcow</strong>: the empty sectors are detected and
suppressed from the destination image.

<em>SPARSE_SIZE</em> indicates the consecutive number of bytes (defaults to
4k) that must contain only zeros for <strong>qemu-img</strong> to create a sparse
image during conversion. If <em>SPARSE_SIZE</em> is 0, the source will not be
scanned for unallocated or zero sectors, and the destination image
will always be fully allocated.

You can use the <em>BACKING_FILE</em> option to force the output image to be
created as a copy on write image of the specified base image; the
<em>BACKING_FILE</em> should have the same content as the input&#39;s base image,
however the path, image format (as given by <em>BACKING_FMT</em>), etc may
differ.

If a relative path name is given, the backing file is looked up
relative to the directory containing <em>OUTPUT_FILENAME</em>.

If the <strong>-n</strong> option is specified, the target volume creation will be
skipped. This is useful for formats such as <strong>rbd</strong> if the target volume
has already been created with site specific options that cannot be
supplied through <strong>qemu-img</strong>.

Out of order writes can be enabled with <strong>-W</strong> to improve performance.
This is only recommended for preallocated devices like host devices or
other raw block devices. Out of order write does not work in
combination with creating compressed images.

<em>NUM_COROUTINES</em> specifies how many coroutines work in parallel during
the convert process (defaults to 8).

Use of <strong>–bitmaps</strong> requests that any persistent bitmaps present in the
original are also copied to the destination. If any bitmap is
inconsistent in the source, the conversion will fail unless
<strong>–skip-broken-bitmaps</strong> is also specified to copy only the consistent
bitmaps.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>create [–object OBJECTDEF] [-q] [-f FMT] [-b BACKING_FILE [-F
BACKING_FMT]] [-u] [-o OPTIONS] FILENAME [SIZE]</strong> :: Create the new
disk image <em>FILENAME</em> of size <em>SIZE</em> and format <em>FMT</em>. Depending on
the file format, you can add one or more <em>OPTIONS</em> that enable
additional features of this format.

If the option <em>BACKING_FILE</em> is specified, then the image will record
only the differences from <em>BACKING_FILE</em>. No size needs to be
specified in this case. <em>BACKING_FILE</em> will never be modified unless
you use the <strong>commit</strong> monitor command (or <strong>qemu-img commit</strong>).

If a relative path name is given, the backing file is looked up
relative to the directory containing <em>FILENAME</em>.

Note that a given backing file will be opened to check that it is
valid. Use the <strong>-u</strong> option to enable unsafe backing file mode, which
means that the image will be created even if the associated backing
file cannot be opened. A matching backing file must be created or
additional options be used to make the backing file specification
valid when you want to use an image created this way.

The size can also be specified using the <em>SIZE</em> option with <strong>-o</strong>, it
doesn&#39;t need to be specified separately in this case.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>dd [–image-opts] [-U] [-f FMT] [-O OUTPUT_FMT] [bs=BLOCK_SIZE]
[count=BLOCKS] [skip=BLOCKS] if=INPUT of=OUTPUT</strong> :: dd copies from
<em>INPUT</em> file to <em>OUTPUT</em> file converting it from <em>FMT</em> format to
<em>OUTPUT_FMT</em> format.

The data is by default read and written using blocks of 512 bytes but
can be modified by specifying <em>BLOCK_SIZE</em>. If count=/BLOCKS/ is
specified dd will stop reading input after reading <em>BLOCKS</em> input
blocks.

The size syntax is similar to <strong>dd(1)</strong>&#39;s size syntax.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>
<p><strong>info [–object OBJECTDEF] [–image-opts] [-f FMT] [–output=OFMT]
[–backing-chain] [-U] FILENAME</strong> :: Give information about the disk
image <em>FILENAME</em>. Use it in particular to know the size reserved on
disk which can be different from the displayed size. If VM snapshots
are stored in the disk image, they are displayed too.</p>
<p>
If a disk image has a backing file chain, information about each disk
image in the chain can be recursively enumerated by using the option
<strong>–backing-chain</strong>.</p>
<p>
For instance, if you have an image chain like:</p>
<blockquote>
<pre class="example">
base.qcow2 &lt;- snap1.qcow2 &lt;- snap2.qcow2
</pre>
</blockquote>
</li>
</ul>
<p>To enumerate information about each disk image in the above chain,
starting from top to base, do:</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-img info --backing-chain snap2.qcow2
</pre>
</blockquote>
</blockquote>
<p>
The command can output in the format <em>OFMT</em> which is either <strong>human</strong> or
<strong>json</strong>. The JSON output is an object of QAPI type <strong>ImageInfo</strong>; with
<strong>–backing-chain</strong>, it is an array of <strong>ImageInfo</strong> objects.</p>
<p>
<strong>–output=human</strong> reports the following information (for every image in
the chain):</p>
<blockquote>
<dl>
<dt>
<strong><em>image</em></strong>
</dt>
<dd>The image file name</dd>
<dt>
<strong><em>file</em> format</strong>
</dt>
<dd>The image format</dd>
<dt>
<strong><em>virtual</em> size</strong>
</dt>
<dd>The size of the guest disk</dd>
<dt>
<strong><em>disk</em> size</strong>
</dt>
<dd>How much space the image file occupies on the host
file system (may be shown as 0 if this information is unavailable,
e.g. because there is no file system)</dd>
<dt>
<strong><em>cluster_size</em></strong>
</dt>
<dd>Cluster size of the image format, if applicable</dd>
<dt>
<strong><em>encrypted</em></strong>
</dt>
<dd>Whether the image is encrypted (only present if so)</dd>
<dt>
<strong><em>cleanly</em> shut down</strong>
</dt>
<dd>This is shown as <strong>no</strong> if the image is dirty
and will have to be auto-repaired the next time it is opened in qemu.</dd>
<dt>
<strong><em>backing</em> file</strong>
</dt>
<dd>The backing file name, if present</dd>
<dt>
<strong><em>backing</em> file format</strong>
</dt>
<dd>The format of the backing file, if the
image enforces it</dd>
<dt>
<strong><em>Snapshot</em> list</strong>
</dt>
<dd>A list of all internal snapshots</dd>
<dt>
<strong><em>Format</em> specific information</strong>
</dt>
<dd>Further information whose structure
depends on the image format. This section is a textual representation
of the respective <strong>ImageInfoSpecific*</strong> QAPI object (e.g.
<strong>ImageInfoSpecificQCow2</strong> for qcow2 images).</dd>
</dl>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>
<p>*map [–object OBJECTDEF] [–image-opts] [-f FMT]
[–start-offset=OFFSET] [–max-length=LEN] [–output=OFMT] [-U]
FILENAME* :: Dump the metadata of image <em>FILENAME</em> and its backing
file chain. In particular, this commands dumps the allocation state of
every sector of <em>FILENAME</em>, together with the topmost file that
allocates it in the backing file chain.</p>
<p>
Two option formats are possible. The default format (<strong>human</strong>) only
dumps known-nonzero areas of the file. Known-zero parts of the file
are omitted altogether, and likewise for parts that are not allocated
throughout the chain. <strong>qemu-img</strong> output will identify a file from
where the data can be read, and the offset in the file. Each line will
include four fields, the first three of which are hexadecimal numbers.
For example the first line of:</p>
<blockquote>
<pre class="example">
Offset          Length          Mapped to       File
0               0x20000         0x50000         /tmp/overlay.qcow2
0x100000        0x10000         0x95380000      /tmp/backing.qcow2
</pre>
</blockquote>
</li>
</ul>
<p>means that 0x20000 (131072) bytes starting at offset 0 in the image are
available in /tmp/overlay.qcow2 (opened in <strong>raw</strong> format) starting at
offset 0x50000 (327680). Data that is compressed, encrypted, or
otherwise not available in raw format will cause an error if <strong>human</strong>
format is in use. Note that file names can include newlines, thus it is
not safe to parse this output format in scripts.</p>
<p>
The alternative format <strong>json</strong> will return an array of dictionaries in
JSON format. It will include similar information in the <strong>start</strong>,
<strong>length</strong>, <strong>offset</strong> fields; it will also include other more specific
information:</p>
<blockquote>
<ul>
<li>boolean field <strong>data</strong>: true if the sectors contain actual data, false
if the sectors are either unallocated or stored as optimized all-zero
clusters</li>
<li>boolean field <strong>zero</strong>: true if the data is known to read as zero</li>
<li>boolean field <strong>present</strong>: true if the data belongs to the backing
chain, false if rebasing the backing chain onto a deeper file would
pick up data from the deeper file;</li>
<li>integer field <strong>depth</strong>: the depth within the backing chain at which the
data was resolved; for example, a depth of 2 refers to the backing
file of the backing file of <em>FILENAME</em>.</li>
</ul>
</blockquote>
<p>
In JSON format, the <strong>offset</strong> field is optional; it is absent in cases
where <strong>human</strong> format would omit the entry or exit with an error. If
<strong>data</strong> is false and the <strong>offset</strong> field is present, the corresponding
sectors in the file are not yet in use, but they are preallocated.</p>
<p>
For more information, consult <strong>include/block/block.h</strong> in QEMU&#39;s source
code.</p>
</blockquote>
<blockquote>
<ul>
<li>
<p>*measure [–output=OFMT] [-O OUTPUT_FMT] [-o OPTIONS] [–size N |
[–object OBJECTDEF] [–image-opts] [-f FMT] [-l SNAPSHOT_PARAM]
FILENAME]* :: Calculate the file size required for a new image. This
information can be used to size logical volumes or SAN LUNs
appropriately for the image that will be placed in them. The values
reported are guaranteed to be large enough to fit the image. The
command can output in the format <em>OFMT</em> which is either <strong>human</strong> or
<strong>json</strong>. The JSON output is an object of QAPI type <strong>BlockMeasureInfo</strong>.</p>
<p>
If the size <em>N</em> is given then act as if creating a new empty image
file using <strong>qemu-img create</strong>. If <em>FILENAME</em> is given then act as if
converting an existing image file using <strong>qemu-img convert</strong>. The format
of the new file is given by <em>OUTPUT_FMT</em> while the format of an
existing file is given by <em>FMT</em>.</p>
<p>
A snapshot in an existing image can be specified using
<em>SNAPSHOT_PARAM</em>.</p>
<p>
The following fields are reported:</p>
<blockquote>
<pre class="example">
required size: 524288
fully allocated size: 1074069504
bitmaps size: 0
</pre>
</blockquote>
</li>
</ul>
<p>The <strong>required size</strong> is the file size of the new image. It may be smaller
than the virtual disk size if the image format supports compact
representation.</p>
<p>
The <strong>fully allocated size</strong> is the file size of the new image once data
has been written to all sectors. This is the maximum size that the image
file can occupy with the exception of internal snapshots, dirty bitmaps,
vmstate data, and other advanced image format features.</p>
<p>
The <strong>bitmaps size</strong> is the additional size required in order to copy
bitmaps from a source image in addition to the guest-visible data; the
line is omitted if either source or destination lacks bitmap support, or
0 if bitmaps are supported but there is nothing to copy.</p>
</blockquote>
<blockquote>
<ul>
<li><strong>snapshot [–object OBJECTDEF] [–image-opts] [-U] [-q] [-l | -a
SNAPSHOT | -c SNAPSHOT | -d SNAPSHOT] FILENAME</strong> :: List, apply, create
or delete snapshots in image <em>FILENAME</em>.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>
<p>*rebase [–object OBJECTDEF] [–image-opts] [-U] [-q] [-f FMT] [-t
CACHE] [-T SRC_CACHE] [-p] [-u] [-c] -b BACKING_FILE [-F BACKING_FMT]
FILENAME* :: Changes the backing file of an image. Only the formats
<strong>qcow2</strong> and <strong>qed</strong> support changing the backing file.</p>
<p>
The backing file is changed to <em>BACKING_FILE</em> and (if the image format
of <em>FILENAME</em> supports this) the backing file format is changed to
<em>BACKING_FMT</em>. If <em>BACKING_FILE</em> is specified as &#34;&#34; (the empty
string), then the image is rebased onto no backing file (i.e. it will
exist independently of any backing file).</p>
<p>
If a relative path name is given, the backing file is looked up
relative to the directory containing <em>FILENAME</em>.</p>
<p>
<em>CACHE</em> specifies the cache mode to be used for <em>FILENAME</em>, whereas
<em>SRC_CACHE</em> specifies the cache mode for reading backing files.</p>
<p>
There are two different modes in which <strong>rebase</strong> can operate:</p>
<dl>
<dt>
<strong>Safe mode</strong>
</dt>
<dd>This is the default mode and performs a real rebase
operation. The new backing file may differ from the old one and
<strong>qemu-img rebase</strong> will take care of keeping the guest-visible
content of <em>FILENAME</em> unchanged.

In order to achieve this, any clusters that differ between
<em>BACKING_FILE</em> and the old backing file of <em>FILENAME</em> are merged
into <em>FILENAME</em> before actually changing the backing file. With the
<strong>-c</strong> option specified, the clusters which are being merged (but not
the entire <em>FILENAME</em> image) are compressed when written.

Note that the safe mode is an expensive operation, comparable to
converting an image. It only works if the old backing file still
exists.</dd>
<dt>
<strong>Unsafe mode</strong>
</dt>
<dd><strong>qemu-img</strong> uses the unsafe mode if <strong>-u</strong> is
specified. In this mode, only the backing file name and format of
<em>FILENAME</em> is changed without any checks on the file contents. The
user must take care of specifying the correct new backing file, or
the guest-visible content of the image will be corrupted.

This mode is useful for renaming or moving the backing file to
somewhere else. It can be used without an accessible old backing
file, i.e. you can use it to fix an image whose backing file has
already been moved/renamed.</dd>
</dl>
</li>
</ul>
<p>You can use <strong>rebase</strong> to perform a &#34;diff&#34; operation on two disk images.
This can be useful when you have copied or cloned a guest, and you want
to get back to a thin image on top of a template or base image.</p>
<p>
Say that <strong>base.img</strong> has been cloned as <strong>modified.img</strong> by copying it, and
that the <strong>modified.img</strong> guest has run so there are now some changes
compared to <strong>base.img</strong>. To construct a thin image called <strong>diff.qcow2</strong>
that contains just the differences, do:</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-img create -f qcow2 -b modified.img diff.qcow2
qemu-img rebase -b base.img diff.qcow2
</pre>
</blockquote>
</blockquote>
<p>
At this point, <strong>modified.img</strong> can be discarded, since <strong>base.img +
diff.qcow2</strong> contains the same information.</p>
</blockquote>
<blockquote>
<ul>
<li>*resize [–object OBJECTDEF] [–image-opts] [-f FMT]
[–preallocation=PREALLOC] [-q] [–shrink] FILENAME [+ |
-]SIZE* :: Change the disk image as if it had been created with
<em>SIZE</em>.

Before using this command to shrink a disk image, you MUST use file
system and partitioning tools inside the VM to reduce allocated file
systems and partition sizes accordingly. Failure to do so will result
in data loss!

When shrinking images, the <strong>–shrink</strong> option must be given. This
informs <strong>qemu-img</strong> that the user acknowledges all loss of data beyond
the truncated image&#39;s end.

After using this command to grow a disk image, you must use file
system and partitioning tools inside the VM to actually begin using
the new space on the device.

When growing an image, the <strong>–preallocation</strong> option may be used to
specify how the additional image area should be allocated on the host.
See the format description in the <em>Notes</em> section which values are
allowed. Using this option may result in slightly more data being
allocated than necessary.</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</div>
</div>
<div id="outline-container-headline-5" class="outline-2">
<h2 id="headline-5">
NOTES
</h2>
<div id="outline-text-headline-5" class="outline-text-2">
<p>Supported image file formats:</p>
<p>
<strong>raw</strong></p>
<blockquote>
<blockquote>
<p>Raw disk image format (default). This format has the advantage of being
simple and easily exportable to all other emulators. If your file system
supports <em>holes</em> (for example in ext2 or ext3 on Linux or NTFS on
Windows), then only the written sectors will reserve space. Use
<strong>qemu-img info</strong> to know the real size used by the image or <strong>ls -ls</strong> on
Unix/Linux.</p>
<p>
Supported options:</p>
<blockquote>
<dl>
<dt>
<strong><strong>preallocation</strong></strong>
</dt>
<dd>Preallocation mode (allowed values: <strong>off</strong>,
<strong>falloc</strong>, <strong>full</strong>). <strong>falloc</strong> mode preallocates space for image by
calling <strong>posix_fallocate()</strong>. <strong>full</strong> mode preallocates space for image
by writing data to underlying storage. This data may or may not be
zero, depending on the storage location.</dd>
</dl>
</blockquote>
</blockquote>
</blockquote>
<p>
<strong>qcow2</strong></p>
<blockquote>
<blockquote>
<p>QEMU image format, the most versatile format. Use it to have smaller
images (useful if your filesystem does not supports holes, for example
on Windows), optional AES encryption, zlib or zstd based compression and
support of multiple VM snapshots.</p>
<p>
Supported options:</p>
<blockquote>
<dl>
<dt>
<strong><strong>compat</strong></strong>
</dt>
<dd>Determines the qcow2 version to use. <strong>compat=0.10</strong> uses
the traditional image format that can be read by any QEMU since 0.10.
<strong>compat=1.1</strong> enables image format extensions that only QEMU 1.1 and
newer understand (this is the default). Amongst others, this includes
zero clusters, which allow efficient copy-on-read for sparse images.</dd>
<dt>
<strong><strong>backing_file</strong></strong>
</dt>
<dd>File name of a base image (see <strong>create</strong>
subcommand)</dd>
<dt>
<strong><strong>backing_fmt</strong></strong>
</dt>
<dd>Image format of the base image</dd>
<dt>
<strong><strong>compression_type</strong></strong>
</dt>
<dd>This option configures which compression
algorithm will be used for compressed clusters on the image. Note that
setting this option doesn&#39;t yet cause the image to actually receive
compressed writes. It is most commonly used with the <strong>-c</strong> option of
<strong>qemu-img convert</strong>, but can also be used with the <strong>compress</strong> filter
driver or backup block jobs with compression enabled.

Valid values are <strong>zlib</strong> and <strong>zstd</strong>. For images that use <strong>compat=0.10</strong>,
only <strong>zlib</strong> compression is available.</dd>
<dt>
<strong><strong>encryption</strong></strong>
</dt>
<dd>
<p>If this option is set to <strong>on</strong>, the image is
encrypted with 128-bit AES-CBC.</p>
<p>
The use of encryption in qcow and qcow2 images is considered to be
flawed by modern cryptography standards, suffering from a number of
design problems:</p>
<ul>
<li>The AES-CBC cipher is used with predictable initialization vectors
based on the sector number. This makes it vulnerable to chosen
plaintext attacks which can reveal the existence of encrypted data.</li>
<li>The user passphrase is directly used as the encryption key. A poorly
chosen or short passphrase will compromise the security of the
encryption.</li>
<li>In the event of the passphrase being compromised there is no way to
change the passphrase to protect data in any qcow images. The files
must be cloned, using a different encryption passphrase in the new
file. The original file must then be securely erased using a program
like shred, though even this is ineffective with many modern storage
technologies.</li>
<li>Initialization vectors used to encrypt sectors are based on the
guest virtual sector number, instead of the host physical sector.
When a disk image has multiple internal snapshots this means that
data in multiple physical sectors is encrypted with the same
initialization vector. With the CBC mode, this opens the possibility
of watermarking attacks if the attack can collect multiple sectors
encrypted with the same IV and some predictable data. Having
multiple qcow2 images with the same passphrase also exposes this
weakness since the passphrase is directly used as the key.</li>
</ul>
</dd>
</dl>
<p>Use of qcow / qcow2 encryption is thus strongly discouraged. Users are
recommended to use an alternative encryption technology such as the
Linux dm-crypt / LUKS system.</p>
<dl>
<dt>
<strong><strong>cluster_size</strong></strong>
</dt>
<dd>Changes the qcow2 cluster size (must be between
512 and 2M). Smaller cluster sizes can improve the image file size
whereas larger cluster sizes generally provide better performance.</dd>
<dt>
<strong><strong>preallocation</strong></strong>
</dt>
<dd>Preallocation mode (allowed values: <strong>off</strong>,
<strong>metadata</strong>, <strong>falloc</strong>, <strong>full</strong>). An image with preallocated metadata is
initially larger but can improve performance when the image needs to
grow. <strong>falloc</strong> and <strong>full</strong> preallocations are like the same options of
<strong>raw</strong> format, but sets up metadata also.</dd>
<dt>
<strong><strong>lazy_refcounts</strong></strong>
</dt>
<dd>If this option is set to <strong>on</strong>, reference count
updates are postponed with the goal of avoiding metadata I/O and
improving performance. This is particularly interesting with
<strong>cache=writethrough</strong> which doesn&#39;t batch metadata updates. The
tradeoff is that after a host crash, the reference count tables must
be rebuilt, i.e. on the next open an (automatic) <strong>qemu-img check -r
all</strong> is required, which may take some time.

This option can only be enabled if <strong>compat=1.1</strong> is specified.</dd>
<dt>
<strong><strong>nocow</strong></strong>
</dt>
<dd>
<p>If this option is set to <strong>on</strong>, it will turn off COW of
the file. It&#39;s only valid on btrfs, no effect on other file systems.</p>
<p>
Btrfs has low performance when hosting a VM image file, even more when
the guest on the VM also using btrfs as file system. Turning off COW
is a way to mitigate this bad performance. Generally there are two
ways to turn off COW on btrfs:</p>
<ul>
<li>Disable it by mounting with nodatacow, then all newly created files
will be NOCOW</li>
<li>For an empty file, add the NOCOW file attribute. That&#39;s what this
option does.</li>
</ul>
</dd>
</dl>
<p>Note: this option is only valid to new or empty files. If there is an
existing file which is COW and has data blocks already, it couldn&#39;t be
changed to NOCOW by setting <strong>nocow=on</strong>. One can issue <strong>lsattr filename</strong>
to check if the NOCOW flag is set or not (Capital &#39;C&#39; is NOCOW flag).</p>
<dl>
<dt>
<strong><strong>data_file</strong></strong>
</dt>
<dd>Filename where all guest data will be stored. If this
option is used, the qcow2 file will only contain the image&#39;s metadata.

Note: Data loss will occur if the given filename already exists when
using this option with <strong>qemu-img create</strong> since <strong>qemu-img</strong> will create
the data file anew, overwriting the file&#39;s original contents. To
simply update the reference to point to the given pre-existing file,
use <strong>qemu-img amend</strong>.</dd>
<dt>
<strong><strong>data_file_raw</strong></strong>
</dt>
<dd>If this option is set to <strong>on</strong>, QEMU will always
keep the external data file consistent as a standalone read-only raw
image.

It does this by forwarding all write accesses to the qcow2 file
through to the raw data file, including their offsets. Therefore, data
that is visible on the qcow2 node (i.e., to the guest) at some offset
is visible at the same offset in the raw data file. This results in a
read-only raw image. Writes that bypass the qcow2 metadata may corrupt
the qcow2 metadata because the out-of-band writes may result in the
metadata falling out of sync with the raw image.

If this option is <strong>off</strong>, QEMU will use the data file to store data in
an arbitrary manner. The file&#39;s content will not make sense without
the accompanying qcow2 metadata. Where data is written will have no
relation to its offset as seen by the guest, and some writes
(specifically zero writes) may not be forwarded to the data file at
all, but will only be handled by modifying qcow2 metadata.

This option can only be enabled if <strong>data_file</strong> is set.</dd>
</dl>
</blockquote>
</blockquote>
</blockquote>
<p>
<strong>Other</strong></p>
<blockquote>
<blockquote>
<p>QEMU also supports various other image file formats for compatibility
with older QEMU versions or other hypervisors, including VMDK, VDI, VHD
(vpc), VHDX, qcow1 and QED. For a full list of supported formats see
<strong>qemu-img –help</strong>. For a more detailed description of these formats, see
the QEMU block drivers reference documentation.</p>
<p>
The main purpose of the block drivers for these formats is image
conversion. For running VMs, it is recommended to convert the disk
images to either raw or qcow2 in order to achieve good performance.</p>
</blockquote>
</blockquote>
</div>
</div>
<div id="outline-container-headline-6" class="outline-2">
<h2 id="headline-6">
AUTHOR
</h2>
<div id="outline-text-headline-6" class="outline-text-2">
<p>Fabrice Bellard</p>
</div>
</div>
<div id="outline-container-headline-7" class="outline-2">
<h2 id="headline-7">
COPYRIGHT
</h2>
<div id="outline-text-headline-7" class="outline-text-2">
<p>2024, The QEMU Project Developers</p>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.js"></script>
    </body>
</html>
