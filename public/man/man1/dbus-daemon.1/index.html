<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - dbus-daemon.1 | Technical Notes</title>

    <link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - dbus-daemon.1</h1>
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
NAME
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>dbus-daemon - Message bus daemon</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
SYNOPSIS
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p><strong>dbus-daemon</strong></p>
<p>
<strong>dbus-daemon</strong> [–version] [–session] [–system] [–config-file=/FILE/]
[–print-address [/=DESCRIPTOR/]] [–print-pid [/=DESCRIPTOR/]] [–fork]
[–nosyslog] [–syslog] [–syslog-only] [–ready-event-handle=value]\\</p>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
DESCRIPTION
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p><strong>dbus-daemon</strong> is the D-Bus message bus daemon. See
<strong><a href="http://www.freedesktop.org/software/dbus/">http://www.freedesktop.org/software/dbus/</a></strong> for more information about
the big picture. D-Bus is first a library that provides one-to-one
communication between any two applications; <strong>dbus-daemon</strong> is an
application that uses this library to implement a message bus daemon.
Multiple programs connect to the message bus daemon and can exchange
messages with one another.</p>
<p>
There are two standard message bus instances: the systemwide message bus
(installed on many systems as the &#34;messagebus&#34; init service) and the
per-user-login-session message bus (started each time a user logs in).
<strong>dbus-daemon</strong> is used for both of these instances, but with a different
configuration file.</p>
<p>
The –session option is equivalent to
&#34;–config-file=/etc/dbus-1/session.conf&#34; and the –system option is
equivalent to &#34;–config-file=/etc/dbus-1/system.conf&#34;. By creating
additional configuration files and using the –config-file option,
additional special-purpose message bus daemons could be created.</p>
<p>
The systemwide daemon is normally launched by an init script, standardly
called simply &#34;messagebus&#34;.</p>
<p>
The systemwide daemon is largely used for broadcasting system events,
such as changes to the printer queue, or adding/removing devices.</p>
<p>
The per-session daemon is used for various interprocess communication
among desktop applications (however, it is not tied to X or the GUI in
any way).</p>
<p>
SIGHUP will cause the D-Bus daemon to PARTIALLY reload its configuration
file and to flush its user/group information caches. Some configuration
changes would require kicking all apps off the bus; so they will only
take effect if you restart the daemon. Policy changes should take effect
with SIGHUP.</p>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
OPTIONS
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<p>The following options are supported:</p>
<p>
.PP <strong>–config-file=FILE</strong></p>
<blockquote>
<p>Use the given configuration file.</p>
<p>
.RE .PP <strong>–fork</strong></p>
<blockquote>
<p>Force the message bus to fork and become a daemon, even if the
configuration file does not specify that it should. In most contexts the
configuration file already gets this right, though. This option is not
supported on Windows.</p>
<p>
.RE .PP <strong>–nofork</strong></p>
<blockquote>
<p>Force the message bus not to fork and become a daemon, even if the
configuration file specifies that it should. On Windows, the dbus-daemon
never forks, so this option is allowed but does nothing.</p>
<p>
.RE .PP <strong>–print-address[=DESCRIPTOR]</strong></p>
<blockquote>
<p>Print the address of the message bus to standard output, or to the given
file descriptor. This is used by programs that launch the message bus.</p>
<p>
.RE .PP <strong>–print-pid[=DESCRIPTOR]</strong></p>
<blockquote>
<p>Print the process ID of the message bus to standard output, or to the
given file descriptor. This is used by programs that launch the message
bus.</p>
<p>
.RE .PP <strong>–session</strong></p>
<blockquote>
<p>Use the standard configuration file for the per-login-session message
bus.</p>
<p>
.RE .PP <strong>–system</strong></p>
<blockquote>
<p>Use the standard configuration file for the systemwide message bus.</p>
<p>
.RE .PP <strong>–version</strong></p>
<blockquote>
<p>Print the version of the daemon.</p>
<p>
.RE .PP <strong>–introspect</strong></p>
<blockquote>
<p>Print the introspection information for all D-Bus internal interfaces.</p>
<p>
.RE .PP <strong>–address[=ADDRESS]</strong></p>
<blockquote>
<p>Set the address to listen on. This option overrides the address
configured in the configuration file via the &lt;listen&gt; directive. See the
documentation of that directive for more details.</p>
<p>
.RE .PP <strong>–systemd-activation</strong></p>
<blockquote>
<p>Enable systemd-style service activation. Only useful in conjunction with
the systemd system and session manager on Linux.</p>
<p>
.RE .PP <strong>–nopidfile</strong></p>
<blockquote>
<p>Dont write a PID file even if one is configured in the configuration
files.</p>
<p>
.RE</p>
<p>
.PP <strong>–syslog</strong></p>
<blockquote>
<p>Force the message bus to use the system log for messages, in addition to
writing to standard error, even if the configuration file does not
specify that it should. On Unix, this uses the syslog; on Windows, this
uses OutputDebugString().</p>
<p>
.RE</p>
<p>
.PP <strong>–syslog-only</strong></p>
<blockquote>
<p>Force the message bus to use the system log for messages, and <em>not</em>
duplicate them to standard error. On Unix, this uses the syslog; on
Windows, this uses OutputDebugString().</p>
<p>
.RE</p>
<p>
.PP <strong>–nosyslog</strong></p>
<blockquote>
<p>Force the message bus to use only standard error for messages, even if
the configuration file specifies that it should use the system log.</p>
<p>
.RE</p>
<p>
.PP <strong>–ready-event-handle=value</strong></p>
<blockquote>
<p>With this option, the dbus daemon raises an event when it is ready to
process connections. The <em>handle</em> must be the Windows handle for an
event object, in the format printed by the <strong>printf</strong> format string %p.
The parent process must create this event object (for example with the
<strong>CreateEvent</strong> function) in a nonsignaled state, then configure it to be
inherited by the dbus-daemon process. The dbus-daemon will signal the
event as if via <strong>SetEvent</strong> when it is ready to receive connections from
clients. The parent process can wait for this to occur by using
functions such as <strong>WaitForSingleObject</strong>. This option is only supported
under Windows. On Unix platforms, a similar result can be achieved by
waiting for the address and/or process ID to be printed to the inherited
file descriptors used for <strong>–print-address</strong> and/or <strong>–print-pid</strong>.</p>
<p>
.RE</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</div>
</div>
<div id="outline-container-headline-5" class="outline-2">
<h2 id="headline-5">
CONFIGURATION FILE
</h2>
<div id="outline-text-headline-5" class="outline-text-2">
<p>A message bus daemon has a configuration file that specializes it for a
particular application. For example, one configuration file might set up
the message bus to be a systemwide message bus, while another might set
it up to be a per-user-login-session bus.</p>
<p>
The configuration file also establishes resource limits, security
parameters, and so forth.</p>
<p>
The configuration file is not part of any interoperability specification
and its backward compatibility is not guaranteed; this document is
documentation, not specification.</p>
<p>
The standard systemwide and per-session message bus setups are
configured in the files &#34;/etc/dbus-1/system.conf&#34; and
&#34;/etc/dbus-1/session.conf&#34;. These files normally &lt;include&gt; a
system-local.conf or session-local.conf in /etc/dbus-1; you can put
local overrides in those files to avoid modifying the primary
configuration files.</p>
<p>
The standard system bus normally reads additional XML files from
/etc/dbus-1/system.d. Third-party packages should install the default
policies necessary for correct operation into that directory, which has
been supported since dbus 1.10 (released in 2015).</p>
<p>
The standard system bus normally also reads XML files from
/etc/dbus-1/system.d, which should be used by system administrators if
they wish to override default policies.</p>
<p>
Third-party packages would historically install XML files into
/etc/dbus-1/system.d, but this practice is now considered to be
deprecated: that directory should be treated as reserved for the system
administrator.</p>
<p>
The configuration file is an XML document. It must have the following
doctype declaration:</p>
<blockquote>
<pre class="example">
   &lt;!DOCTYPE busconfig PUBLIC &#34;-//freedesktop//DTD D-Bus Bus Configuration 1.0//EN&#34;
    &#34;http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd&#34;&gt;
</pre>
</blockquote>
<p>
The following elements may be present in the configuration file.</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;busconfig&gt;</em></p>
</blockquote>
<p>
Root element.</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;type&gt;</em></p>
</blockquote>
<p>
The well-known type of the message bus. Currently known values are
&#34;system&#34; and &#34;session&#34;; if other values are set, they should be either
added to the D-Bus specification, or namespaced. The last &lt;type&gt; element
&#34;wins&#34; (previous values are ignored). This element only controls which
message bus specific environment variables are set in activated clients.
Most of the policy that distinguishes a session bus from the system bus
is controlled from the other elements in the configuration file.</p>
<p>
If the well-known type of the message bus is &#34;session&#34;, then the
DBUS_STARTER_BUS_TYPE environment variable will be set to &#34;session&#34; and
the DBUS_SESSION_BUS_ADDRESS environment variable will be set to the
address of the session bus. Likewise, if the type of the message bus is
&#34;system&#34;, then the DBUS_STARTER_BUS_TYPE environment variable will be
set to &#34;system&#34; and the DBUS_SYSTEM_BUS_ADDRESS environment variable
will be set to the address of the system bus (which is normally well
known anyway).</p>
<p>
Example: &lt;type&gt;session&lt;/type&gt;</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;include&gt;</em></p>
</blockquote>
<p>
Include a file &lt;include&gt;filename.conf&lt;/include&gt; at this point. If the
filename is relative, it is located relative to the configuration file
doing the including.</p>
<p>
&lt;include&gt; has an optional attribute &#34;ignore_missing=(yes|no)&#34; which
defaults to &#34;no&#34; if not provided. This attribute controls whether its a
fatal error for the included file to be absent.</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;includedir&gt;</em></p>
</blockquote>
<p>
Include all files in &lt;includedir&gt;foo.d&lt;/includedir&gt; at this point. Files
in the directory are included in undefined order. Only files ending in
&#34;.conf&#34; are included.</p>
<p>
This is intended to allow extension of the system bus by particular
packages. For example, if CUPS wants to be able to send out notification
of printer queue changes, it could install a file to
/etc/dbus-1/system.d that allowed all apps to receive this message and
allowed the printer daemon user to send it.</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;user&gt;</em></p>
</blockquote>
<p>
The user account the daemon should run as, as either a username or a
UID. If the daemon cannot change to this UID on startup, it will exit.
If this element is not present, the daemon will not change or care about
its UID.</p>
<p>
The last &lt;user&gt; entry in the file &#34;wins&#34;, the others are ignored.</p>
<p>
The user is changed after the bus has completed initialization. So
sockets etc. will be created before changing user, but no data will be
read from clients before changing user. This means that sockets and PID
files can be created in a location that requires root privileges for
writing.</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;fork&gt;</em></p>
</blockquote>
<p>
If present, the bus daemon becomes a real daemon (forks into the
background, etc.). This is generally used rather than the –fork command
line option.</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;keep_umask&gt;</em></p>
</blockquote>
<p>
If present, the bus daemon keeps its original umask when forking. This
may be useful to avoid affecting the behavior of child processes.</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;syslog&gt;</em></p>
</blockquote>
<p>
If present, the bus daemon will log to syslog. The –syslog,
–syslog-only and –nosyslog command-line options take precedence over
this setting.</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;pidfile&gt;</em></p>
</blockquote>
<p>
If present, the bus daemon will write its pid to the specified file. The
–nopidfile command-line option takes precedence over this setting.</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;allow_anonymous&gt;</em></p>
</blockquote>
<p>
If present, connections that authenticated using the ANONYMOUS mechanism
will be authorized to connect. This option has no practical effect
unless the ANONYMOUS mechanism has also been enabled using the <em>&lt;auth&gt;</em>
element, described below.</p>
<p>
Using this directive in the configuration of the well-known system bus
or the well-known session bus will make that bus insecure and should
never be done. Similarly, on custom bus types, using this directive will
usually make the custom bus insecure, unless its configuration has been
specifically designed to prevent anonymous users from causing damage or
escalating privileges.</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;listen&gt;</em></p>
</blockquote>
<p>
Add an address that the bus should listen on. The address is in the
standard D-Bus format that contains a transport name plus possible
parameters/options.</p>
<p>
On platforms other than Windows, unix-based transports (unix, systemd,
launchd) are the default for both the well-known system bus and the
well-known session bus, and are strongly recommended.</p>
<p>
On Windows, unix-based transports are not available, so TCP-based
transports must be used. Similar to remote X11, the tcp and nonce-tcp
transports have no integrity or confidentiality protection, so they
should normally only be used across the local loopback interface, for
example using an address like tcp:host=127.0.0.1 or
nonce-tcp:host=localhost. In particular, configuring the well-known
system bus or the well-known session bus to listen on a non-loopback TCP
address is insecure.</p>
<p>
Developers are sometimes tempted to use remote TCP as a debugging tool.
However, if this functionality is left enabled in finished products, the
result will be dangerously insecure. Instead of using remote TCP,
developers should <strong>relay connections via Secure Shell or a similar
protocol</strong>[1].</p>
<p>
Remote TCP connections were historically sometimes used to share a
single session bus between login sessions of the same user on different
machines within a trusted local area network, in conjunction with
unencrypted remote X11, a NFS-shared home directory and NIS (YP)
authentication. This is insecure against an attacker on the same LAN and
should be considered strongly deprecated; more specifically, it is
insecure in the same ways and for the same reasons as unencrypted remote
X11 and NFSv2/NFSv3. The D-Bus maintainers recommend using a separate
session bus per (user, machine) pair, only accessible from within that
machine.</p>
<p>
Example: &lt;listen&gt;unix:path=/tmp/foo&lt;/listen&gt;</p>
<p>
Example: &lt;listen&gt;tcp:host=localhost,port=1234&lt;/listen&gt;</p>
<p>
If there are multiple &lt;listen&gt; elements, then the bus listens on
multiple addresses. The bus will pass its address to started services or
other interested parties with the last address given in &lt;listen&gt; first.
That is, apps will try to connect to the last &lt;listen&gt; address first.</p>
<p>
tcp sockets can accept IPv4 addresses, IPv6 addresses or hostnames. If a
hostname resolves to multiple addresses, the server will bind to all of
them. The family=ipv4 or family=ipv6 options can be used to force it to
bind to a subset of addresses</p>
<p>
Example: &lt;listen&gt;tcp:host=localhost,port=0,family=ipv4&lt;/listen&gt;</p>
<p>
A special case is using a port number of zero (or omitting the port),
which means to choose an available port selected by the operating
system. The port number chosen can be obtained with the –print-address
command line parameter and will be present in other cases where the
server reports its own address, such as when DBUS_SESSION_BUS_ADDRESS is
set.</p>
<p>
Example: &lt;listen&gt;tcp:host=localhost,port=0&lt;/listen&gt;</p>
<p>
tcp/nonce-tcp addresses also allow a bind=hostname option, used in a
listenable address to configure the interface on which the server will
listen: either the hostname is the IP address of one of the local
machines interfaces (most commonly 127.0.0.1), a DNS name that resolves
to one of those IP addresses, 0.0.0.0 to listen on all IPv4 interfaces
simultaneously, or :: to listen on all IPv4 and IPv6 interfaces
simultaneously (if supported by the OS). If not specified, the default
is the same value as &#34;host&#34;.</p>
<p>
Example: &lt;listen&gt;tcp:host=localhost,bind=0.0.0.0,port=0&lt;/listen&gt;</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;auth&gt;</em></p>
</blockquote>
<p>
Lists permitted authorization mechanisms. If this element doesnt exist,
then all known mechanisms are allowed. If there are multiple &lt;auth&gt;
elements, all the listed mechanisms are allowed. The order in which
mechanisms are listed is not meaningful.</p>
<p>
On non-Windows operating systems, allowing only the EXTERNAL
authentication mechanism is strongly recommended. This is the default
for the well-known system bus and for the well-known session bus.</p>
<p>
Example: &lt;auth&gt;EXTERNAL&lt;/auth&gt;</p>
<p>
Example: &lt;auth&gt;DBUS_COOKIE_SHA1&lt;/auth&gt;</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;servicedir&gt;</em></p>
</blockquote>
<p>
Adds a directory to search for .service files, which tell the
dbus-daemon how to start a program to provide a particular well-known
bus name. See the D-Bus Specification for more details about the
contents of .service files.</p>
<p>
If a particular service is found in more than one &lt;servicedir&gt;, the
first directory listed in the configuration file takes precedence. If
two service files providing the same well-known bus name are found in
the same directory, it is arbitrary which one will be chosen (this can
only happen if at least one of the service files does not have the
recommended name, which is its well-known bus name followed by
&#34;.service&#34;).</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;standard_session_servicedirs/&gt;</em></p>
</blockquote>
<p>
&lt;standard_session_servicedirs/&gt; requests a standard set of session
service directories. Its effect is similar to specifying a series of
&lt;servicedir/&gt; elements for each of the data directories, in the order
given here. It is not exactly equivalent, because there is currently no
way to disable directory monitoring or enforce strict service file
naming for a &lt;servicedir/&gt;.</p>
<p>
As with &lt;servicedir/&gt; elements, if a particular service is found in more
than one service directory, the first directory takes precedence. If two
service files providing the same well-known bus name are found in the
same directory, it is arbitrary which one will be chosen (this can only
happen if at least one of the service files does not have the
recommended name, which is its well-known bus name followed by
&#34;.service&#34;).</p>
<p>
On Unix, the standard session service directories are:</p>
<blockquote>
<p>·</p>
<p>
/$XDG_RUNTIME_DIR//dbus-1/services, if XDG_RUNTIME_DIR is set (see the
XDG Base Directory Specification for details of XDG_RUNTIME_DIR): this
location is suitable for transient services created at runtime by
systemd generators (see *systemd.generator*(7)), session managers or
other session infrastructure. It is an extension provided by the
reference implementation of dbus-daemon, and is not standardized in the
D-Bus Specification.</p>
<p>
Unlike the other standard session service directories, this directory
enforces strict naming for the service files: the filename must be
exactly the well-known bus name of the service, followed by &#34;.service&#34;.</p>
<p>
Also unlike the other standard session service directories, this
directory is never monitored with *inotify*(7) or similar APIs. Programs
that create service files in this directory while a dbus-daemon is
running are expected to call the dbus-daemons ReloadConfig() method
after they have made changes.</p>
<p>
.RE</p>
<blockquote>
<p>·</p>
<p>
<em>$XDG_DATA_HOME//dbus-1/services, where XDG_DATA_HOME defaults to
~</em>.local/share (see the XDG Base Directory Specification): this location
is specified by the D-Bus Specification, and is suitable for per-user,
locally-installed software.</p>
<p>
.RE</p>
<blockquote>
<p>·</p>
<p>
/directory//dbus-1/services for each directory in XDG_DATA_DIRS, where
XDG_DATA_DIRS defaults to /usr/local/share:/usr/share (see the XDG Base
Directory Specification): these locations are specified by the D-Bus
Specification. The defaults are suitable for software installed locally
by a system administrator (/usr/local/share) or for software installed
from operating system packages (/usr/share). Per-user or system-wide
configuration that sets the XDG_DATA_DIRS environment variable can
extend this search path to cover installations in other locations, for
example ~/.local/share/flatpak/exports/share/ and
<em>var/lib/flatpak/exports/share</em> when *flatpak*(1) is used.</p>
<p>
.RE</p>
<blockquote>
<p>·</p>
<p>
<em>${datadir}//dbus-1/services for the /${datadir}</em> that was specified
when dbus was compiled, typically /usr/share: this location is an
extension provided by the reference dbus-daemon implementation, and is
suitable for software stacks installed alongside dbus-daemon.</p>
<p>
.RE</p>
<p>
The &#34;XDG Base Directory Specification&#34; can be found at
<strong><a href="http://freedesktop.org/wiki/Standards/basedir-spec">http://freedesktop.org/wiki/Standards/basedir-spec</a></strong> if it hasnt moved,
otherwise try your favorite search engine.</p>
<p>
On Windows, the standard session service directories are:</p>
<blockquote>
<p>·</p>
<p>
/%CommonProgramFiles%//dbus-1/services if %CommonProgramFiles% is set:
this location is suitable for system-wide installed software packages</p>
<p>
.RE</p>
<blockquote>
<p>·</p>
<p>
A share/dbus-1/services directory found in the same directory hierarchy
(prefix) as the dbus-daemon: this location is suitable for software
stacks installed alongside dbus-daemon</p>
<p>
.RE</p>
<p>
The &lt;standard_session_servicedirs/&gt; option is only relevant to the
per-user-session bus daemon defined in /etc/dbus-1/session.conf. Putting
it in any other configuration file would probably be nonsense.</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;standard_system_servicedirs/&gt;</em></p>
</blockquote>
<p>
&lt;standard_system_servicedirs/&gt; specifies the standard system-wide
activation directories that should be searched for service files. As
with session services, the first directory listed has highest
precedence.</p>
<p>
On Unix, the standard system service directories are:</p>
<blockquote>
<p>·</p>
<p>
/usr/local/share/dbus-1/system-services: this location is specified by
the D-Bus Specification, and is suitable for software installed locally
by the system administrator</p>
<p>
.RE</p>
<blockquote>
<p>·</p>
<p>
/usr/share/dbus-1/system-services: this location is specified by the
D-Bus Specification, and is suitable for software installed by operating
system packages</p>
<p>
.RE</p>
<blockquote>
<p>·</p>
<p>
<em>${datadir}//dbus-1/system-services for the /${datadir}</em> that was
specified when dbus was compiled, typically /usr/share: this location is
an extension provided by the reference dbus-daemon implementation, and
is suitable for software stacks installed alongside dbus-daemon</p>
<p>
.RE</p>
<blockquote>
<p>·</p>
<p>
/lib/dbus-1/system-services: this location is specified by the D-Bus
Specification, and was intended for software installed by operating
system packages and used during early boot (but it should be considered
deprecated, because the reference dbus-daemon is not designed to be
available during early boot)</p>
<p>
.RE</p>
<p>
On Windows, there is no standard system bus, so there are no standard
system bus directories either.</p>
<p>
The &lt;standard_system_servicedirs/&gt; option is only relevant to the
per-system bus daemon defined in /etc/dbus-1/system.conf. Putting it in
any other configuration file would probably be nonsense.</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;servicehelper/&gt;</em></p>
</blockquote>
<p>
&lt;servicehelper/&gt; specifies the setuid helper that is used to launch
system daemons with an alternate user. Typically this should be the
dbus-daemon-launch-helper executable in located in libexec.</p>
<p>
The &lt;servicehelper/&gt; option is only relevant to the per-system bus
daemon defined in /etc/dbus-1/system.conf. Putting it in any other
configuration file would probably be nonsense.</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;limit&gt;</em></p>
</blockquote>
<p>
&lt;limit&gt; establishes a resource limit. For example:</p>
<blockquote>
<pre class="example">
  &lt;limit name=&#34;max_message_size&#34;&gt;64&lt;/limit&gt;
  &lt;limit name=&#34;max_completed_connections&#34;&gt;512&lt;/limit&gt;
</pre>
</blockquote>
<p>
The name attribute is mandatory. Available limit names are:</p>
<blockquote>
<pre class="example">
      &#34;max_incoming_bytes&#34;         : total size in bytes of messages
                                     incoming from a single connection
      &#34;max_incoming_unix_fds&#34;      : total number of unix fds of messages
                                     incoming from a single connection
      &#34;max_outgoing_bytes&#34;         : total size in bytes of messages
                                     queued up for a single connection
      &#34;max_outgoing_unix_fds&#34;      : total number of unix fds of messages
                                     queued up for a single connection
      &#34;max_message_size&#34;           : max size of a single message in
                                     bytes
      &#34;max_message_unix_fds&#34;       : max unix fds of a single message
      &#34;service_start_timeout&#34;      : milliseconds (thousandths) until
                                     a started service has to connect
      &#34;auth_timeout&#34;               : milliseconds (thousandths) a
                                     connection is given to
                                     authenticate
      &#34;pending_fd_timeout&#34;         : milliseconds (thousandths) a
                                     fd is given to be transmitted to
                                     dbus-daemon before disconnecting the
                                     connection
      &#34;max_completed_connections&#34;  : max number of authenticated connections
      &#34;max_incomplete_connections&#34; : max number of unauthenticated
                                     connections
      &#34;max_connections_per_user&#34;   : max number of completed connections from
                                     the same user (only enforced on Unix OSs)
      &#34;max_pending_service_starts&#34; : max number of service launches in
                                     progress at the same time
      &#34;max_names_per_connection&#34;   : max number of names a single
                                     connection can own
      &#34;max_match_rules_per_connection&#34;: max number of match rules for a single
                                        connection
      &#34;max_replies_per_connection&#34; : max number of pending method
                                     replies per connection
                                     (number of calls-in-progress)
      &#34;reply_timeout&#34;              : milliseconds (thousandths)
                                     until a method call times out
</pre>
</blockquote>
<p>
The max incoming/outgoing queue sizes allow a new message to be queued
if one byte remains below the max. So you can in fact exceed the max by
max_message_size.</p>
<p>
max_completed_connections divided by max_connections_per_user is the
number of users that can work together to denial-of-service all other
users by using up all connections on the systemwide bus.</p>
<p>
Limits are normally only of interest on the systemwide bus, not the user
session buses.</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;policy&gt;</em></p>
</blockquote>
<p>
The &lt;policy&gt; element defines a security policy to be applied to a
particular set of connections to the bus. A policy is made up of &lt;allow&gt;
and &lt;deny&gt; elements. Policies are normally used with the systemwide bus;
they are analogous to a firewall in that they allow expected traffic and
prevent unexpected traffic.</p>
<p>
Currently, the system bus has a default-deny policy for sending method
calls and owning bus names, and a default-allow policy for receiving
messages, sending signals, and sending a single success or error reply
for each method call that does not have the NO_REPLY flag. Sending more
than the expected number of replies is not allowed.</p>
<p>
In general, it is best to keep system services as small, targeted
programs which run in their own process and provide a single bus name.
Then, all that is needed is an &lt;allow&gt; rule for the &#34;own&#34; permission to
let the process claim the bus name, and a &#34;send_destination&#34; rule to
allow traffic from some or all uids to your service.</p>
<p>
The &lt;policy&gt; element has one of four attributes:</p>
<blockquote>
<pre class="example">
  context=&#34;(default|mandatory)&#34;
  at_console=&#34;(true|false)&#34;
  user=&#34;username or userid&#34;
  group=&#34;group name or gid&#34;
</pre>
</blockquote>
<p>
Policies are applied to a connection as follows:</p>
<blockquote>
<pre class="example">
   - all context=&#34;default&#34; policies are applied
   - all group=&#34;connections users group&#34; policies are applied
     in undefined order
   - all user=&#34;connections auth user&#34; policies are applied
     in undefined order
   - all at_console=&#34;true&#34; policies are applied
   - all at_console=&#34;false&#34; policies are applied
   - all context=&#34;mandatory&#34; policies are applied
</pre>
</blockquote>
<p>
Policies applied later will override those applied earlier, when the
policies overlap. Multiple policies with the same user/group/context are
applied in the order they appear in the config file.</p>
<p>
.PP <em>&lt;deny&gt;</em></p>
<blockquote>
<p><em>&lt;allow&gt;</em></p>
<p>
.RE</p>
<p>
A &lt;deny&gt; element appears below a &lt;policy&gt; element and prohibits some
action. The &lt;allow&gt; element makes an exception to previous &lt;deny&gt;
statements, and works just like &lt;deny&gt; but with the inverse meaning.</p>
<p>
The possible attributes of these elements are:</p>
<blockquote>
<pre class="example">
   send_interface=&#34;interface_name&#34; | &#34;*&#34;
   send_member=&#34;method_or_signal_name&#34; | &#34;*&#34;
   send_error=&#34;error_name&#34; | &#34;*&#34;
   send_broadcast=&#34;true&#34; | &#34;false&#34;
   send_destination=&#34;name&#34; | &#34;*&#34;
   send_destination_prefix=&#34;name&#34;
   send_type=&#34;method_call&#34; | &#34;method_return&#34; | &#34;signal&#34; | &#34;error&#34; | &#34;*&#34;
   send_path=&#34;/path/name&#34; | &#34;*&#34;

   receive_interface=&#34;interface_name&#34; | &#34;*&#34;
   receive_member=&#34;method_or_signal_name&#34; | &#34;*&#34;
   receive_error=&#34;error_name&#34; | &#34;*&#34;
   receive_sender=&#34;name&#34; | &#34;*&#34;
   receive_type=&#34;method_call&#34; | &#34;method_return&#34; | &#34;signal&#34; | &#34;error&#34; | &#34;*&#34;
   receive_path=&#34;/path/name&#34; | &#34;*&#34;

   send_requested_reply=&#34;true&#34; | &#34;false&#34;
   receive_requested_reply=&#34;true&#34; | &#34;false&#34;

   eavesdrop=&#34;true&#34; | &#34;false&#34;

   own=&#34;name&#34; | &#34;*&#34;
   own_prefix=&#34;name&#34;
   user=&#34;username&#34; | &#34;*&#34;
   group=&#34;groupname&#34; | &#34;*&#34;
</pre>
</blockquote>
<p>
Examples:</p>
<blockquote>
<pre class="example">
   &lt;deny send_destination=&#34;org.freedesktop.Service&#34; send_interface=&#34;org.freedesktop.System&#34; send_member=&#34;Reboot&#34;/&gt;
   &lt;deny send_destination=&#34;org.freedesktop.System&#34;/&gt;
   &lt;deny receive_sender=&#34;org.freedesktop.System&#34;/&gt;
   &lt;deny user=&#34;john&#34;/&gt;
   &lt;deny group=&#34;enemies&#34;/&gt;
</pre>
</blockquote>
<p>
The &lt;deny&gt; elements attributes determine whether the deny &#34;matches&#34; a
particular action. If it matches, the action is denied (unless later
rules in the config file allow it).</p>
<p>
Rules with one or more of the send_* family of attributes are checked in
order when a connection attempts to send a message. The last rule that
matches the message determines whether it may be sent. The well-known
session bus normally allows sending any message. The well-known system
bus normally allows sending any signal, selected method calls to the
<strong>dbus-daemon</strong>, and exactly one reply to each previously-sent method call
(either success or an error). Either of these can be overridden by
configuration; on the system bus, services that will receive method
calls must install configuration that allows them to do so, usually via
rules of the form &lt;policy context=&#34;default&#34;&gt;&lt;allow
send_destination=&#34;…&#34;/&gt;&lt;policy&gt;.</p>
<p>
Rules with one or more of the receive_* family of attributes, or with
the eavesdrop attribute and no others, are checked for each recipient of
a message (there might be more than one recipient if the message is a
broadcast or a connection is eavesdropping). The last rule that matches
the message determines whether it may be received. The well-known
session bus normally allows receiving any message, including
eavesdropping. The well-known system bus normally allows receiving any
message that was not eavesdropped (any unicast message addressed to the
recipient, and any broadcast message).</p>
<p>
The eavesdrop, min_fds and max_fds attributes are modifiers that can be
applied to either send_* or receive_* rules, and are documented below.</p>
<p>
send_destination and receive_sender rules mean that messages may not be
sent to or received from the <strong>owner</strong> of the given name, not that they
may not be sent <strong>to that name</strong>. That is, if a connection owns services
A, B, C, and sending to A is denied, sending to B or C will not work
either. As a special case, send_destination=&#34;<strong>&#34; matches any message
(whether it has a destination specified or not), and receive_sender=&#34;</strong>&#34;
similarly matches any message.</p>
<p>
A send_destination_prefix rule opens or closes the whole namespace for
sending. It means that messages may or may not be sent to the <em>owner</em> of
any name matching the prefix, regardless of whether it is the primary or
the queued owner. In other words, for &lt;allow
send_destination_prefix=&#34;a.b&#34;/&gt; rule and names &#34;a.b&#34;, &#34;a.b.c&#34;, and
&#34;a.b.c.d&#34; present on the bus, it works the same as if three separate
rules: &lt;allow send_destination=&#34;a.b&#34;/&gt;, &lt;allow
send_destination=&#34;a.b.c&#34;/&gt;, and &lt;allow send_destination=&#34;a.b.c.d&#34;/&gt; had
been defined. The rules for matching names are the same as in own_prefix
(see below): a prefix of &#34;a.b&#34; matches names &#34;a.b&#34; or &#34;a.b.c&#34; or
&#34;a.b.c.d&#34;, but not &#34;a.bc&#34; or &#34;a.c&#34;. The send_destination_prefix
attribute cannot be combined with the send_destination attribute in the
same rule.</p>
<p>
Rules with send_broadcast=&#34;true&#34; match signal messages with no
destination (broadcasts). Rules with send_broadcast=&#34;false&#34; are the
inverse: they match any unicast destination (unicast signals, together
with all method calls, replies and errors) but do not match messages
with no destination (broadcasts). This is not the same as
send_destination=&#34;*&#34;, which matches any sent message, regardless of
whether it has a destination or not.</p>
<p>
The other send_* and receive_* attributes are purely textual/by-value
matches against the given field in the message header, except that for
the attributes where it is allowed, * matches any message (whether it
has the relevant header field or not). For example, send_interface=&#34;*&#34;
matches any sent message, even if it does not contain an interface
header field. More complex glob matching such as foo.bar.* is not
allowed.</p>
<p>
&#34;Eavesdropping&#34; occurs when an application receives a message that was
explicitly addressed to a name the application does not own, or is a
reply to such a message. Eavesdropping thus only applies to messages
that are addressed to services and replies to such messages (i.e. it
does not apply to signals).</p>
<p>
For &lt;allow&gt;, eavesdrop=&#34;true&#34; indicates that the rule matches even when
eavesdropping. eavesdrop=&#34;false&#34; is the default and means that the rule
only allows messages to go to their specified recipient. For &lt;deny&gt;,
eavesdrop=&#34;true&#34; indicates that the rule matches only when
eavesdropping. eavesdrop=&#34;false&#34; is the default for &lt;deny&gt; also, but
here it means that the rule applies always, even when not eavesdropping.
The eavesdrop attribute can only be combined with send and receive rules
(with send_* and receive_* attributes).</p>
<p>
The [send|receive]_requested_reply attribute works similarly to the
eavesdrop attribute. It controls whether the &lt;deny&gt; or &lt;allow&gt; matches a
reply that is expected (corresponds to a previous method call message).
This attribute only makes sense for reply messages (errors and method
returns), and is ignored for other message types.</p>
<p>
For &lt;allow&gt;, [send|receive]_requested_reply=&#34;true&#34; is the default and
indicates that only requested replies are allowed by the rule.
[send|receive]_requested_reply=&#34;false&#34; means that the rule allows any
reply even if unexpected.</p>
<p>
For &lt;deny&gt;, [send|receive]_requested_reply=&#34;false&#34; is the default but
indicates that the rule matches only when the reply was not requested.
[send|receive]_requested_reply=&#34;true&#34; indicates that the rule applies
always, regardless of pending reply state.</p>
<p>
The min_fds and max_fds attributes modify either send_* or receive_*
rules. A rule with the min_fds attribute only matches messages if they
have at least that many Unix file descriptors attached. Conversely, a
rule with the max_fds attribute only matches messages if they have no
more than that many file descriptors attached. In practice, rules with
these attributes will most commonly take the form &lt;allow
send_destination=&#34;…&#34; max_fds=&#34;0&#34;/&gt;, &lt;deny send_destination=&#34;…&#34;
min_fds=&#34;1&#34;/&gt; or &lt;deny receive_sender=&#34;*&#34; min_fds=&#34;1&#34;/&gt;.</p>
<p>
Rules with the user or group attribute are checked when a new connection
to the message bus is established, and control whether the connection
can continue. Each of these attributes cannot be combined with any other
attribute. As a special case, both user=&#34;<strong>&#34; and group=&#34;</strong>&#34; match any
connection. If there are no rules of this form, the default is to allow
connections from the same user ID that owns the <strong>dbus-daemon</strong> process.
The well-known session bus normally uses that default behaviour, while
the well-known system bus normally allows any connection.</p>
<p>
Rules with the own or own_prefix attribute are checked when a connection
attempts to own a well-known bus names. As a special case, own=&#34;*&#34;
matches any well-known bus name. The well-known session bus normally
allows any connection to own any name, while the well-known system bus
normally does not allow any connection to own any name, except where
allowed by further configuration. System services that will own a name
must install configuration that allows them to do so, usually via rules
of the form &lt;policy user=&#34;some-system-user&#34;&gt;&lt;allow own=&#34;…&#34;/&gt;&lt;/policy&gt;.</p>
<p>
&lt;allow own_prefix=&#34;a.b&#34;/&gt; allows you to own the name &#34;a.b&#34; or any name
whose first dot-separated elements are &#34;a.b&#34;: in particular, you can own
&#34;a.b.c&#34; or &#34;a.b.c.d&#34;, but not &#34;a.bc&#34; or &#34;a.c&#34;. This is useful when
services like Telepathy and ReserveDevice define a meaning for subtrees
of well-known names, such as
org.freedesktop.Telepathy.ConnectionManager.(anything) and
org.freedesktop.ReserveDevice1.(anything).</p>
<p>
It does not make sense to deny a user or group inside a &lt;policy&gt; for a
user or group; user/group denials can only be inside context=&#34;default&#34;
or context=&#34;mandatory&#34; policies.</p>
<p>
A single &lt;deny&gt; rule may specify combinations of attributes such as
send_destination and send_interface and send_type. In this case, the
denial applies only if both attributes match the message being denied.
e.g. &lt;deny send_interface=&#34;foo.bar&#34; send_destination=&#34;foo.blah&#34;/&gt; would
deny messages with the given interface AND the given bus name. To get an
OR effect you specify multiple &lt;deny&gt; rules.</p>
<p>
You cant include both send_ and receive_ attributes on the same rule,
since &#34;whether the message can be sent&#34; and &#34;whether it can be received&#34;
are evaluated separately.</p>
<p>
Be careful with send_interface/receive_interface, because the interface
field in messages is optional. In particular, do NOT specify &lt;deny
send_interface=&#34;org.foo.Bar&#34;/&gt;! This will cause no-interface messages to
be blocked for all services, which is almost certainly not what you
intended. Always use rules of the form: &lt;deny
send_interface=&#34;org.foo.Bar&#34; send_destination=&#34;org.foo.Service&#34;/&gt;</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;selinux&gt;</em></p>
</blockquote>
<p>
The &lt;selinux&gt; element contains settings related to Security Enhanced
Linux. More details below.</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;associate&gt;</em></p>
</blockquote>
<p>
An &lt;associate&gt; element appears below an &lt;selinux&gt; element and creates a
mapping. Right now only one kind of association is possible:</p>
<blockquote>
<pre class="example">
   &lt;associate own=&#34;org.freedesktop.Foobar&#34; context=&#34;foo_t&#34;/&gt;
</pre>
</blockquote>
<p>
This means that if a connection asks to own the name
&#34;org.freedesktop.Foobar&#34; then the source context will be the context of
the connection and the target context will be &#34;foo_t&#34; - see the short
discussion of SELinux below.</p>
<p>
Note, the context here is the target context when requesting a name, NOT
the context of the connection owning the name.</p>
<p>
Theres currently no way to set a default for owning any name, if we add
this syntax it will look like:</p>
<blockquote>
<pre class="example">
   &lt;associate own=&#34;*&#34; context=&#34;foo_t&#34;/&gt;
</pre>
</blockquote>
<p>
If you find a reason this is useful, let the developers know. Right now
the default will be the security context of the bus itself.</p>
<p>
If two &lt;associate&gt; elements specify the same name, the element appearing
later in the configuration file will be used.</p>
<blockquote>
<p>·</p>
<p>
<em>&lt;apparmor&gt;</em></p>
</blockquote>
<p>
The &lt;apparmor&gt; element is used to configure AppArmor mediation on the
bus. It can contain one attribute that specifies the mediation mode:</p>
<blockquote>
<pre class="example">
   &lt;apparmor mode=&#34;(enabled|disabled|required)&#34;/&gt;
</pre>
</blockquote>
<p>
The default mode is &#34;enabled&#34;. In &#34;enabled&#34; mode, AppArmor mediation
will be performed if AppArmor support is available in the kernel. If it
is not available, dbus-daemon will start but AppArmor mediation will not
occur. In &#34;disabled&#34; mode, AppArmor mediation is disabled. In &#34;required&#34;
mode, AppArmor mediation will be enabled if AppArmor support is
available, otherwise dbus-daemon will refuse to start.</p>
<p>
The AppArmor mediation mode of the bus cannot be changed after the bus
starts. Modifying the mode in the configuration file and sending a
SIGHUP signal to the daemon has no effect on the mediation mode.</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</div>
</div>
<div id="outline-container-headline-6" class="outline-2">
<h2 id="headline-6">
INTEGRATING SESSION SERVICES
</h2>
<div id="outline-text-headline-6" class="outline-text-2">
<p>
.PP Integration files are not mandatory for session services: any
program with access to the session bus can request a well-known name and
provide D-Bus interfaces.</p>
<p>
.PP Many D-Bus session services support service activation, a mechanism
in which the <strong>dbus-daemon</strong> can launch the service on-demand, either by
running the session service itself or by communicating with <strong>systemd
–user</strong>. This is set up by creating a service file in the directory
/${datadir}//dbus-1/services, for example:</p>
<blockquote>
<pre class="example">
[D-BUS Service]
Name=com.example.SessionService1
Exec=/usr/bin/example-session-service
# Optional
SystemdService=example-session-service
</pre>
</blockquote>
<p>
See the <strong>D-Bus Specification</strong>[2] for details of the contents and
interpretation of service files.</p>
<p>
.PP If there is a service file for <em>com.example.SessionService1</em>, it
should be named <em>com.example.SessionService1</em>.service, although for
compatibility with legacy services this is not mandatory.</p>
<p>
.PP Session services that declare the optional SystemdService must also
provide a systemd user service unit file whose name or Alias matches the
SystemdService (see *systemd.unit*(5), *systemd.service*(5) for further
details on systemd service units), for example:</p>
<blockquote>
<pre class="example">
[Unit]
Description=Example session service

[Service]
Type=dbus
BusName=com.example.SessionService1
ExecStart=/usr/bin/example-session-service
</pre>
</blockquote>
</div>
</div>
<div id="outline-container-headline-7" class="outline-2">
<h2 id="headline-7">
INTEGRATING SYSTEM SERVICES
</h2>
<div id="outline-text-headline-7" class="outline-text-2">
<p>
.PP The standard system bus does not allow method calls or owning
well-known bus names by default, so a useful D-Bus system service will
normally need to configure a default security policy that allows it to
work. D-Bus system services should install a default policy file in
/${datadir}//dbus-1/service.d, containing the policy rules necessary to
make that system service functional. A best-practice policy file will
often look like this:</p>
<blockquote>
<pre class="example">
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;
&lt;!DOCTYPE busconfig PUBLIC
 &#34;-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN&#34;
 &#34;http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd&#34;&gt;
&lt;busconfig&gt;
  &lt;policy user=&#34;_example&#34;&gt;
    &lt;allow own=&#34;com.example.Example1&#34;/&gt;
  &lt;/policy&gt;

  &lt;policy context=&#34;default&#34;&gt;
    &lt;allow send_destination=&#34;com.example.Example1&#34;/&gt;
  &lt;/policy&gt;
&lt;/busconfig&gt;
</pre>
</blockquote>
<p>
where <em>_example</em> is the username of the system uid that will run the
system service daemon process, and <em>com.example.Example1</em> is its
well-known bus name.</p>
<p>
.PP The policy file for <em>com.example.Example1</em> should normally be named
<em>com.example.Example1</em>.conf.</p>
<p>
.PP Some existing system services rely on more complex &lt;policy&gt; rules to
control the messages that the service can receive. However, the
*dbus-daemon*s policy language is not well-suited to finer-grained
policies: any policy has to be expressed in terms of D-Bus interfaces
and method names, not in terms of higher-level domain-specific concepts
like removable or built-in devices. It is recommended that new services
should normally accept method call messages from all callers, then apply
a sysadmin-controllable policy to decide whether to obey the requests
contained in those method call messages, for example by consulting
<strong>polkit</strong>[3].</p>
<p>
.PP Like session services, many D-Bus system services support service
activation, a mechanism in which the <strong>dbus-daemon</strong> can launch the
service on-demand, either by running the system service itself or by
communicating with <strong>systemd</strong>. This is set up by creating a service file
in the directory /${datadir}//dbus-1/system-services, for example:</p>
<blockquote>
<pre class="example">
[D-BUS Service]
Name=com.example.Example1
Exec=/usr/sbin/example-service
User=_example
# Optional
SystemdService=dbus-com.example.Example1.service
</pre>
</blockquote>
<p>
See the <strong>D-Bus Specification</strong>[2] for details of the contents and
interpretation of service files.</p>
<p>
.PP If there is a service file for <em>com.example.Example1</em>, it must be
named <em>com.example.Example1</em>.service.</p>
<p>
.PP System services that declare the optional SystemdService must also
provide a systemd service unit file whose name or Alias matches the
SystemdService (see *systemd.unit*(5), *systemd.service*(5) for further
details on systemd service units), for example:</p>
<blockquote>
<pre class="example">
[Unit]
Description=Example service

[Service]
Type=dbus
BusName=com.example.Example1
ExecStart=/usr/sbin/example-service

[Install]
WantedBy=multi-user.target
Alias=dbus-com.example.Example1.service
</pre>
</blockquote>
</div>
</div>
<div id="outline-container-headline-8" class="outline-2">
<h2 id="headline-8">
SELINUX
</h2>
<div id="outline-text-headline-8" class="outline-text-2">
<p>See <strong><a href="http://www.nsa.gov/selinux/">http://www.nsa.gov/selinux/</a></strong> for full details on SELinux. Some
useful excerpts:</p>
<p>
Every subject (process) and object (e.g. file, socket, IPC object, etc)
in the system is assigned a collection of security attributes, known as
a security context. A security context contains all of the security
attributes associated with a particular subject or object that are
relevant to the security policy.</p>
<p>
In order to better encapsulate security contexts and to provide greater
efficiency, the policy enforcement code of SELinux typically handles
security identifiers (SIDs) rather than security contexts. A SID is an
integer that is mapped by the security server to a security context at
runtime.</p>
<p>
When a security decision is required, the policy enforcement code passes
a pair of SIDs (typically the SID of a subject and the SID of an object,
but sometimes a pair of subject SIDs or a pair of object SIDs), and an
object security class to the security server. The object security class
indicates the kind of object, e.g. a process, a regular file, a
directory, a TCP socket, etc.</p>
<p>
Access decisions specify whether or not a permission is granted for a
given pair of SIDs and class. Each object class has a set of associated
permissions defined to control operations on objects with that class.</p>
<p>
D-Bus performs SELinux security checks in two places.</p>
<p>
First, any time a message is routed from one connection to another
connection, the bus daemon will check permissions with the security
context of the first connection as source, security context of the
second connection as target, object class &#34;dbus&#34; and requested
permission &#34;send_msg&#34;.</p>
<p>
If a security context is not available for a connection (impossible when
using UNIX domain sockets), then the target context used is the context
of the bus daemon itself. There is currently no way to change this
default, because were assuming that only UNIX domain sockets will be
used to connect to the systemwide bus. If this changes, well probably
add a way to set the default connection context.</p>
<p>
Second, any time a connection asks to own a name, the bus daemon will
check permissions with the security context of the connection as source,
the security context specified for the name in the config file as
target, object class &#34;dbus&#34; and requested permission &#34;acquire_svc&#34;.</p>
<p>
The security context for a bus name is specified with the &lt;associate&gt;
element described earlier in this document. If a name has no security
context associated in the configuration file, the security context of
the bus daemon itself will be used.</p>
</div>
</div>
<div id="outline-container-headline-9" class="outline-2">
<h2 id="headline-9">
APPARMOR
</h2>
<div id="outline-text-headline-9" class="outline-text-2">
<p>The AppArmor confinement context is stored when applications connect to
the bus. The confinement context consists of a label and a confinement
mode. When a security decision is required, the daemon uses the
confinement context to query the AppArmor policy to determine if the
action should be allowed or denied and if the action should be audited.</p>
<p>
The daemon performs AppArmor security checks in three places.</p>
<p>
First, any time a message is routed from one connection to another
connection, the bus daemon will check permissions with the label of the
first connection as source, label and/or connection name of the second
connection as target, along with the bus name, the path name, the
interface name, and the member name. Reply messages, such as
method_return and error messages, are implicitly allowed if they are in
response to a message that has already been allowed.</p>
<p>
Second, any time a connection asks to own a name, the bus daemon will
check permissions with the label of the connection as source, the
requested name as target, along with the bus name.</p>
<p>
Third, any time a connection attempts to eavesdrop, the bus daemon will
check permissions with the label of the connection as the source, along
with the bus name.</p>
<p>
AppArmor rules for bus mediation are not stored in the bus configuration
files. They are stored in the applications AppArmor profile. Please see
<em>apparmor.d(5)</em> for more details.</p>
</div>
</div>
<div id="outline-container-headline-10" class="outline-2">
<h2 id="headline-10">
DEBUGGING
</h2>
<div id="outline-text-headline-10" class="outline-text-2">
<p>If youre trying to figure out where your messages are going or why you
arent getting messages, there are several things you can try.</p>
<p>
Remember that the system bus is heavily locked down and if you havent
installed a security policy file to allow your message through, it wont
work. For the session bus, this is not a concern.</p>
<p>
The simplest way to figure out whats happening on the bus is to run the
<em>dbus-monitor</em> program, which comes with the D-Bus package. You can also
send test messages with <em>dbus-send</em>. These programs have their own man
pages.</p>
<p>
If you want to know what the daemon itself is doing, you might consider
running a separate copy of the daemon to test against. This will allow
you to put the daemon under a debugger, or run it with verbose output,
without messing up your real session and system daemons.</p>
<p>
To run a separate test copy of the daemon, for example you might open a
terminal and type:</p>
<blockquote>
<pre class="example">
  DBUS_VERBOSE=1 dbus-daemon --session --print-address
</pre>
</blockquote>
<p>
The test daemon address will be printed when the daemon starts. You will
need to copy-and-paste this address and use it as the value of the
DBUS_SESSION_BUS_ADDRESS environment variable when you launch the
applications you want to test. This will cause those applications to
connect to your test bus instead of the DBUS_SESSION_BUS_ADDRESS of your
real session bus.</p>
<p>
DBUS_VERBOSE=1 will have NO EFFECT unless your copy of D-Bus was
compiled with verbose mode enabled. This is not recommended in
production builds due to performance impact. You may need to rebuild
D-Bus if your copy was not built with debugging in mind. (DBUS_VERBOSE
also affects the D-Bus library and thus applications using D-Bus; it may
be useful to see verbose output on both the client side and from the
daemon.)</p>
<p>
If you want to get fancy, you can create a custom bus configuration for
your test bus (see the session.conf and system.conf files that define
the two default configurations for example). This would allow you to
specify a different directory for .service files, for example.</p>
</div>
</div>
<div id="outline-container-headline-11" class="outline-2">
<h2 id="headline-11">
AUTHOR
</h2>
<div id="outline-text-headline-11" class="outline-text-2">
<p>See <strong><a href="http://www.freedesktop.org/software/dbus/doc/AUTHORS">http://www.freedesktop.org/software/dbus/doc/AUTHORS</a></strong></p>
</div>
</div>
<div id="outline-container-headline-12" class="outline-2">
<h2 id="headline-12">
BUGS
</h2>
<div id="outline-text-headline-12" class="outline-text-2">
<p>Please send bug reports to the D-Bus mailing list or bug tracker, see
<strong><a href="http://www.freedesktop.org/software/dbus/">http://www.freedesktop.org/software/dbus/</a></strong></p>
</div>
</div>
<div id="outline-container-headline-13" class="outline-2">
<h2 id="headline-13">
NOTES
</h2>
<div id="outline-text-headline-13" class="outline-text-2">
<dl>
<dt>
1.
</dt>
<dd>relay connections via Secure Shell or a similar protocol

https://lists.freedesktop.org/archives/dbus/2018-April/017447.html</dd>
<dt>
2.
</dt>
<dd>D-Bus Specification

https://dbus.freedesktop.org/doc/dbus-specification.html</dd>
<dt>
3.
</dt>
<dd>polkit

https://www.freedesktop.org/wiki/Software/polkit/</dd>
</dl>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.js"></script>
    </body>
</html>
