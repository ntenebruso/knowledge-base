<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - grep.1 | Technical Notes</title>

    <link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - grep.1</h1>
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
NAME
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>grep - print lines that match patterns</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
SYNOPSIS
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p><strong>grep</strong> [/OPTION/. . .] <em>PATTERNS</em> [/FILE/. . .]<br>
<strong>grep</strong> [/OPTION/. . .] <strong>-e</strong> <em>PATTERNS</em> . . . [/FILE/. . .]<br>
<strong>grep</strong> [/OPTION/. . .] <strong>-f</strong> <em>PATTERN_FILE</em> . . . [/FILE/. . .]</p>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
DESCRIPTION
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p><strong>grep</strong> searches for <em>PATTERNS</em> in each <em>FILE</em>. <em>PATTERNS</em> is one or more
patterns separated by newline characters, and <strong>grep</strong> prints each line
that matches a pattern. Typically <em>PATTERNS</em> should be quoted when
<strong>grep</strong> is used in a shell command.</p>
<p>
A <em>FILE</em> of “*-*” stands for standard input. If no <em>FILE</em> is given,
recursive searches examine the working directory, and nonrecursive
searches read standard input.</p>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
OPTIONS
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<div id="outline-container-headline-5" class="outline-3">
<h3 id="headline-5">
Generic Program Information
</h3>
<div id="outline-text-headline-5" class="outline-text-3">
<dl>
<dt>
<strong>- -help</strong>
</dt>
<dd>Output a usage message and exit.</dd>
<dt>
<strong>-V</strong>, <strong>- -version</strong>
</dt>
<dd>Output the version number of <strong>grep</strong> and exit.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-6" class="outline-3">
<h3 id="headline-6">
Pattern Syntax
</h3>
<div id="outline-text-headline-6" class="outline-text-3">
<dl>
<dt>
<strong>-E</strong>, <strong>- -extended-regexp</strong>
</dt>
<dd>Interpret <em>PATTERNS</em> as extended regular
expressions (EREs, see below).</dd>
<dt>
<strong>-F</strong>, <strong>- -fixed-strings</strong>
</dt>
<dd>Interpret <em>PATTERNS</em> as fixed strings, not
regular expressions.</dd>
<dt>
<strong>-G</strong>, <strong>- -basic-regexp</strong>
</dt>
<dd>Interpret <em>PATTERNS</em> as basic regular
expressions (BREs, see below). This is the default.</dd>
<dt>
<strong>-P</strong>, <strong>- -perl-regexp</strong>
</dt>
<dd>Interpret <em>PATTERNS</em> as Perl-compatible
regular expressions (PCREs). This option is experimental when combined
with the <strong>-z</strong> (<strong>- -null-data</strong>) option, and <strong>grep -P</strong> may warn of
unimplemented features.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-7" class="outline-3">
<h3 id="headline-7">
Matching Control
</h3>
<div id="outline-text-headline-7" class="outline-text-3">
<dl>
<dt>
<strong>-e*/ PATTERNS/</strong>, - -regexp=*/PATTERNS/
</dt>
<dd>Use <em>PATTERNS</em> as the
patterns. If this option is used multiple times or is combined with
the <strong>-f</strong> (<strong>- -file</strong>) option, search for all patterns given. This
option can be used to protect a pattern beginning with “-”.</dd>
<dt>
<strong>-f*/ FILE/</strong>, - -file=*/FILE/
</dt>
<dd>Obtain patterns from <em>FILE</em>, one per
line. If this option is used multiple times or is combined with the
<strong>-e</strong> (<strong>- -regexp</strong>) option, search for all patterns given. The empty
file contains zero patterns, and therefore matches nothing. If <em>FILE</em>
is <strong>-</strong> , read patterns from standard input.</dd>
<dt>
<strong>-i</strong>, <strong>- -ignore-case</strong>
</dt>
<dd>Ignore case distinctions in patterns and
input data, so that characters that differ only in case match each
other.</dd>
<dt>
<strong>- -no-ignore-case</strong>
</dt>
<dd>Do not ignore case distinctions in patterns and
input data. This is the default. This option is useful for passing to
shell scripts that already use <strong>-i</strong>, to cancel its effects because the
two options override each other.</dd>
<dt>
<strong>-v</strong>, <strong>- -invert-match</strong>
</dt>
<dd>Invert the sense of matching, to select
non-matching lines.</dd>
<dt>
<strong>-w</strong>, <strong>- -word-regexp</strong>
</dt>
<dd>Select only those lines containing matches
that form whole words. The test is that the matching substring must
either be at the beginning of the line, or preceded by a non-word
constituent character. Similarly, it must be either at the end of the
line or followed by a non-word constituent character. Word-constituent
characters are letters, digits, and the underscore. This option has no
effect if <strong>-x</strong> is also specified.</dd>
<dt>
<strong>-x</strong>, <strong>- -line-regexp</strong>
</dt>
<dd>Select only those matches that exactly match
the whole line. For a regular expression pattern, this is like
parenthesizing the pattern and then surrounding it with <strong>^</strong> and <strong>$</strong>.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-8" class="outline-3">
<h3 id="headline-8">
General Output Control
</h3>
<div id="outline-text-headline-8" class="outline-text-3">
<dl>
<dt>
<strong>-c</strong>, <strong>- -count</strong>
</dt>
<dd>Suppress normal output; instead print a count of
matching lines for each input file. With the <strong>-v</strong>, <strong>- -invert-match</strong>
option (see above), count non-matching lines.</dd>
<dt>
<strong>- -color</strong>[*=/WHEN/*], <strong>- -colour</strong>[*=/WHEN/*]
</dt>
<dd>Surround the matched
(non-empty) strings, matching lines, context lines, file names, line
numbers, byte offsets, and separators (for fields and groups of
context lines) with escape sequences to display them in color on the
terminal. The colors are defined by the environment variable
<strong>GREP_COLORS</strong>. <em>WHEN</em> is <strong>never</strong>, <strong>always</strong>, or <strong>auto</strong>.</dd>
<dt>
<strong>-L</strong>, <strong>- -files-without-match</strong>
</dt>
<dd>Suppress normal output; instead
print the name of each input file from which no output would normally
have been printed.</dd>
<dt>
<strong>-l</strong>, <strong>- -files-with-matches</strong>
</dt>
<dd>Suppress normal output; instead print
the name of each input file from which output would normally have been
printed. Scanning each input file stops upon first match.</dd>
<dt>
<strong>-m*/ NUM/</strong>, - -max-count=*/NUM/
</dt>
<dd>Stop reading a file after <em>NUM</em>
matching lines. If <em>NUM</em> is zero, <strong>grep</strong> stops right away without
reading input. A <em>NUM</em> of -1 is treated as infinity and <strong>grep</strong> does
not stop; this is the default. If the input is standard input from a
regular file, and <em>NUM</em> matching lines are output, <strong>grep</strong> ensures that
the standard input is positioned to just after the last matching line
before exiting, regardless of the presence of trailing context lines.
This enables a calling process to resume a search. When <strong>grep</strong> stops
after <em>NUM</em> matching lines, it outputs any trailing context lines.
When the <strong>-c</strong> or <strong>- -count</strong> option is also used, <strong>grep</strong> does not
output a count greater than <em>NUM</em>. When the <strong>-v</strong> or <strong>- -invert-match</strong>
option is also used, <strong>grep</strong> stops after outputting <em>NUM</em> non-matching
lines.</dd>
<dt>
<strong>-o</strong>, <strong>- -only-matching</strong>
</dt>
<dd>Print only the matched (non-empty) parts
of a matching line, with each such part on a separate output line.</dd>
<dt>
<strong>-q</strong>, <strong>- -quiet</strong>, <strong>- -silent</strong>
</dt>
<dd>Quiet; do not write anything to
standard output. Exit immediately with zero status if any match is
found, even if an error was detected. Also see the <strong>-s</strong> or
<strong>- -no-messages</strong> option.</dd>
<dt>
<strong>-s</strong>, <strong>- -no-messages</strong>
</dt>
<dd>Suppress error messages about nonexistent or
unreadable files.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-9" class="outline-3">
<h3 id="headline-9">
Output Line Prefix Control
</h3>
<div id="outline-text-headline-9" class="outline-text-3">
<dl>
<dt>
<strong>-b</strong>, <strong>- -byte-offset</strong>
</dt>
<dd>Print the 0-based byte offset within the
input file before each line of output. If <strong>-o</strong> (<strong>- -only-matching</strong>) is
specified, print the offset of the matching part itself.</dd>
<dt>
<strong>-H</strong>, <strong>- -with-filename</strong>
</dt>
<dd>Print the file name for each match. This
is the default when there is more than one file to search. This is a
GNU extension.</dd>
<dt>
<strong>-h</strong>, <strong>- -no-filename</strong>
</dt>
<dd>Suppress the prefixing of file names on
output. This is the default when there is only one file (or only
standard input) to search.</dd>
<dt>
*- -label=*/LABEL/
</dt>
<dd>Display input actually coming from standard
input as input coming from file <em>LABEL</em>. This can be useful for
commands that transform a file&#39;s contents before searching, e.g.,
<strong>gzip -cd foo.gz | grep - -label=foo -H &#39;some pattern&#39;</strong>. See also the
<strong>-H</strong> option.</dd>
<dt>
<strong>-n</strong>, <strong>- -line-number</strong>
</dt>
<dd>Prefix each line of output with the 1-based
line number within its input file.</dd>
<dt>
<strong>-T</strong>, <strong>- -initial-tab</strong>
</dt>
<dd>Make sure that the first character of actual
line content lies on a tab stop, so that the alignment of tabs looks
normal. This is useful with options that prefix their output to the
actual content: <strong>-H</strong>,*-n*, and <strong>-b</strong>. In order to improve the
probability that lines from a single file will all start at the same
column, this also causes the line number and byte offset (if present)
to be printed in a minimum size field width.</dd>
<dt>
<strong>-Z</strong>, <strong>- -null</strong>
</dt>
<dd>Output a zero byte (the ASCII <strong>NUL</strong> character)
instead of the character that normally follows a file name. For
example, <strong>grep -lZ</strong> outputs a zero byte after each file name instead
of the usual newline. This option makes the output unambiguous, even
in the presence of file names containing unusual characters like
newlines. This option can be used with commands like <strong>find -print0</strong>,
<strong>perl -0</strong>, <strong>sort -z</strong>, and <strong>xargs -0</strong> to process arbitrary file names,
even those that contain newline characters.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-10" class="outline-3">
<h3 id="headline-10">
Context Line Control
</h3>
<div id="outline-text-headline-10" class="outline-text-3">
<dl>
<dt>
<strong>-A*/ NUM/</strong>, - -after-context=*/NUM/
</dt>
<dd>Print <em>NUM</em> lines of trailing
context after matching lines. Places a line containing a group
separator (<strong>- -</strong>) between contiguous groups of matches. With the <strong>-o</strong>
or <strong>- -only-matching</strong> option, this has no effect and a warning is
given.</dd>
<dt>
<strong>-B*/ NUM/</strong>, - -before-context=*/NUM/
</dt>
<dd>Print <em>NUM</em> lines of leading
context before matching lines. Places a line containing a group
separator (<strong>- -</strong>) between contiguous groups of matches. With the <strong>-o</strong>
or <strong>- -only-matching</strong> option, this has no effect and a warning is
given.</dd>
<dt>
<strong>-C*/ NUM/</strong>, -<strong><em>NUM</em></strong>, - -context=*/NUM/
</dt>
<dd>Print <em>NUM</em> lines of
output context. Places a line containing a group separator (<strong>- -</strong>)
between contiguous groups of matches. With the <strong>-o</strong> or
<strong>- -only-matching</strong> option, this has no effect and a warning is given.</dd>
<dt>
*- -group-separator=*/SEP/
</dt>
<dd>When <strong>-A</strong>, <strong>-B</strong>, or <strong>-C</strong> are in use,
print <em>SEP</em> instead of <strong>- -</strong> between groups of lines.</dd>
<dt>
<strong>- -no-group-separator</strong>
</dt>
<dd>When <strong>-A</strong>, <strong>-B</strong>, or <strong>-C</strong> are in use, do not
print a separator between groups of lines.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-11" class="outline-3">
<h3 id="headline-11">
File and Directory Selection
</h3>
<div id="outline-text-headline-11" class="outline-text-3">
<dl>
<dt>
<strong>-a</strong>, <strong>- -text</strong>
</dt>
<dd>Process a binary file as if it were text; this is
equivalent to the <strong>- -binary-files=text</strong> option.</dd>
<dt>
*- -binary-files=*/TYPE/
</dt>
<dd>If a file&#39;s data or metadata indicate that
the file contains binary data, assume that the file is of type <em>TYPE</em>.
Non-text bytes indicate binary data; these are either output bytes
that are improperly encoded for the current locale, or null input
bytes when the <strong>-z</strong> option is not given.

By default, <em>TYPE</em> is <strong>binary</strong>, and <strong>grep</strong> suppresses output after
null input binary data is discovered, and suppresses output lines that
contain improperly encoded data. When some output is suppressed,
<strong>grep</strong> follows any output with a message to standard error saying that
a binary file matches.

If <em>TYPE</em> is <strong>without-match</strong>, when <strong>grep</strong> discovers null input binary
data it assumes that the rest of the file does not match; this is
equivalent to the <strong>-I</strong> option.

If <em>TYPE</em> is <strong>text</strong>, <strong>grep</strong> processes a binary file as if it were
text; this is equivalent to the <strong>-a</strong> option.

When <em>type</em> is <strong>binary</strong>, <strong>grep</strong> may treat non-text bytes as line
terminators even without the <strong>-z</strong> option. This means choosing <strong>binary</strong>
versus <strong>text</strong> can affect whether a pattern matches a file. For
example, when <em>type</em> is <strong>binary</strong> the pattern <strong>q$ might</strong> match <strong>q</strong>
immediately followed by a null byte, even though this is not matched
when <em>type</em> is <strong>text</strong>. Conversely, when <em>type</em> is <strong>binary</strong> the pattern
<strong>.</strong> (period) might not match a null byte.

<em>Warning:</em> The <strong>-a</strong> option might output binary garbage, which can have
nasty side effects if the output is a terminal and if the terminal
driver interprets some of it as commands. On the other hand, when
reading files whose text encodings are unknown, it can be helpful to
use <strong>-a</strong> or to set <strong>LC_ALL=&#39;C&#39;</strong> in the environment, in order to find
more matches even if the matches are unsafe for direct display.</dd>
<dt>
<strong>-D*/ ACTION/</strong>, - -devices=*/ACTION/
</dt>
<dd>If an input file is a device,
FIFO or socket, use <em>ACTION</em> to process it. By default, <em>ACTION</em> is
<strong>read</strong>, which means that devices are read just as if they were
ordinary files. If <em>ACTION</em> is <strong>skip</strong>, devices are silently skipped.</dd>
<dt>
<strong>-d*/ ACTION/</strong>, - -directories=*/ACTION/
</dt>
<dd>If an input file is a
directory, use <em>ACTION</em> to process it. By default, <em>ACTION</em> is <strong>read</strong>,
i.e., read directories just as if they were ordinary files. If
<em>ACTION</em> is <strong>skip</strong>, silently skip directories. If <em>ACTION</em> is
<strong>recurse</strong>, read all files under each directory, recursively, following
symbolic links only if they are on the command line. This is
equivalent to the <strong>-r</strong> option.</dd>
<dt>
*- -exclude=*/GLOB/
</dt>
<dd>Skip any command-line file with a name suffix
that matches the pattern <em>GLOB</em>, using wildcard matching; a name
suffix is either the whole name, or a trailing part that starts with a
non-slash character immediately after a slash (<strong>/</strong>) in the name. When
searching recursively, skip any subfile whose base name matches
<em>GLOB</em>; the base name is the part after the last slash. A pattern can
use <strong>*</strong>, <strong>?</strong>, and <strong>[</strong>. . .*]* as wildcards, and <strong>\</strong> to quote a
wildcard or backslash character literally.</dd>
<dt>
*- -exclude-from=*/FILE/
</dt>
<dd>Skip files whose base name matches any of
the file-name globs read from <em>FILE</em> (using wildcard matching as
described under <strong>- -exclude</strong>).</dd>
<dt>
*- -exclude-dir=*/GLOB/
</dt>
<dd>Skip any command-line directory with a name
suffix that matches the pattern <em>GLOB</em>. When searching recursively,
skip any subdirectory whose base name matches <em>GLOB</em>. Ignore any
redundant trailing slashes in <em>GLOB</em>.</dd>
<dt>
<strong>-I</strong>
</dt>
<dd>Process a binary file as if it did not contain matching data;
this is equivalent to the <strong>- -binary-files=without-match</strong> option.</dd>
<dt>
*- -include=*/GLOB/
</dt>
<dd>Search only files whose base name matches
<em>GLOB</em> (using wildcard matching as described under <strong>- -exclude</strong>). If
contradictory <strong>- -include</strong> and <strong>- -exclude</strong> options are given, the
last matching one wins. If no <strong>- -include</strong> or <strong>- -exclude</strong> options
match, a file is included unless the first such option is
<strong>- -include</strong>.</dd>
<dt>
<strong>-r</strong>, <strong>- -recursive</strong>
</dt>
<dd>Read all files under each directory,
recursively, following symbolic links only if they are on the command
line. Note that if no file operand is given, <strong>grep</strong> searches the
working directory. This is equivalent to the <strong>-d recurse</strong> option.</dd>
<dt>
<strong>-R</strong>, <strong>- -dereference-recursive</strong>
</dt>
<dd>Read all files under each
directory, recursively. Follow all symbolic links, unlike <strong>-r</strong>.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-12" class="outline-3">
<h3 id="headline-12">
Other Options
</h3>
<div id="outline-text-headline-12" class="outline-text-3">
<dl>
<dt>
<strong>- -line-buffered</strong>
</dt>
<dd>Use line buffering on output. This can cause a
performance penalty.</dd>
<dt>
<strong>-U</strong>, <strong>- -binary</strong>
</dt>
<dd>Treat the file(s) as binary. By default, under
MS-DOS and MS-Windows, <strong>grep</strong> guesses whether a file is text or binary
as described for the <strong>- -binary-files</strong> option. If <strong>grep</strong> decides the
file is a text file, it strips the CR characters from the original
file contents (to make regular expressions with <strong>^</strong> and <strong>$</strong> work
correctly). Specifying <strong>-U</strong> overrules this guesswork, causing all
files to be read and passed to the matching mechanism verbatim; if the
file is a text file with CR/LF pairs at the end of each line, this
will cause some regular expressions to fail. This option has no effect
on platforms other than MS-DOS and MS-Windows.</dd>
<dt>
<strong>-z</strong>, <strong>- -null-data</strong>
</dt>
<dd>Treat input and output data as sequences of
lines, each terminated by a zero byte (the ASCII NUL character)
instead of a newline. Like the <strong>-Z</strong> or <strong>- -null</strong> option, this option
can be used with commands like <strong>sort -z</strong> to process arbitrary file
names.</dd>
</dl>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-13" class="outline-2">
<h2 id="headline-13">
REGULAR EXPRESSIONS
</h2>
<div id="outline-text-headline-13" class="outline-text-2">
<p>A regular expression is a pattern that describes a set of strings.
Regular expressions are constructed analogously to arithmetic
expressions, by using various operators to combine smaller expressions.</p>
<p>
<strong>grep</strong> understands three different versions of regular expression
syntax: “basic” (BRE), “extended” (ERE) and “perl” (PCRE). In GNU
<strong>grep</strong>, basic and extended regular expressions are merely different
notations for the same pattern-matching functionality. In other
implementations, basic regular expressions are ordinarily less powerful
than extended, though occasionally it is the other way around. The
following description applies to extended regular expressions;
differences for basic regular expressions are summarized afterwards.
Perl-compatible regular expressions have different functionality, and
are documented in *pcre2syntax*(3) and *pcre2pattern*(3), but work only
if PCRE support is enabled.</p>
<p>
The fundamental building blocks are the regular expressions that match a
single character. Most characters, including all letters and digits, are
regular expressions that match themselves. Any meta-character with
special meaning may be quoted by preceding it with a backslash.</p>
<p>
The period <strong>.</strong> matches any single character. It is unspecified whether
it matches an encoding error.</p>
<div id="outline-container-headline-14" class="outline-3">
<h3 id="headline-14">
Character Classes and Bracket Expressions
</h3>
<div id="outline-text-headline-14" class="outline-text-3">
<p>A <em>bracket expression</em> is a list of characters enclosed by <strong>[</strong> and <strong>]</strong>.
It matches any single character in that list. If the first character of
the list is the caret <strong>^</strong> then it matches any character <em>not</em> in the
list; it is unspecified whether it matches an encoding error. For
example, the regular expression <strong>[0123456789]</strong> matches any single digit.</p>
<p>
Within a bracket expression, a <em>range expression</em> consists of two
characters separated by a hyphen. It matches any single character that
sorts between the two characters, inclusive, using the locale&#39;s
collating sequence and character set. For example, in the default C
locale, <strong>[a-d]</strong> is equivalent to <strong>[abcd]</strong>. Many locales sort characters
in dictionary order, and in these locales <strong>[a-d]</strong> is typically not
equivalent to <strong>[abcd]</strong>; it might be equivalent to <strong>[aBbCcDd]</strong>, for
example. To obtain the traditional interpretation of bracket
expressions, you can use the C locale by setting the <strong>LC_ALL</strong>
environment variable to the value <strong>C</strong>.</p>
<p>
Finally, certain named classes of characters are predefined within
bracket expressions, as follows. Their names are self explanatory, and
they are <strong>[:alnum:]</strong>, <strong>[:alpha:]</strong>, <strong>[:blank:]</strong>, <strong>[:cntrl:]</strong>,
<strong>[:digit:]</strong>, <strong>[:graph:]</strong>, <strong>[:lower:]</strong>, <strong>[:print:]</strong>, <strong>[:punct:]</strong>,
<strong>[:space:]</strong>, <strong>[:upper:]</strong>, and <strong>[:xdigit:]</strong>. For example, <strong><a href=":alnum:">:alnum:</a></strong>
means the character class of numbers and letters in the current locale.
In the C locale and ASCII character set encoding, this is the same as
<strong>[0-9A-Za-z]</strong>. (Note that the brackets in these class names are part of
the symbolic names, and must be included in addition to the brackets
delimiting the bracket expression.) Most meta-characters lose their
special meaning inside bracket expressions. To include a literal <strong>]</strong>
place it first in the list. Similarly, to include a literal <strong>^</strong> place it
anywhere but first. Finally, to include a literal <strong>-</strong> place it last.</p>
</div>
</div>
<div id="outline-container-headline-15" class="outline-3">
<h3 id="headline-15">
Anchoring
</h3>
<div id="outline-text-headline-15" class="outline-text-3">
<p>The caret <strong>^</strong> and the dollar sign <strong>$</strong> are meta-characters that
respectively match the empty string at the beginning and end of a line.</p>
</div>
</div>
<div id="outline-container-headline-16" class="outline-3">
<h3 id="headline-16">
The Backslash Character and Special Expressions
</h3>
<div id="outline-text-headline-16" class="outline-text-3">
<p>The symbols <strong>\&lt;</strong> and <strong>\&gt;</strong> respectively match the empty string at the
beginning and end of a word. The symbol <strong>\b</strong> matches the empty string at
the edge of a word, and <strong>\B</strong> matches the empty string provided it&#39;s
<em>not</em> at the edge of a word. The symbol <strong>\w</strong> is a synonym for
<strong>[_[:alnum:]]</strong> and <strong>\W</strong> is a synonym for <strong>[^_[:alnum:]]</strong>.</p>
</div>
</div>
<div id="outline-container-headline-17" class="outline-3">
<h3 id="headline-17">
Repetition
</h3>
<div id="outline-text-headline-17" class="outline-text-3">
<p>A regular expression may be followed by one of several repetition
operators:</p>
<dl>
<dt>
<strong>?</strong>
</dt>
<dd>The preceding item is optional and matched at most once.</dd>
<dt>
<strong>*</strong>
</dt>
<dd>The preceding item will be matched zero or more times.</dd>
<dt>
<strong>+</strong>
</dt>
<dd>The preceding item will be matched one or more times.</dd>
<dt>
<strong>{*/n/</strong>}*
</dt>
<dd>The preceding item is matched exactly <em>n</em> times.</dd>
<dt>
<strong>{*/n/</strong>,}*
</dt>
<dd>The preceding item is matched <em>n</em> or more times.</dd>
<dt>
<strong>{,*/m/</strong>}*
</dt>
<dd>The preceding item is matched at most <em>m</em> times. This is
a GNU extension.</dd>
<dt>
<strong>{*/n/</strong>,*/m/*}*
</dt>
<dd>The preceding item is matched at least <em>n</em> times,
but not more than <em>m</em> times.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-18" class="outline-3">
<h3 id="headline-18">
Concatenation
</h3>
<div id="outline-text-headline-18" class="outline-text-3">
<p>Two regular expressions may be concatenated; the resulting regular
expression matches any string formed by concatenating two substrings
that respectively match the concatenated expressions.</p>
</div>
</div>
<div id="outline-container-headline-19" class="outline-3">
<h3 id="headline-19">
Alternation
</h3>
<div id="outline-text-headline-19" class="outline-text-3">
<p>Two regular expressions may be joined by the infix operator <strong>|</strong>; the
resulting regular expression matches any string matching either
alternate expression.</p>
</div>
</div>
<div id="outline-container-headline-20" class="outline-3">
<h3 id="headline-20">
Precedence
</h3>
<div id="outline-text-headline-20" class="outline-text-3">
<p>Repetition takes precedence over concatenation, which in turn takes
precedence over alternation. A whole expression may be enclosed in
parentheses to override these precedence rules and form a subexpression.</p>
</div>
</div>
<div id="outline-container-headline-21" class="outline-3">
<h3 id="headline-21">
Back-references and Subexpressions
</h3>
<div id="outline-text-headline-21" class="outline-text-3">
<p>The back-reference *\*/n/ , where <em>n</em> is a single digit, matches the
substring previously matched by the /n/th parenthesized subexpression of
the regular expression.</p>
</div>
</div>
<div id="outline-container-headline-22" class="outline-3">
<h3 id="headline-22">
Basic vs Extended Regular Expressions
</h3>
<div id="outline-text-headline-22" class="outline-text-3">
<p>In basic regular expressions the meta-characters <strong>?</strong>, <strong>+</strong>, <strong>{</strong>, <strong>|</strong>,
<strong>(</strong>, and <strong>)</strong> lose their special meaning; instead use the backslashed
versions <strong>\?</strong>, <strong>\+</strong>, <strong>\{</strong>, <strong>\|</strong>, <strong>\(</strong>, and <strong>\)</strong>.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-23" class="outline-2">
<h2 id="headline-23">
EXIT STATUS
</h2>
<div id="outline-text-headline-23" class="outline-text-2">
<p>Normally the exit status is 0 if a line is selected, 1 if no lines were
selected, and 2 if an error occurred. However, if the <strong>-q</strong> or <strong>- -quiet</strong>
or <strong>- -silent</strong> is used and a line is selected, the exit status is 0 even
if an error occurred.</p>
</div>
</div>
<div id="outline-container-headline-24" class="outline-2">
<h2 id="headline-24">
ENVIRONMENT
</h2>
<div id="outline-text-headline-24" class="outline-text-2">
<p>The behavior of <strong>grep</strong> is affected by the following environment
variables.</p>
<p>
The locale for category <strong>LC_*/foo/ is specified by examining the three
environment variables *LC_ALL</strong>, <strong>LC_/foo/</strong>, <strong>LANG</strong>, in that order. The
first of these variables that is set specifies the locale. For example,
if <strong>LC_ALL</strong> is not set, but <strong>LC_MESSAGES</strong> is set to <strong>pt_BR</strong>, then the
Brazilian Portuguese locale is used for the <strong>LC_MESSAGES</strong> category. The
C locale is used if none of these environment variables are set, if the
locale catalog is not installed, or if <strong>grep</strong> was not compiled with
national language support (NLS). The shell command <strong>locale -a</strong> lists
locales that are currently available.</p>
<dl>
<dt>
<strong>GREP_COLORS</strong>
</dt>
<dd>
<p>Controls how the <strong>- -color</strong> option highlights output.
Its value is a colon-separated list of capabilities that defaults to
<strong>ms=01;31:mc=01;31:sl=:cx=:fn=35:ln=32:bn=32:se=36</strong> with the <strong>rv</strong> and
<strong>ne</strong> boolean capabilities omitted (i.e., false). Supported
capabilities are as follows.</p>
<dl>
<dt>
<strong>sl=</strong>
</dt>
<dd>SGR substring for whole selected lines (i.e., matching
lines when the <strong>-v</strong> command-line option is omitted, or non-matching
lines when <strong>-v</strong> is specified). If however the boolean <strong>rv</strong>
capability and the <strong>-v</strong> command-line option are both specified, it
applies to context matching lines instead. The default is empty
(i.e., the terminal&#39;s default color pair).</dd>
<dt>
<strong>cx=</strong>
</dt>
<dd>SGR substring for whole context lines (i.e., non-matching
lines when the <strong>-v</strong> command-line option is omitted, or matching
lines when <strong>-v</strong> is specified). If however the boolean <strong>rv</strong>
capability and the <strong>-v</strong> command-line option are both specified, it
applies to selected non-matching lines instead. The default is empty
(i.e., the terminal&#39;s default color pair).</dd>
<dt>
<strong>rv</strong>
</dt>
<dd>Boolean value that reverses (swaps) the meanings of the
<strong>sl=</strong> and <strong>cx=</strong> capabilities when the <strong>-v</strong> command-line option is
specified. The default is false (i.e., the capability is omitted).</dd>
<dt>
<strong>mt=01;31</strong>
</dt>
<dd>SGR substring for matching non-empty text in any
matching line (i.e., a selected line when the <strong>-v</strong> command-line
option is omitted, or a context line when <strong>-v</strong> is specified).
Setting this is equivalent to setting both <strong>ms=</strong> and <strong>mc=</strong> at once
to the same value. The default is a bold red text foreground over
the current line background.</dd>
<dt>
<strong>ms=01;31</strong>
</dt>
<dd>SGR substring for matching non-empty text in a
selected line. (This is only used when the <strong>-v</strong> command-line option
is omitted.) The effect of the <strong>sl=</strong> (or <strong>cx=</strong> if <strong>rv</strong>) capability
remains active when this kicks in. The default is a bold red text
foreground over the current line background.</dd>
<dt>
<strong>mc=01;31</strong>
</dt>
<dd>SGR substring for matching non-empty text in a context
line. (This is only used when the <strong>-v</strong> command-line option is
specified.) The effect of the <strong>cx=</strong> (or <strong>sl=</strong> if <strong>rv</strong>) capability
remains active when this kicks in. The default is a bold red text
foreground over the current line background.</dd>
<dt>
<strong>fn=35</strong>
</dt>
<dd>SGR substring for file names prefixing any content line.
The default is a magenta text foreground over the terminal&#39;s default
background.</dd>
<dt>
<strong>ln=32</strong>
</dt>
<dd>SGR substring for line numbers prefixing any content
line. The default is a green text foreground over the terminal&#39;s
default background.</dd>
<dt>
<strong>bn=32</strong>
</dt>
<dd>SGR substring for byte offsets prefixing any content
line. The default is a green text foreground over the terminal&#39;s
default background.</dd>
<dt>
<strong>se=36</strong>
</dt>
<dd>SGR substring for separators that are inserted between
selected line fields (<strong>:</strong>), between context line fields, (<strong>-</strong>), and
between groups of adjacent lines when nonzero context is specified
(<strong>- -</strong>). The default is a cyan text foreground over the terminal&#39;s
default background.</dd>
<dt>
<strong>ne</strong>
</dt>
<dd>Boolean value that prevents clearing to the end of line
using Erase in Line (EL) to Right (<strong>\33[K</strong>) each time a colorized
item ends. This is needed on terminals on which EL is not supported.
It is otherwise useful on terminals for which the <strong>back_color_erase</strong>
(<strong>bce</strong>) boolean terminfo capability does not apply, when the chosen
highlight colors do not affect the background, or when EL is too
slow or causes too much flicker. The default is false (i.e., the
capability is omitted).</dd>
</dl>
<p>Note that boolean capabilities have no <strong>=</strong>. . . part. They are omitted
(i.e., false) by default and become true when specified.</p>
<p>
See the Select Graphic Rendition (SGR) section in the documentation of
the text terminal that is used for permitted values and their meaning
as character attributes. These substring values are integers in
decimal representation and can be concatenated with semicolons. <strong>grep</strong>
takes care of assembling the result into a complete SGR sequence
(<strong>\33[</strong>. . .*m*). Common values to concatenate include <strong>1</strong> for bold,
<strong>4</strong> for underline, <strong>5</strong> for blink, <strong>7</strong> for inverse, <strong>39</strong> for default
foreground color, <strong>30</strong> to <strong>37</strong> for foreground colors, <strong>90</strong> to <strong>97</strong> for
16-color mode foreground colors, <strong>38;5;0</strong> to <strong>38;5;255</strong> for 88-color
and 256-color modes foreground colors, <strong>49</strong> for default background
color, <strong>40</strong> to <strong>47</strong> for background colors, <strong>100</strong> to <strong>107</strong> for 16-color
mode background colors, and <strong>48;5;0</strong> to <strong>48;5;255</strong> for 88-color and
256-color modes background colors.</p>
</dd>
<dt>
<strong>LC_ALL</strong>, <strong>LC_COLLATE</strong>, <strong>LANG</strong>
</dt>
<dd>These variables specify the locale
for the <strong>LC_COLLATE</strong> category, which determines the collating sequence
used to interpret range expressions like <strong>[a-z]</strong>.</dd>
<dt>
<strong>LC_ALL</strong>, <strong>LC_CTYPE</strong>, <strong>LANG</strong>
</dt>
<dd>These variables specify the locale for
the <strong>LC_CTYPE</strong> category, which determines the type of characters,
e.g., which characters are whitespace. This category also determines
the character encoding, that is, whether text is encoded in UTF-8,
ASCII, or some other encoding. In the C or POSIX locale, all
characters are encoded as a single byte and every byte is a valid
character.</dd>
<dt>
<strong>LC_ALL</strong>, <strong>LC_MESSAGES</strong>, <strong>LANG</strong>
</dt>
<dd>These variables specify the locale
for the <strong>LC_MESSAGES</strong> category, which determines the language that
<strong>grep</strong> uses for messages. The default C locale uses American English
messages.</dd>
<dt>
<strong>POSIXLY_CORRECT</strong>
</dt>
<dd>If set, <strong>grep</strong> behaves as POSIX requires;
otherwise, <strong>grep</strong> behaves more like other GNU programs. POSIX requires
that options that follow file names must be treated as file names; by
default, such options are permuted to the front of the operand list
and are treated as options. Also, POSIX requires that unrecognized
options be diagnosed as “illegal”, but since they are not really
against the law the default is to diagnose them as “invalid”.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-25" class="outline-2">
<h2 id="headline-25">
NOTES
</h2>
<div id="outline-text-headline-25" class="outline-text-2">
<p>This man page is maintained only fitfully; the full documentation is
often more up-to-date.</p>
</div>
</div>
<div id="outline-container-headline-26" class="outline-2">
<h2 id="headline-26">
COPYRIGHT
</h2>
<div id="outline-text-headline-26" class="outline-text-2">
<p>Copyright 1998-2000, 2002, 2005-2023 Free Software Foundation, Inc.</p>
<p>
This is free software; see the source for copying conditions. There is
NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.</p>
</div>
</div>
<div id="outline-container-headline-27" class="outline-2">
<h2 id="headline-27">
BUGS
</h2>
<div id="outline-text-headline-27" class="outline-text-2">
<div id="outline-container-headline-28" class="outline-3">
<h3 id="headline-28">
Reporting Bugs
</h3>
<div id="outline-text-headline-28" class="outline-text-3">
<p>Email bug reports to <a href="mailto:bug-grep@gnu.org">the bug-reporting
address</a>. An <a href="https://lists.gnu.org/mailman/listinfo/bug-grep">email
archive</a> and a
<a href="https://debbugs.gnu.org/cgi/pkgreport.cgi?package=grep">bug tracker</a>
are available.</p>
</div>
</div>
<div id="outline-container-headline-29" class="outline-3">
<h3 id="headline-29">
Known Bugs
</h3>
<div id="outline-text-headline-29" class="outline-text-3">
<p>Large repetition counts in the <strong>{*/n/</strong>,*/m/*}* construct may cause
<strong>grep</strong> to use lots of memory. In addition, certain other obscure regular
expressions require exponential time and space, and may cause <strong>grep</strong> to
run out of memory.</p>
<p>
Back-references are very slow, and may require exponential time.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-30" class="outline-2">
<h2 id="headline-30">
EXAMPLE
</h2>
<div id="outline-text-headline-30" class="outline-text-2">
<p>The following example outputs the location and contents of any line
containing “f” and ending in “.c”, within all files in the current
directory whose names contain “g” and end in “.h”. The <strong>-n</strong> option
outputs line numbers, the <strong>–</strong> argument treats expansions of “*g*.h”
starting with “-” as file names not options, and the empty file
/dev/null causes file names to be output even if only one file name
happens to be of the form “*g*.h”.</p>
<pre class="example">
$ grep -n -- &#39;f.*\.c$&#39; *g*.h /dev/null
argmatch.h:1:/* definitions and prototypes for argmatch.c
</pre>
<p>
The only line that matches is line 1 of argmatch.h. Note that the
regular expression syntax used in the pattern differs from the globbing
syntax that the shell uses to match file names.</p>
</div>
</div>
<div id="outline-container-headline-31" class="outline-2">
<h2 id="headline-31">
SEE ALSO
</h2>
<div id="outline-text-headline-31" class="outline-text-2">
<div id="outline-container-headline-32" class="outline-3">
<h3 id="headline-32">
Regular Manual Pages
</h3>
<div id="outline-text-headline-32" class="outline-text-3">
<p>*awk*(1), *cmp*(1), *diff*(1), *find*(1), *perl*(1), *sed*(1),
*sort*(1), *xargs*(1), *read*(2), *pcre2*(3), *pcre2syntax*(3),
*pcre2pattern*(3), *terminfo*(5), *glob*(7), *regex*(7)</p>
</div>
</div>
<div id="outline-container-headline-33" class="outline-3">
<h3 id="headline-33">
Full Documentation
</h3>
<div id="outline-text-headline-33" class="outline-text-3">
<p>A <a href="https://www.gnu.org/software/grep/manual/">complete manual</a> is
available. If the <strong>info</strong> and <strong>grep</strong> programs are properly installed at
your site, the command</p>
<blockquote>
<p><strong>info grep</strong></p>
</blockquote>
<p>
should give you access to the complete manual.\\</p>
</div>
</div>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.js"></script>
    </body>
</html>
