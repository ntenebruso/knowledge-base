<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - find.1 | Technical Notes</title>

    <link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - find.1</h1>
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
NAME
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>find - search for files in a directory hierarchy</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
SYNOPSIS
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p><strong>find</strong> [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point…]
[expression]</p>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
DESCRIPTION
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p>This manual page documents the GNU version of <strong>find</strong>. GNU <strong>find</strong>
searches the directory tree rooted at each given starting-point by
evaluating the given expression from left to right, according to the
rules of precedence (see section OPERATORS), until the outcome is known
(the left hand side is false for <em>and</em> operations, true for <em>or</em>), at
which point <strong>find</strong> moves on to the next file name. If no starting-point
is specified, `.&#39; is assumed.</p>
<p>
If you are using <strong>find</strong> in an environment where security is important
(for example if you are using it to search directories that are writable
by other users), you should read the `Security Considerations&#39; chapter
of the findutils documentation, which is called <strong>Finding Files</strong> and
comes with findutils. That document also includes a lot more detail and
discussion than this manual page, so you may find it a more useful
source of information.</p>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
OPTIONS
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<p>The <strong>-H</strong>, <strong>-L</strong> and <strong>-P</strong> options control the treatment of symbolic links.
Command-line arguments following these are taken to be names of files or
directories to be examined, up to the first argument that begins with
`-&#39;, or the argument `(&#39; or `!&#39;. That argument and any following
arguments are taken to be the expression describing what is to be
searched for. If no paths are given, the current directory is used. If
no expression is given, the expression <strong>-print</strong> is used (but you should
probably consider using <strong>-print0</strong> instead, anyway).</p>
<p>
This manual page talks about `options&#39; within the expression list. These
options control the behaviour of <strong>find</strong> but are specified immediately
after the last path name. The five `real&#39; options <strong>-H</strong>, <strong>-L</strong>, <strong>-P</strong>, <strong>-D</strong>
and <strong>-O</strong> must appear before the first path name, if at all. A double
dash <strong>–</strong> could theoretically be used to signal that any remaining
arguments are not options, but this does not really work due to the way
<strong>find</strong> determines the end of the following path arguments: it does that
by reading until an expression argument comes (which also starts with a
`-&#39;). Now, if a path argument would start with a `-&#39;, then <strong>find</strong> would
treat it as expression argument instead. Thus, to ensure that all start
points are taken as such, and especially to prevent that wildcard
patterns expanded by the calling shell are not mistakenly treated as
expression arguments, it is generally safer to prefix wildcards or
dubious path names with either `./&#39; or to use absolute path names
starting with &#39;/&#39;. Alternatively, it is generally safe though
non-portable to use the GNU option <strong>-files0-from</strong> to pass arbitrary
starting points to <strong>find</strong>.</p>
<dl>
<dt>
-P
</dt>
<dd>Never follow symbolic links. This is the default behaviour. When
<strong>find</strong> examines or prints information about files, and the file is a
symbolic link, the information used shall be taken from the properties
of the symbolic link itself.</dd>
<dt>
-L
</dt>
<dd>Follow symbolic links. When <strong>find</strong> examines or prints
information about files, the information used shall be taken from the
properties of the file to which the link points, not from the link
itself (unless it is a broken symbolic link or <strong>find</strong> is unable to
examine the file to which the link points). Use of this option implies
<strong>-noleaf</strong>. If you later use the <strong>-P</strong> option, <strong>-noleaf</strong> will still be
in effect. If <strong>-L</strong> is in effect and <strong>find</strong> discovers a symbolic link
to a subdirectory during its search, the subdirectory pointed to by
the symbolic link will be searched.

When the <strong>-L</strong> option is in effect, the <strong>-type</strong> predicate will always
match against the type of the file that a symbolic link points to
rather than the link itself (unless the symbolic link is broken).
Actions that can cause symbolic links to become broken while <strong>find</strong> is
executing (for example <strong>-delete</strong>) can give rise to confusing
behaviour. Using <strong>-L</strong> causes the <strong>-lname</strong> and <strong>-ilname</strong> predicates
always to return false.</dd>
<dt>
-H
</dt>
<dd>Do not follow symbolic links, except while processing the
command line arguments. When <strong>find</strong> examines or prints information
about files, the information used shall be taken from the properties
of the symbolic link itself. The only exception to this behaviour is
when a file specified on the command line is a symbolic link, and the
link can be resolved. For that situation, the information used is
taken from whatever the link points to (that is, the link is
followed). The information about the link itself is used as a fallback
if the file pointed to by the symbolic link cannot be examined. If
<strong>-H</strong> is in effect and one of the paths specified on the command line
is a symbolic link to a directory, the contents of that directory will
be examined (though of course <strong>-maxdepth 0</strong> would prevent this).</dd>
</dl>
<p>If more than one of <strong>-H</strong>, <strong>-L</strong> and <strong>-P</strong> is specified, each overrides the
others; the last one appearing on the command line takes effect. Since
it is the default, the <strong>-P</strong> option should be considered to be in effect
unless either <strong>-H</strong> or <strong>-L</strong> is specified.</p>
<p>
GNU <strong>find</strong> frequently stats files during the processing of the command
line itself, before any searching has begun. These options also affect
how those arguments are processed. Specifically, there are a number of
tests that compare files listed on the command line against a file we
are currently considering. In each case, the file specified on the
command line will have been examined and some of its properties will
have been saved. If the named file is in fact a symbolic link, and the
<strong>-P</strong> option is in effect (or if neither <strong>-H</strong> nor <strong>-L</strong> were specified),
the information used for the comparison will be taken from the
properties of the symbolic link. Otherwise, it will be taken from the
properties of the file the link points to. If <strong>find</strong> cannot follow the
link (for example because it has insufficient privileges or the link
points to a nonexistent file) the properties of the link itself will be
used.</p>
<p>
When the <strong>-H</strong> or <strong>-L</strong> options are in effect, any symbolic links listed
as the argument of <strong>-newer</strong> will be dereferenced, and the timestamp will
be taken from the file to which the symbolic link points. The same
consideration applies to <strong>-newerXY</strong>, <strong>-anewer</strong> and <strong>-cnewer</strong>.</p>
<p>
The <strong>-follow</strong> option has a similar effect to <strong>-L</strong>, though it takes
effect at the point where it appears (that is, if <strong>-L</strong> is not used but
<strong>-follow</strong> is, any symbolic links appearing after <strong>-follow</strong> on the
command line will be dereferenced, and those before it will not).</p>
<dl>
<dt>
-D debugopts
</dt>
<dd>
<p>Print diagnostic information; this can be helpful to
diagnose problems with why <strong>find</strong> is not doing what you want. The list
of debug options should be comma separated. Compatibility of the debug
options is not guaranteed between releases of findutils. For a
complete list of valid debug options, see the output of <strong>find -D
help</strong>. Valid debug options include</p>
<dl>
<dt>
exec
</dt>
<dd>Show diagnostic information relating to -exec, -execdir, -ok
and -okdir</dd>
<dt>
opt
</dt>
<dd>Prints diagnostic information relating to the optimisation of
the expression tree; see the -O option.</dd>
<dt>
rates
</dt>
<dd>Prints a summary indicating how often each predicate
succeeded or failed.</dd>
<dt>
search
</dt>
<dd>Navigate the directory tree verbosely.</dd>
<dt>
stat
</dt>
<dd>Print messages as files are examined with the <strong>stat</strong> and
<strong>lstat</strong> system calls. The <strong>find</strong> program tries to minimise such
calls.</dd>
<dt>
tree
</dt>
<dd>Show the expression tree in its original and optimized form.</dd>
<dt>
all
</dt>
<dd>Enable all of the other debug options (but <strong>help</strong>).</dd>
<dt>
help
</dt>
<dd>Explain the debugging options.</dd>
</dl>
</dd>
<dt>
-Olevel
</dt>
<dd>
<p>Enables query optimisation. The <strong>find</strong> program reorders
tests to speed up execution while preserving the overall effect; that
is, predicates with side effects are not reordered relative to each
other. The optimisations performed at each optimisation level are as
follows.</p>
<ol>
<li value="0">Equivalent to optimisation level 1.</li>
<li>This is the default optimisation level and corresponds to the
traditional behaviour. Expressions are reordered so that tests
based only on the names of files (for example <strong>-name</strong> and <strong>-regex</strong>)
are performed first.</li>
<li>Any <strong>-type</strong> or <strong>-xtype</strong> tests are performed after any tests based
only on the names of files, but before any tests that require
information from the inode. On many modern versions of Unix, file
types are returned by <strong>readdir()</strong> and so these predicates are
faster to evaluate than predicates which need to stat the file
first. If you use the <strong>-fstype <em>FOO</em></strong> predicate and specify a
filesystem type <em>FOO</em> which is not known (that is, present in
`/etc/mtab&#39;) at the time <strong>find</strong> starts, that predicate is
equivalent to <strong>-false</strong>.</li>
<li>At this optimisation level, the full cost-based query optimizer is
enabled. The order of tests is modified so that cheap (i.e. fast)
tests are performed first and more expensive ones are performed
later, if necessary. Within each cost band, predicates are
evaluated earlier or later according to whether they are likely to
succeed or not. For <strong>-o</strong>, predicates which are likely to succeed
are evaluated earlier, and for <strong>-a</strong>, predicates which are likely to
fail are evaluated earlier.</li>
</ol>
<p>The cost-based optimizer has a fixed idea of how likely any given test
is to succeed. In some cases the probability takes account of the
specific nature of the test (for example, <strong>-type f</strong> is assumed to be
more likely to succeed than <strong>-type c</strong>). The cost-based optimizer is
currently being evaluated. If it does not actually improve the
performance of <strong>find</strong>, it will be removed again. Conversely,
optimisations that prove to be reliable, robust and effective may be
enabled at lower optimisation levels over time. However, the default
behaviour (i.e. optimisation level 1) will not be changed in the 4.3.x
release series. The findutils test suite runs all the tests on <strong>find</strong>
at each optimisation level and ensures that the result is the same.</p>
<p>
The re-ordering of operations performed by the cost-based optimizer
can result in user-visible behaviour change. For example, the
<strong>-readable</strong> and <strong>-empty</strong> predicates are sensitive to re-ordering. If
they are run in the order <strong>-empty -readable</strong>, an error message will be
issued for unreadable directories. If they are run in the order
<strong>-readable -empty</strong> no error message will be issued. This is the reason
why such operation re-ordering is not performed at the default
optimisation level.</p>
</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-5" class="outline-2">
<h2 id="headline-5">
EXPRESSION
</h2>
<div id="outline-text-headline-5" class="outline-text-2">
<p>The part of the command line after the list of starting points is the
<em>expression</em>. This is a kind of query specification describing how we
match files and what we do with the files that were matched. An
expression is composed of a sequence of things:</p>
<dl>
<dt>
Tests
</dt>
<dd>Tests return a true or false value, usually on the basis of
some property of a file we are considering. The <strong>-empty</strong> test for
example is true only when the current file is empty.</dd>
<dt>
Actions
</dt>
<dd>Actions have side effects (such as printing something on
the standard output) and return either true or false, usually based on
whether or not they are successful. The <strong>-print</strong> action for example
prints the name of the current file on the standard output.</dd>
<dt>
Global options
</dt>
<dd>Global options affect the operation of tests and
actions specified on any part of the command line. Global options
always return true. The <strong>-depth</strong> option for example makes <strong>find</strong>
traverse the file system in a depth-first order.</dd>
<dt>
Positional options
</dt>
<dd>Positional options affect only tests or actions
which follow them. Positional options always return true. The
<strong>-regextype</strong> option for example is positional, specifying the regular
expression dialect for regular expressions occurring later on the
command line.</dd>
<dt>
Operators
</dt>
<dd>Operators join together the other items within the
expression. They include for example <strong>-o</strong> (meaning logical OR) and
<strong>-a</strong> (meaning logical AND). Where an operator is missing, <strong>-a</strong> is
assumed.</dd>
</dl>
<p>The <strong>-print</strong> action is performed on all files for which the whole
expression is true, unless it contains an action other than <strong>-prune</strong> or
<strong>-quit</strong>. Actions which inhibit the default <strong>-print</strong> are <strong>-delete</strong>,
<strong>-exec</strong>, <strong>-execdir</strong>, <strong>-ok</strong>, <strong>-okdir</strong>, <strong>-fls</strong>, <strong>-fprint</strong>, <strong>-fprintf</strong>,
<strong>-ls</strong>, <strong>-print</strong> and <strong>-printf</strong>.</p>
<p>
The <strong>-delete</strong> action also acts like an option (since it implies
<strong>-depth</strong>).</p>
<div id="outline-container-headline-6" class="outline-3">
<h3 id="headline-6">
POSITIONAL OPTIONS
</h3>
<div id="outline-text-headline-6" class="outline-text-3">
<p>Positional options always return true. They affect only tests occurring
later on the command line.</p>
<dl>
<dt>
-daystart
</dt>
<dd>Measure times (for <strong>-amin</strong>, <strong>-atime</strong>, <strong>-cmin</strong>, <strong>-ctime</strong>,
<strong>-mmin</strong>, and <strong>-mtime</strong>) from the beginning of today rather than from 24
hours ago. This option only affects tests which appear later on the
command line.</dd>
<dt>
-follow
</dt>
<dd>Deprecated; use the <strong>-L</strong> option instead. Dereference
symbolic links. Implies <strong>-noleaf</strong>. The <strong>-follow</strong> option affects only
those tests which appear after it on the command line. Unless the <strong>-H</strong>
or <strong>-L</strong> option has been specified, the position of the <strong>-follow</strong>
option changes the behaviour of the <strong>-newer</strong> predicate; any files
listed as the argument of <strong>-newer</strong> will be dereferenced if they are
symbolic links. The same consideration applies to <strong>-newerXY</strong>,
<strong>-anewer</strong> and <strong>-cnewer</strong>. Similarly, the <strong>-type</strong> predicate will always
match against the type of the file that a symbolic link points to
rather than the link itself. Using <strong>-follow</strong> causes the <strong>-lname and</strong>
<strong>-ilname</strong> predicates always to return false.</dd>
<dt>
-regextype type
</dt>
<dd>Changes the regular expression syntax understood by
<strong>-regex</strong> and <strong>-iregex</strong> tests which occur later on the command line. To
see which regular expression types are known, use <strong>-regextype help</strong>.
The Texinfo documentation (see <strong>SEE</strong> <strong>ALSO</strong>) explains the meaning of
and differences between the various types of regular expression. If
you do not use this option, find behaves as if the regular expression
type <strong>emacs</strong> had been specified.</dd>
<dt>
-warn, -nowarn
</dt>
<dd>Turn warning messages on or off. These warnings
apply only to the command line usage, not to any conditions that
<strong>find</strong> might encounter when it searches directories. The default
behaviour corresponds to <strong>-warn</strong> if standard input is a tty, and to
<strong>-nowarn</strong> otherwise. If a warning message relating to command-line
usage is produced, the exit status of <strong>find</strong> is not affected. If the
<strong>POSIXLY_CORRECT</strong> environment variable is set, and <strong>-warn</strong> is also
used, it is not specified which, if any, warnings will be active.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-7" class="outline-3">
<h3 id="headline-7">
GLOBAL OPTIONS
</h3>
<div id="outline-text-headline-7" class="outline-text-3">
<p>Global options always return true. Global options take effect even for
tests which occur earlier on the command line. To prevent confusion,
global options should be specified on the command-line after the list of
start points, just before the first test, positional option or action.
If you specify a global option in some other place, <strong>find</strong> will issue a
warning message explaining that this can be confusing.</p>
<p>
The global options occur after the list of start points, and so are not
the same kind of option as <strong>-L</strong>, for example.</p>
<dl>
<dt>
-d
</dt>
<dd>A synonym for -depth, for compatibility with FreeBSD, NetBSD,
MacOS X and OpenBSD.</dd>
<dt>
-depth
</dt>
<dd>Process each directory&#39;s contents before the directory
itself. The -delete action also implies <strong>-depth</strong>.</dd>
<dt>
-files0-from file
</dt>
<dd>Read the starting points from <em>file</em> instead of
getting them on the command line. In contrast to the known limitations
of passing starting points via arguments on the command line, namely
the limitation of the amount of file names, and the inherent ambiguity
of file names clashing with option names, using this option allows to
safely pass an arbitrary number of starting points to <strong>find</strong>.</dd>
</dl>
<p>Using this option and passing starting points on the command line is
mutually exclusive, and is therefore not allowed at the same time.</p>
<p>
The <em>file</em> argument is mandatory. One can use <strong>-files0-from -</strong> to read
the list of starting points from the <em>standard input</em> stream, and e.g.
from a pipe. In this case, the actions <strong>-ok</strong> and <strong>-okdir</strong> are not
allowed, because they would obviously interfere with reading from
<em>standard input</em> in order to get a user confirmation.</p>
<p>
The starting points in <em>file</em> have to be separated by ASCII NUL
characters. Two consecutive NUL characters, i.e., a starting point with
a Zero-length file name is not allowed and will lead to an error
diagnostic followed by a non-Zero exit code later.</p>
<p>
In the case the given <em>file</em> is empty, <strong>find</strong> does not process any
starting point and therefore will exit immediately after parsing the
program arguments. This is unlike the standard invocation where <strong>find</strong>
assumes the current directory as starting point if no path argument is
passed.</p>
<p>
The processing of the starting points is otherwise as usual, e.g. <strong>find</strong>
will recurse into subdirectories unless otherwise prevented. To process
only the starting points, one can additionally pass <strong>-maxdepth 0</strong>.</p>
<p>
Further notes: if a file is listed more than once in the input file, it
is unspecified whether it is visited more than once. If the <em>file</em> is
mutated during the operation of <strong>find</strong>, the result is unspecified as
well. Finally, the seek position within the named <em>file</em> at the time
<strong>find</strong> exits, be it with <strong>-quit</strong> or in any other way, is also
unspecified. By &#34;unspecified&#34; here is meant that it may or may not work
or do any specific thing, and that the behavior may change from platform
to platform, or from <strong>findutils</strong> release to release.</p>
<dl>
<dt>
-help, –help
</dt>
<dd>Print a summary of the command-line usage of <strong>find</strong>
and exit.</dd>
<dt>
-ignore_readdir_race
</dt>
<dd>Normally, <strong>find</strong> will emit an error message
when it fails to stat a file. If you give this option and a file is
deleted between the time <strong>find</strong> reads the name of the file from the
directory and the time it tries to stat the file, no error message
will be issued. This also applies to files or directories whose names
are given on the command line. This option takes effect at the time
the command line is read, which means that you cannot search one part
of the filesystem with this option on and part of it with this option
off (if you need to do that, you will need to issue two <strong>find</strong>
commands instead, one with the option and one without it).</dd>
</dl>
<p>Furthermore, <strong>find</strong> with the <strong>-ignore_readdir_race</strong> option will ignore
errors of the <strong>-delete</strong> action in the case the file has disappeared
since the parent directory was read: it will not output an error
diagnostic, and the return code of the <strong>-delete</strong> action will be true.</p>
<dl>
<dt>
-maxdepth levels
</dt>
<dd>Descend at most <em>levels</em> (a non-negative integer)
levels of directories below the starting-points. Using <strong>-maxdepth 0</strong>
means only apply the tests and actions to the starting-points
themselves.</dd>
<dt>
-mindepth levels
</dt>
<dd>Do not apply any tests or actions at levels less
than <em>levels</em> (a non-negative integer). Using <strong>-mindepth 1</strong> means
process all files except the starting-points.</dd>
<dt>
-mount
</dt>
<dd>Don&#39;t descend directories on other filesystems. An alternate
name for <strong>-xdev</strong>, for compatibility with some other versions of
<strong>find</strong>.</dd>
<dt>
-noignore_readdir_race
</dt>
<dd>Turns off the effect of
<strong>-ignore_readdir_race</strong>.</dd>
<dt>
-noleaf
</dt>
<dd>Do not optimize by assuming that directories contain 2
fewer subdirectories than their hard link count. This option is needed
when searching filesystems that do not follow the Unix directory-link
convention, such as CD-ROM or MS-DOS filesystems or AFS volume mount
points. Each directory on a normal Unix filesystem has at least 2 hard
links: its name and its `.&#39; entry. Additionally, its subdirectories
(if any) each have a `..&#39; entry linked to that directory. When <strong>find</strong>
is examining a directory, after it has statted 2 fewer subdirectories
than the directory&#39;s link count, it knows that the rest of the entries
in the directory are non-directories (`leaf&#39; files in the directory
tree). If only the files&#39; names need to be examined, there is no need
to stat them; this gives a significant increase in search speed.</dd>
<dt>
-version, –version
</dt>
<dd>Print the <strong>find</strong> version number and exit.</dd>
<dt>
-xdev
</dt>
<dd>Don&#39;t descend directories on other filesystems.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-8" class="outline-3">
<h3 id="headline-8">
TESTS
</h3>
<div id="outline-text-headline-8" class="outline-text-3">
<p>Some tests, for example <strong>-newerXY</strong> and <strong>-samefile</strong>, allow comparison
between the file currently being examined and some reference file
specified on the command line. When these tests are used, the
interpretation of the reference file is determined by the options <strong>-H</strong>,
<strong>-L</strong> and <strong>-P</strong> and any previous <strong>-follow</strong>, but the reference file is only
examined once, at the time the command line is parsed. If the reference
file cannot be examined (for example, the <strong>stat*(2) system call fails
for it), an error message is issued, and *find</strong> exits with a nonzero
status.</p>
<p>
A numeric argument <em>n</em> can be specified to tests (like <strong>-amin</strong>,
<strong>-mtime</strong>, <strong>-gid</strong>, <strong>-inum</strong>, <strong>-links</strong>, <strong>-size</strong>, <strong>-uid</strong> and <strong>-used</strong>) as</p>
<dl>
<dt>
+n
</dt>
<dd>for greater than <em>n</em>,</dd>
<dt>
-n
</dt>
<dd>for less than <em>n</em>,</dd>
</dl>
<ol>
<li value="14">for exactly <em>n</em>.</li>
</ol>
<p>Supported tests:</p>
<dl>
<dt>
-amin n
</dt>
<dd>File was last accessed less than, more than or exactly <em>n</em>
minutes ago.</dd>
<dt>
-anewer reference
</dt>
<dd>Time of the last access of the current file is
more recent than that of the last data modification of the <em>reference</em>
file. If <em>reference</em> is a symbolic link and the <strong>-H</strong> option or the
<strong>-L</strong> option is in effect, then the time of the last data modification
of the file it points to is always used.</dd>
<dt>
-atime n
</dt>
<dd>File was last accessed less than, more than or exactly
/n/*24 hours ago. When <strong>find</strong> figures out how many 24-hour periods ago
the file was last accessed, any fractional part is ignored, so to
match <strong>-atime +1</strong>, a file has to have been accessed at least <em>two</em>
days ago.</dd>
<dt>
-cmin n
</dt>
<dd>File&#39;s status was last changed less than, more than or
exactly <em>n</em> minutes ago.</dd>
<dt>
-cnewer reference
</dt>
<dd>Time of the last status change of the current
file is more recent than that of the last data modification of the
<em>reference</em> file. If <em>reference</em> is a symbolic link and the <strong>-H</strong>
option or the <strong>-L</strong> option is in effect, then the time of the last data
modification of the file it points to is always used.</dd>
<dt>
-ctime n
</dt>
<dd>File&#39;s status was last changed less than, more than or
exactly /n/*24 hours ago. See the comments for <strong>-atime</strong> to understand
how rounding affects the interpretation of file status change times.</dd>
<dt>
-empty
</dt>
<dd>File is empty and is either a regular file or a directory.</dd>
<dt>
-executable
</dt>
<dd>Matches files which are executable and directories
which are searchable (in a file name resolution sense) by the current
user. This takes into account access control lists and other
permissions artefacts which the <strong>-perm</strong> test ignores. This test makes
use of the *access*(2) system call, and so can be fooled by NFS
servers which do UID mapping (or root-squashing), since many systems
implement *access*(2) in the client&#39;s kernel and so cannot make use of
the UID mapping information held on the server. Because this test is
based only on the result of the *access*(2) system call, there is no
guarantee that a file for which this test succeeds can actually be
executed.</dd>
<dt>
-false
</dt>
<dd>Always false.</dd>
<dt>
-fstype type
</dt>
<dd>File is on a filesystem of type <em>type</em>. The valid
filesystem types vary among different versions of Unix; an incomplete
list of filesystem types that are accepted on some version of Unix or
another is: ufs, 4.2, 4.3, nfs, tmp, mfs, S51K, S52K. You can use
<strong>-printf</strong> with the %F directive to see the types of your filesystems.</dd>
<dt>
-gid n
</dt>
<dd>File&#39;s numeric group ID is less than, more than or exactly
<em>n</em>.</dd>
<dt>
-group gname
</dt>
<dd>File belongs to group <em>gname</em> (numeric group ID
allowed).</dd>
<dt>
-ilname pattern
</dt>
<dd>Like <strong>-lname</strong>, but the match is case insensitive.
If the <strong>-L</strong> option or the <strong>-follow</strong> option is in effect, this test
returns false unless the symbolic link is broken.</dd>
<dt>
-iname pattern
</dt>
<dd>Like <strong>-name</strong>, but the match is case insensitive. For
example, the patterns `fo*&#39; and `F??&#39; match the file names `Foo&#39;,
`FOO&#39;, `foo&#39;, `fOo&#39;, etc. The pattern `*foo*` will also match a file
called &#39;.foobar&#39;.</dd>
<dt>
-inum n
</dt>
<dd>File has inode number smaller than, greater than or exactly
<em>n</em>. It is normally easier to use the <strong>-samefile</strong> test instead.</dd>
<dt>
-ipath pattern
</dt>
<dd>Like <strong>-path</strong>. but the match is case insensitive.</dd>
<dt>
-iregex pattern
</dt>
<dd>Like <strong>-regex</strong>, but the match is case insensitive.</dd>
<dt>
-iwholename pattern
</dt>
<dd>See -ipath. This alternative is less portable
than <strong>-ipath</strong>.</dd>
<dt>
-links n
</dt>
<dd>File has less than, more than or exactly <em>n</em> hard links.</dd>
<dt>
-lname pattern
</dt>
<dd>File is a symbolic link whose contents match shell
pattern <em>pattern</em>. The metacharacters do not treat `/&#39; or `.&#39;
specially. If the <strong>-L</strong> option or the <strong>-follow</strong> option is in effect,
this test returns false unless the symbolic link is broken.</dd>
<dt>
-mmin n
</dt>
<dd>File&#39;s data was last modified less than, more than or
exactly <em>n</em> minutes ago.</dd>
<dt>
-mtime n
</dt>
<dd>File&#39;s data was last modified less than, more than or
exactly /n/*24 hours ago. See the comments for <strong>-atime</strong> to understand
how rounding affects the interpretation of file modification times.</dd>
<dt>
-name pattern
</dt>
<dd>Base of file name (the path with the leading
directories removed) matches shell pattern <em>pattern</em>. Because the
leading directories of the file names are removed, the <em>pattern</em>
should not include a slash, because `-name a/b&#39; will never match
anything (and you probably want to use <strong>-path</strong> instead). An exception
to this is when using only a slash as <em>pattern</em> (`-name <em>&#39;), because
that is a valid string for matching the root directory &#34;</em>&#34; (because
the base name of &#34;<em>&#34; is &#34;</em>&#34;). A warning is issued if you try to pass a
pattern containing a - but not consisting solely of one - slash,
unless the environment variable <strong>POSIXLY_CORRECT</strong> is set or the option
<strong>-nowarn</strong> is used.</dd>
</dl>
<p>To ignore a directory and the files under it, use <strong>-prune</strong> rather than
checking every file in the tree; see an example in the description of
that action. Braces are not recognised as being special, despite the
fact that some shells including Bash imbue braces with a special meaning
in shell patterns. The filename matching is performed with the use of
the *fnmatch*(3) library function. Don&#39;t forget to enclose the pattern
in quotes in order to protect it from expansion by the shell.</p>
<dl>
<dt>
-newer reference
</dt>
<dd>Time of the last data modification of the current
file is more recent than that of the last data modification of the
<em>reference</em> file. If <em>reference</em> is a symbolic link and the <strong>-H</strong>
option or the <strong>-L</strong> option is in effect, then the time of the last data
modification of the file it points to is always used.</dd>
<dt>
-newerXY reference
</dt>
<dd>Succeeds if timestamp <em>X</em> of the file being
considered is newer than timestamp <em>Y</em> of the file <em>reference</em>. The
letters <em>X</em> and <em>Y</em> can be any of the following letters:</dd>
</dl>
<table>
<tbody>
<tr>
<td>a</td>
<td>The access time of the file <em>reference</em></td>
</tr>
<tr>
<td>B</td>
<td>The birth time of the file <em>reference</em></td>
</tr>
<tr>
<td>c</td>
<td>The inode status change time of <em>reference</em></td>
</tr>
<tr>
<td>m</td>
<td>The modification time of the file <em>reference</em></td>
</tr>
<tr>
<td>t</td>
<td><em>reference</em> is interpreted directly as a time</td>
</tr>
</tbody>
</table>
<p>
Some combinations are invalid; for example, it is invalid for <em>X</em> to be
<em>t</em>. Some combinations are not implemented on all systems; for example
<em>B</em> is not supported on all systems. If an invalid or unsupported
combination of <em>XY</em> is specified, a fatal error results. Time
specifications are interpreted as for the argument to the <strong>-d</strong> option of
GNU <strong>date</strong>. If you try to use the birth time of a reference file, and
the birth time cannot be determined, a fatal error message results. If
you specify a test which refers to the birth time of files being
examined, this test will fail for any files where the birth time is
unknown.</p>
<dl>
<dt>
-nogroup
</dt>
<dd>No group corresponds to file&#39;s numeric group ID.</dd>
<dt>
-nouser
</dt>
<dd>No user corresponds to file&#39;s numeric user ID.</dd>
<dt>
-path pattern
</dt>
<dd>File name matches shell pattern <em>pattern</em>. The
metacharacters do not treat `/&#39; or `.&#39; specially; so, for example,</dd>
</dl>
<pre class="example">
find . -path &#34;./sr*sc&#34;
</pre>
<p>
will print an entry for a directory called <em>./src/misc</em> (if one exists).
To ignore a whole directory tree, use <strong>-prune</strong> rather than checking
every file in the tree. Note that the pattern match test applies to the
whole file name, starting from one of the start points named on the
command line. It would only make sense to use an absolute path name here
if the relevant start point is also an absolute path. This means that
this command will never match anything:\\</p>
<pre class="example">
find bar -path /foo/bar/myfile -print
</pre>
<p>
Find compares the <strong>-path</strong> argument with the concatenation of a directory
name and the base name of the file it&#39;s examining. Since the
concatenation will never end with a slash, <strong>-path</strong> arguments ending in a
slash will match nothing (except perhaps a start point specified on the
command line). The predicate <strong>-path</strong> is also supported by HP-UX <strong>find</strong>
and is part of the POSIX 2008 standard.</p>
<dl>
<dt>
-perm mode
</dt>
<dd>File&#39;s permission bits are exactly <em>mode</em> (octal or
symbolic). Since an exact match is required, if you want to use this
form for symbolic modes, you may have to specify a rather complex mode
string. For example `-perm g=w&#39; will only match files which have mode
0020 (that is, ones for which group write permission is the only
permission set). It is more likely that you will want to use the `/&#39;
or `-&#39; forms, for example `-perm -g=w&#39;, which matches any file with
group write permission. See the <strong>EXAMPLES</strong> section for some
illustrative examples.</dd>
<dt>
-perm -mode
</dt>
<dd>All of the permission bits <em>mode</em> are set for the file.
Symbolic modes are accepted in this form, and this is usually the way
in which you would want to use them. You must specify `u&#39;, `g&#39; or `o&#39;
if you use a symbolic mode. See the <strong>EXAMPLES</strong> section for some
illustrative examples.</dd>
<dt>
-perm /mode
</dt>
<dd>Any of the permission bits <em>mode</em> are set for the file.
Symbolic modes are accepted in this form. You must specify `u&#39;, `g&#39; or
`o&#39; if you use a symbolic mode. See the <strong>EXAMPLES</strong> section for some
illustrative examples. If no permission bits in <em>mode</em> are set, this
test matches any file (the idea here is to be consistent with the
behaviour of <strong>-perm -000</strong>).</dd>
<dt>
-perm +mode
</dt>
<dd>This is no longer supported (and has been deprecated
since 2005). Use <strong>-perm <em>/mode</em></strong> instead.</dd>
<dt>
-readable
</dt>
<dd>Matches files which are readable by the current user.
This takes into account access control lists and other permissions
artefacts which the <strong>-perm</strong> test ignores. This test makes use of the
*access*(2) system call, and so can be fooled by NFS servers which do
UID mapping (or root-squashing), since many systems implement
*access*(2) in the client&#39;s kernel and so cannot make use of the UID
mapping information held on the server.</dd>
<dt>
-regex pattern
</dt>
<dd>File name matches regular expression <em>pattern</em>. This
is a match on the whole path, not a search. For example, to match a
file named <em>./fubar3,</em> you can use the regular expression `.*bar.&#39; or
`.*b.*3&#39;, but not `f.*r3&#39;. The regular expressions understood by
<strong>find</strong> are by default Emacs Regular Expressions, but this can be
changed with the <strong>-regextype</strong> option.</dd>
<dt>
-samefile name
</dt>
<dd>File refers to the same inode as <em>name</em>. When <strong>-L</strong>
is in effect, this can include symbolic links.</dd>
<dt>
-size n[cwbkMG]
</dt>
<dd>
<p>File uses less than, more than or exactly <em>n</em> units
of space, rounding up. The following suffixes can be used:</p>
<dl>
<dt>
`b&#39;
</dt>
<dd>for 512-byte blocks (this is the default if no suffix is
used)</dd>
<dt>
`c&#39;
</dt>
<dd>for bytes</dd>
<dt>
`w&#39;
</dt>
<dd>for two-byte words</dd>
<dt>
`k&#39;
</dt>
<dd>for kibibytes (KiB, units of 1024 bytes)</dd>
<dt>
`M&#39;
</dt>
<dd>for mebibytes (MiB, units of 1024 * 1024 = 1 048 576 bytes)</dd>
<dt>
`G&#39;
</dt>
<dd>for gibibytes (GiB, units of 1024 * 1024 * 1024 =
1 073 741 824 bytes)</dd>
</dl>
<p>The size is simply the st_size member of the struct stat populated by
the lstat (or stat) system call, rounded up as shown above. In other
words, it&#39;s consistent with the result you get for <strong>ls -l</strong>. Bear in
mind that the `%k&#39; and `%b&#39; format specifiers of <strong>-printf</strong> handle
sparse files differently. The `b&#39; suffix always denotes 512-byte
blocks and never 1024-byte blocks, which is different to the behaviour
of <strong>-ls</strong>.</p>
<p>
The + and - prefixes signify greater than and less than, as usual;
i.e., an exact size of <em>n</em> units does not match. Bear in mind that the
size is rounded up to the next unit. Therefore <strong>-size -1M</strong> is not
equivalent to <strong>-size -1 048 576c</strong>. The former only matches empty
files, the latter matches files from 0 to 1,048,575 bytes.</p>
</dd>
<dt>
-true
</dt>
<dd>Always true.</dd>
<dt>
-type c
</dt>
<dd>
<p>File is of type <em>c</em>:</p>
<ol>
<li value="2">block (buffered) special</li>
<li>character (unbuffered) special</li>
<li>directory</li>
<li>named pipe (FIFO)</li>
<li>regular file</li>
<li>symbolic link; this is never true if the <strong>-L</strong> option or the
<strong>-follow</strong> option is in effect, unless the symbolic link is broken.
If you want to search for symbolic links when <strong>-L</strong> is in effect,
use <strong>-xtype</strong>.</li>
<li>socket</li>
<li value="4">door (Solaris)</li>
</ol>
<p>To search for more than one type at once, you can supply the combined
list of type letters separated by a comma `,&#39; (GNU extension).</p>
</dd>
<dt>
-uid n
</dt>
<dd>File&#39;s numeric user ID is less than, more than or exactly
<em>n</em>.</dd>
<dt>
-used n
</dt>
<dd>File was last accessed less than, more than or exactly <em>n</em>
days after its status was last changed.</dd>
<dt>
-user uname
</dt>
<dd>File is owned by user <em>uname</em> (numeric user ID
allowed).</dd>
<dt>
-wholename pattern
</dt>
<dd>See -path. This alternative is less portable
than <strong>-path</strong>.</dd>
<dt>
-writable
</dt>
<dd>Matches files which are writable by the current user.
This takes into account access control lists and other permissions
artefacts which the <strong>-perm</strong> test ignores. This test makes use of the
*access*(2) system call, and so can be fooled by NFS servers which do
UID mapping (or root-squashing), since many systems implement
*access*(2) in the client&#39;s kernel and so cannot make use of the UID
mapping information held on the server.</dd>
<dt>
-xtype c
</dt>
<dd>The same as <strong>-type</strong> unless the file is a symbolic link.
For symbolic links: if the <strong>-H</strong> or <strong>-P</strong> option was specified, true if
the file is a link to a file of type <em>c</em>; if the <strong>-L</strong> option has been
given, true if <em>c</em> is `l&#39;. In other words, for symbolic links,
<strong>-xtype</strong> checks the type of the file that <strong>-type</strong> does not check. If a
symbolic link is broken (because the thing it points to does not exist
or the link points to itself) then <strong>-xtype</strong> will behave the same as
<strong>-type</strong>.</dd>
<dt>
-context pattern
</dt>
<dd>(SELinux only) Security context of the file
matches glob <em>pattern</em>.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-9" class="outline-3">
<h3 id="headline-9">
ACTIONS
</h3>
<div id="outline-text-headline-9" class="outline-text-3">
<dl>
<dt>
-delete
</dt>
<dd>Delete files or directories; true if removal succeeded. If
the removal failed, an error message is issued and <strong>find</strong>&#39;s exit
status will be nonzero (when it eventually exits).</dd>
</dl>
<p><strong>Warning</strong>: Don&#39;t forget that <strong>find</strong> evaluates the command line as an
expression, so putting <strong>-delete</strong> first will make <strong>find</strong> try to delete
everything below the starting points you specified.</p>
<p>
The use of the <strong>-delete</strong> action on the command line automatically turns
on the <strong>-depth</strong> option. As in turn <strong>-depth</strong> makes <strong>-prune</strong> ineffective,
the <strong>-delete</strong> action cannot usefully be combined with <strong>-prune</strong>.</p>
<p>
Often, the user might want to test a <strong>find</strong> command line with <strong>-print</strong>
prior to adding <strong>-delete</strong> for the actual removal run. To avoid
surprising results, it is usually best to remember to use <strong>-depth</strong>
explicitly during those earlier test runs.</p>
<p>
The <strong>-delete</strong> action will fail to remove a directory unless it is empty.</p>
<p>
Together with the <strong>-ignore_readdir_race</strong> option, <strong>find</strong> will ignore
errors of the <strong>-delete</strong> action in the case the file has disappeared
since the parent directory was read: it will not output an error
diagnostic, not change the exit code to nonzero, and the return code of
the <strong>-delete</strong> action will be true.</p>
<dl>
<dt>
-exec command ;
</dt>
<dd>Execute <em>command</em>; true if 0 status is returned.
All following arguments to <strong>find</strong> are taken to be arguments to the
command until an argument consisting of `;&#39; is encountered. The string
`{}&#39; is replaced by the current file name being processed everywhere
it occurs in the arguments to the command, not just in arguments where
it is alone, as in some versions of <strong>find</strong>. Both of these
constructions might need to be escaped (with a `\&#39;) or quoted to
protect them from expansion by the shell. See the <strong>EXAMPLES</strong> section
for examples of the use of the <strong>-exec</strong> option. The specified command
is run once for each matched file. The command is executed in the
starting directory. There are unavoidable security problems
surrounding use of the <strong>-exec</strong> action; you should use the <strong>-execdir</strong>
option instead.</dd>
<dt>
-exec command {} +
</dt>
<dd>This variant of the <strong>-exec</strong> action runs the
specified command on the selected files, but the command line is built
by appending each selected file name at the end; the total number of
invocations of the command will be much less than the number of
matched files. The command line is built in much the same way that
<strong>xargs</strong> builds its command lines. Only one instance of `{}&#39; is allowed
within the command, and it must appear at the end, immediately before
the `+&#39;; it needs to be escaped (with a `\&#39;) or quoted to protect it
from interpretation by the shell. The command is executed in the
starting directory. If any invocation with the `+&#39; form returns a
non-zero value as exit status, then <strong>find</strong> returns a non-zero exit
status. If <strong>find</strong> encounters an error, this can sometimes cause an
immediate exit, so some pending commands may not be run at all. For
this reason <strong>-exec <em>my-command</em> … {} + -quit</strong> may not result in
<em>my-command</em> actually being run. This variant of <strong>-exec</strong> always
returns true.</dd>
<dt>
-execdir command ;
</dt>
<dd></dd>
<dt>
-execdir command {} +
</dt>
<dd>Like <strong>-exec</strong>, but the specified command is
run from the subdirectory containing the matched file, which is not
normally the directory in which you started <strong>find</strong>. As with -exec, the
{} should be quoted if find is being invoked from a shell. This a much
more secure method for invoking commands, as it avoids race conditions
during resolution of the paths to the matched files. As with the
<strong>-exec</strong> action, the `+&#39; form of <strong>-execdir</strong> will build a command line
to process more than one matched file, but any given invocation of
<em>command</em> will only list files that exist in the same subdirectory. If
you use this option, you must ensure that your <strong>PATH</strong> environment
variable does not reference `.&#39;; otherwise, an attacker can run any
commands they like by leaving an appropriately-named file in a
directory in which you will run <strong>-execdir</strong>. The same applies to having
entries in <strong>PATH</strong> which are empty or which are not absolute directory
names. If any invocation with the `+&#39; form returns a non-zero value as
exit status, then <strong>find</strong> returns a non-zero exit status. If <strong>find</strong>
encounters an error, this can sometimes cause an immediate exit, so
some pending commands may not be run at all. The result of the action
depends on whether the <strong>+</strong> or the <strong>;</strong> variant is being used; <strong>-execdir
<em>command</em> {} +</strong> always returns true, while <strong>-execdir <em>command</em> {} ;</strong>
returns true only if <em>command</em> returns 0.</dd>
<dt>
-fls file
</dt>
<dd>True; like <strong>-ls</strong> but write to <em>file</em> like <strong>-fprint</strong>. The
output file is always created, even if the predicate is never matched.
See the <strong>UNUSUAL FILENAMES</strong> section for information about how unusual
characters in filenames are handled.</dd>
<dt>
-fprint file
</dt>
<dd>True; print the full file name into file <em>file</em>. If
<em>file</em> does not exist when <strong>find</strong> is run, it is created; if it does
exist, it is truncated. The file names <em>/dev/stdout</em> and <em>/dev/stderr</em>
are handled specially; they refer to the standard output and standard
error output, respectively. The output file is always created, even if
the predicate is never matched. See the <strong>UNUSUAL FILENAMES</strong> section
for information about how unusual characters in filenames are handled.</dd>
<dt>
-fprint0 file
</dt>
<dd>True; like <strong>-print0</strong> but write to <em>file</em> like
<strong>-fprint</strong>. The output file is always created, even if the predicate is
never matched. See the <strong>UNUSUAL FILENAMES</strong> section for information
about how unusual characters in filenames are handled.</dd>
<dt>
-fprintf file format
</dt>
<dd>True; like <strong>-printf</strong> but write to <em>file</em> like
<strong>-fprint</strong>. The output file is always created, even if the predicate is
never matched. See the <strong>UNUSUAL FILENAMES</strong> section for information
about how unusual characters in filenames are handled.</dd>
<dt>
-ls
</dt>
<dd>True; list current file in <strong>ls -dils</strong> format on standard
output. The block counts are of 1 KB blocks, unless the environment
variable <strong>POSIXLY_CORRECT</strong> is set, in which case 512-byte blocks are
used. See the <strong>UNUSUAL FILENAMES</strong> section for information about how
unusual characters in filenames are handled.</dd>
<dt>
-ok command ;
</dt>
<dd>Like <strong>-exec</strong> but ask the user first. If the user
agrees, run the command. Otherwise just return false. If the command
is run, its standard input is redirected from <em>/dev/null</em>. This action
may not be specified together with the <strong>-files0-from</strong> option.

The response to the prompt is matched against a pair of regular
expressions to determine if it is an affirmative or negative response.
This regular expression is obtained from the system if the
<strong>POSIXLY_CORRECT</strong> environment variable is set, or otherwise from
<strong>find</strong>&#39;s message translations. If the system has no suitable
definition, <strong>find</strong>&#39;s own definition will be used. In either case, the
interpretation of the regular expression itself will be affected by
the environment variables <strong>LC_CTYPE</strong> (character classes) and
<strong>LC_COLLATE</strong> (character ranges and equivalence classes).</dd>
<dt>
-okdir command ;
</dt>
<dd>Like <strong>-execdir</strong> but ask the user first in the same
way as for <strong>-ok</strong>. If the user does not agree, just return false. If
the command is run, its standard input is redirected from <em>/dev/null</em>.
This action may not be specified together with the <strong>-files0-from</strong>
option.</dd>
<dt>
-print
</dt>
<dd>True; print the full file name on the standard output,
followed by a newline. If you are piping the output of <strong>find</strong> into
another program and there is the faintest possibility that the files
which you are searching for might contain a newline, then you should
seriously consider using the <strong>-print0</strong> option instead of <strong>-print</strong>. See
the <strong>UNUSUAL FILENAMES</strong> section for information about how unusual
characters in filenames are handled.</dd>
<dt>
-print0
</dt>
<dd>True; print the full file name on the standard output,
followed by a null character (instead of the newline character that
<strong>-print</strong> uses). This allows file names that contain newlines or other
types of white space to be correctly interpreted by programs that
process the <strong>find</strong> output. This option corresponds to the <strong>-0</strong> option
of <strong>xargs</strong>.</dd>
<dt>
-printf format
</dt>
<dd>
<p>True; print <em>format</em> on the standard output,
interpreting `\&#39; escapes and `%&#39; directives. Field widths and
precisions can be specified as with the *printf*(3) C function. Please
note that many of the fields are printed as %s rather than %d, and
this may mean that flags don&#39;t work as you might expect. This also
means that the `-&#39; flag does work (it forces fields to be
left-aligned). Unlike <strong>-print</strong>, <strong>-printf</strong> does not add a newline at
the end of the string. The escapes and directives are:</p>
<dl>
<dt>
\a
</dt>
<dd>Alarm bell.</dd>
<dt>
\b
</dt>
<dd>Backspace.</dd>
<dt>
\c
</dt>
<dd>Stop printing from this format immediately and flush the
output.</dd>
<dt>
\f
</dt>
<dd>Form feed.</dd>
<dt>
\n
</dt>
<dd>Newline.</dd>
<dt>
\r
</dt>
<dd>Carriage return.</dd>
<dt>
\t
</dt>
<dd>Horizontal tab.</dd>
<dt>
\v
</dt>
<dd>Vertical tab.</dd>
<dt>
\0
</dt>
<dd>ASCII NUL.</dd>
<dt>
\\
</dt>
<dd>A literal backslash (`\&#39;).</dd>
<dt>
\NNN
</dt>
<dd>The character whose ASCII code is NNN (octal).</dd>
</dl>
<p>A `\&#39; character followed by any other character is treated as an
ordinary character, so they both are printed.</p>
<dl>
<dt>
%%
</dt>
<dd>A literal percent sign.</dd>
<dt>
%a
</dt>
<dd>File&#39;s last access time in the format returned by the C
*ctime*(3) function.</dd>
<dt>
%Ak
</dt>
<dd>
<p>File&#39;s last access time in the format specified by <em>k</em>, which
is either `@&#39; or a directive for the C *strftime*(3) function. The
following shows an incomplete list of possible values for <em>k</em>.
Please refer to the documentation of *strftime*(3) for the full
list. Some of the conversion specification characters might not be
available on all systems, due to differences in the implementation
of the *strftime*(3) library function.</p>
<ol>
<li>seconds since Jan. 1, 1970, 00:00 GMT, with fractional part.</li>
</ol>
<p>Time fields:</p>
<ol>
<li value="8">hour (00..23)</li>
<li>hour (01..12)</li>
<li value="11">hour ( 0..23)</li>
<li>hour ( 1..12)</li>
<li value="13">minute (00..59)</li>
<li value="16">locale&#39;s AM or PM</li>
<li>time, 12-hour (hh:mm:ss [AP]M)</li>
<li value="19">Second (00.00 .. 61.00). There is a fractional part.</li>
<li>time, 24-hour (hh:mm:ss.xxxxxxxxxx)</li>
</ol>
<ul>
<li>Date and time, separated by `+&#39;, for example
`2004-04-28+22:22:05.0&#39;. This is a GNU extension. The time is
given in the current timezone (which may be affected by setting
the <strong>TZ</strong> environment variable). The seconds field includes a
fractional part.</li>
</ul>
<ol>
<li value="24">locale&#39;s time representation (H:M:S). The seconds field
includes a fractional part.</li>
<li>time zone (e.g., EDT), or nothing if no time zone is
determinable</li>
</ol>
<p>Date fields:</p>
<ol>
<li>locale&#39;s abbreviated weekday name (Sun..Sat)</li>
<li>locale&#39;s full weekday name, variable length (Sunday..Saturday)</li>
<li value="2">locale&#39;s abbreviated month name (Jan..Dec)</li>
<li value="2">locale&#39;s full month name, variable length
(January..December)</li>
<li value="3">locale&#39;s date and time (Sat Nov 04 12:02:33 EST 1989). The
format is the same as for *ctime*(3) and so to preserve
compatibility with that format, there is no fractional part in
the seconds field.</li>
<li>day of month (01..31)</li>
<li value="4">date (mm/dd/yy)</li>
<li>date (yyyy-mm-dd)</li>
<li value="8">same as b</li>
<li>day of year (001..366)</li>
<li>month (01..12)</li>
<li value="21">week number of year with Sunday as first day of week
(00..53)</li>
<li value="23">day of week (0..6)</li>
<li value="23">week number of year with Monday as first day of week
(00..53)</li>
<li value="24">locale&#39;s date representation (mm/dd/yy)</li>
<li>last two digits of year (00..99)</li>
<li value="25">year (1970…)</li>
</ol>
</dd>
<dt>
%b
</dt>
<dd>The amount of disk space used for this file in 512-byte
blocks. Since disk space is allocated in multiples of the filesystem
block size this is usually greater than %s/512, but it can also be
smaller if the file is a sparse file.</dd>
<dt>
%Bk
</dt>
<dd>File&#39;s birth time, i.e., its creation time, in the format
specified by <em>k</em>, which is the same as for %A. This directive
produces an empty string if the underlying operating system or
filesystem does not support birth times.</dd>
<dt>
%c
</dt>
<dd>File&#39;s last status change time in the format returned by the C
*ctime*(3) function.</dd>
<dt>
%Ck
</dt>
<dd>File&#39;s last status change time in the format specified by
<em>k</em>, which is the same as for %A.</dd>
<dt>
%d
</dt>
<dd>File&#39;s depth in the directory tree; 0 means the file is a
starting-point.</dd>
<dt>
%D
</dt>
<dd>The device number on which the file exists (the st_dev field
of struct stat), in decimal.</dd>
<dt>
%f
</dt>
<dd>Print the basename; the file&#39;s name with any leading
directories removed (only the last element). For <strong>/</strong>, the result is
`/&#39;. See the <strong>EXAMPLES</strong> section for an example.</dd>
<dt>
%F
</dt>
<dd>Type of the filesystem the file is on; this value can be used
for -fstype.</dd>
<dt>
%g
</dt>
<dd>File&#39;s group name, or numeric group ID if the group has no
name.</dd>
<dt>
%G
</dt>
<dd>File&#39;s numeric group ID.</dd>
<dt>
%h
</dt>
<dd>Dirname; the Leading directories of the file&#39;s name (all but
the last element). If the file name contains no slashes (since it is
in the current directory) the %h specifier expands to `.&#39;. For files
which are themselves directories and contain a slash (including
<strong>/</strong>), %h expands to the empty string. See the <strong>EXAMPLES</strong> section for
an example.</dd>
<dt>
%H
</dt>
<dd>Starting-point under which file was found.</dd>
<dt>
%i
</dt>
<dd>File&#39;s inode number (in decimal).</dd>
<dt>
%k
</dt>
<dd>The amount of disk space used for this file in 1 KB blocks.
Since disk space is allocated in multiples of the filesystem block
size this is usually greater than %s/1024, but it can also be
smaller if the file is a sparse file.</dd>
<dt>
%l
</dt>
<dd>Object of symbolic link (empty string if file is not a
symbolic link).</dd>
<dt>
%m
</dt>
<dd>File&#39;s permission bits (in octal). This option uses the
`traditional&#39; numbers which most Unix implementations use, but if
your particular implementation uses an unusual ordering of octal
permissions bits, you will see a difference between the actual value
of the file&#39;s mode and the output of %m. Normally you will want to
have a leading zero on this number, and to do this, you should use
the <strong>#</strong> flag (as in, for example, `%#m&#39;).</dd>
<dt>
%M
</dt>
<dd>File&#39;s permissions (in symbolic form, as for <strong>ls</strong>). This
directive is supported in findutils 4.2.5 and later.</dd>
<dt>
%n
</dt>
<dd>Number of hard links to file.</dd>
<dt>
%p
</dt>
<dd>File&#39;s name.</dd>
<dt>
%P
</dt>
<dd>File&#39;s name with the name of the starting-point under which it
was found removed.</dd>
<dt>
%s
</dt>
<dd>File&#39;s size in bytes.</dd>
<dt>
%S
</dt>
<dd>File&#39;s sparseness. This is calculated as (BLOCKSIZE*st_blocks
/ st_size). The exact value you will get for an ordinary file of a
certain length is system-dependent. However, normally sparse files
will have values less than 1.0, and files which use indirect blocks
may have a value which is greater than 1.0. In general the number of
blocks used by a file is file system dependent. The value used for
BLOCKSIZE is system-dependent, but is usually 512 bytes. If the file
size is zero, the value printed is undefined. On systems which lack
support for st_blocks, a file&#39;s sparseness is assumed to be 1.0.</dd>
<dt>
%t
</dt>
<dd>File&#39;s last modification time in the format returned by the C
*ctime*(3) function.</dd>
<dt>
%Tk
</dt>
<dd>File&#39;s last modification time in the format specified by <em>k</em>,
which is the same as for %A.</dd>
<dt>
%u
</dt>
<dd>File&#39;s user name, or numeric user ID if the user has no name.</dd>
<dt>
%U
</dt>
<dd>File&#39;s numeric user ID.</dd>
<dt>
%y
</dt>
<dd>File&#39;s type (like in <strong>ls -l</strong>), U=unknown type (shouldn&#39;t
happen)</dd>
<dt>
%Y
</dt>
<dd>File&#39;s type (like %y), plus follow symbolic links: `L&#39;=loop,
`N&#39;=nonexistent, `?&#39; for any other error when determining the type
of the target of a symbolic link.</dd>
<dt>
%Z
</dt>
<dd>(SELinux only) file&#39;s security context.</dd>
<dt>
%{ %[ %(
</dt>
<dd>Reserved for future use.</dd>
</dl>
<p>A `%&#39; character followed by any other character is discarded, but the
other character is printed (don&#39;t rely on this, as further format
characters may be introduced). A `%&#39; at the end of the format argument
causes undefined behaviour since there is no following character. In
some locales, it may hide your door keys, while in others it may
remove the final page from the novel you are reading.</p>
<p>
The %m and %d directives support the <strong>#</strong>, <strong>0</strong> and <strong>+</strong> flags, but the
other directives do not, even if they print numbers. Numeric
directives that do not support these flags include <strong>G</strong>, <strong>U</strong>, <strong>b</strong>, <strong>D</strong>,
<strong>k</strong> and <strong>n</strong>. The `-&#39; format flag is supported and changes the
alignment of a field from right-justified (which is the default) to
left-justified.</p>
<p>
See the <strong>UNUSUAL FILENAMES</strong> section for information about how unusual
characters in filenames are handled.</p>
</dd>
<dt>
-prune
</dt>
<dd>True; if the file is a directory, do not descend into it. If
<strong>-depth</strong> is given, then <strong>-prune</strong> has no effect. Because <strong>-delete</strong>
implies <strong>-depth</strong>, you cannot usefully use <strong>-prune</strong> and <strong>-delete</strong>
together. For example, to skip the directory <em>src/emacs</em> and all files
and directories under it, and print the names of the other files
found, do something like this:</dd>
</dl>
<pre class="example">
find . -path ./src/emacs -prune -o -print
</pre>
<dl>
<dt>
-quit
</dt>
<dd>Exit immediately (with return value zero if no errors have
occurred). This is different to <strong>-prune</strong> because <strong>-prune</strong> only applies
to the contents of pruned directories, while <strong>-quit</strong> simply makes
<strong>find</strong> stop immediately. No child processes will be left running. Any
command lines which have been built by <strong>-exec … +</strong> or <strong>-execdir …
+</strong> are invoked before the program is exited. After <strong>-quit</strong> is
executed, no more files specified on the command line will be
processed. For example, `*find <em>/tmp/foo</em> <em>/tmp/bar</em> -print -quit*`
will print only `/tmp/foo`.<br>
One common use of <strong>-quit</strong> is to stop searching the file system once we
have found what we want. For example, if we want to find just a single
file we can do this:</dd>
</dl>
<pre class="example">
find / -name needle -print -quit
</pre>
</div>
</div>
<div id="outline-container-headline-10" class="outline-3">
<h3 id="headline-10">
OPERATORS
</h3>
<div id="outline-text-headline-10" class="outline-text-3">
<p>Listed in order of decreasing precedence:</p>
<dl>
<dt>
( expr )
</dt>
<dd>Force precedence. Since parentheses are special to the
shell, you will normally need to quote them. Many of the examples in
this manual page use backslashes for this purpose: `\(...\)&#39; instead
of `(…)&#39;.</dd>
<dt>
! expr
</dt>
<dd>True if <em>expr</em> is false. This character will also usually
need protection from interpretation by the shell.</dd>
<dt>
-not expr
</dt>
<dd>Same as ! <em>expr</em>, but not POSIX compliant.</dd>
<dt>
expr1 expr2
</dt>
<dd>Two expressions in a row are taken to be joined with an
implied <strong>-a</strong>; <em>expr2</em> is not evaluated if <em>expr1</em> is false.</dd>
<dt>
expr1 -a expr2
</dt>
<dd>Same as <em>expr1 expr2</em>.</dd>
<dt>
expr1 -and expr2
</dt>
<dd>Same as <em>expr1 expr2</em>, but not POSIX compliant.</dd>
<dt>
expr1 -o expr2
</dt>
<dd>Or; <em>expr2</em> is not evaluated if <em>expr1</em> is true.</dd>
<dt>
expr1 -or expr2
</dt>
<dd>Same as <em>expr1</em> <strong>-o</strong> <em>expr2</em>, but not POSIX
compliant.</dd>
<dt>
expr1 , expr2
</dt>
<dd>List; both <em>expr1</em> and <em>expr2</em> are always evaluated.
The value of <em>expr1</em> is discarded; the value of the list is the value
of <em>expr2</em>. The comma operator can be useful for searching for several
different types of thing, but traversing the filesystem hierarchy only
once. The <strong>-fprintf</strong> action can be used to list the various matched
items into several different output files.</dd>
</dl>
<p>Please note that <strong>-a</strong> when specified implicitly (for example by two
tests appearing without an explicit operator between them) or explicitly
has higher precedence than <strong>-o</strong>. This means that <strong>find . -name afile -o
-name bfile -print</strong> will never print <em>afile</em>.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-11" class="outline-2">
<h2 id="headline-11">
UNUSUAL FILENAMES
</h2>
<div id="outline-text-headline-11" class="outline-text-2">
<p>Many of the actions of <strong>find</strong> result in the printing of data which is
under the control of other users. This includes file names, sizes,
modification times and so forth. File names are a potential problem
since they can contain any character except `\0&#39; and `/&#39;. Unusual
characters in file names can do unexpected and often undesirable things
to your terminal (for example, changing the settings of your function
keys on some terminals). Unusual characters are handled differently by
various actions, as described below.</p>
<dl>
<dt>
-print0, -fprint0
</dt>
<dd>Always print the exact filename, unchanged, even
if the output is going to a terminal.</dd>
<dt>
-ls, -fls
</dt>
<dd>Unusual characters are always escaped. White space,
backslash, and double quote characters are printed using C-style
escaping (for example `\f&#39;, `\&#34;&#39;). Other unusual characters are
printed using an octal escape. Other printable characters (for <strong>-ls</strong>
and <strong>-fls</strong> these are the characters between octal 041 and 0176) are
printed as-is.</dd>
<dt>
-printf, -fprintf
</dt>
<dd>If the output is not going to a terminal, it is
printed as-is. Otherwise, the result depends on which directive is in
use. The directives %D, %F, %g, %G, %H, %Y, and %y expand to values
which are not under control of files&#39; owners, and so are printed
as-is. The directives %a, %b, %c, %d, %i, %k, %m, %M, %n, %s, %t, %u
and %U have values which are under the control of files&#39; owners but
which cannot be used to send arbitrary data to the terminal, and so
these are printed as-is. The directives %f, %h, %l, %p and %P are
quoted. This quoting is performed in the same way as for GNU <strong>ls</strong>.
This is not the same quoting mechanism as the one used for <strong>-ls</strong> and
<strong>-fls</strong>. If you are able to decide what format to use for the output of
<strong>find</strong> then it is normally better to use `\0&#39; as a terminator than to
use newline, as file names can contain white space and newline
characters. The setting of the <strong>LC_CTYPE</strong> environment variable is used
to determine which characters need to be quoted.</dd>
<dt>
-print, -fprint
</dt>
<dd>Quoting is handled in the same way as for <strong>-printf</strong>
and <strong>-fprintf</strong>. If you are using <strong>find</strong> in a script or in a situation
where the matched files might have arbitrary names, you should
consider using <strong>-print0</strong> instead of <strong>-print</strong>.</dd>
</dl>
<p>The <strong>-ok</strong> and <strong>-okdir</strong> actions print the current filename as-is. This
may change in a future release.</p>
</div>
</div>
<div id="outline-container-headline-12" class="outline-2">
<h2 id="headline-12">
STANDARDS CONFORMANCE
</h2>
<div id="outline-text-headline-12" class="outline-text-2">
<p>For closest compliance to the POSIX standard, you should set the
<strong>POSIXLY_CORRECT</strong> environment variable. The following options are
specified in the POSIX standard (IEEE Std 1003.1-2008, 2016 Edition):</p>
<dl>
<dt>
-H
</dt>
<dd>This option is supported.</dd>
<dt>
-L
</dt>
<dd>This option is supported.</dd>
<dt>
-name
</dt>
<dd>This option is supported, but POSIX conformance depends on
the POSIX conformance of the system&#39;s <strong>fnmatch*(3) library function.
As of findutils-4.2.2, shell metacharacters (`</strong>&#39;, `?&#39; or `[]&#39; for
example) match a leading `.&#39;, because IEEE PASC interpretation 126
requires this. This is a change from previous versions of findutils.</dd>
<dt>
-type
</dt>
<dd>Supported. POSIX specifies `b&#39;, `c&#39;, `d&#39;, `l&#39;, `p&#39;, `f&#39; and
`s&#39;. GNU find also supports `D&#39;, representing a Door, where the OS
provides these. Furthermore, GNU find allows multiple types to be
specified at once in a comma-separated list.</dd>
<dt>
-ok
</dt>
<dd>Supported. Interpretation of the response is according to the
`yes&#39; and `no&#39; patterns selected by setting the <strong>LC_MESSAGES</strong>
environment variable. When the <strong>POSIXLY_CORRECT</strong> environment variable
is set, these patterns are taken system&#39;s definition of a positive
(yes) or negative (no) response. See the system&#39;s documentation for
<strong>nl_langinfo*(3), in particular YESEXPR and NOEXPR. When
*POSIXLY_CORRECT</strong> is not set, the patterns are instead taken from
<strong>find</strong>&#39;s own message catalogue.</dd>
<dt>
-newer
</dt>
<dd>Supported. If the file specified is a symbolic link, it is
always dereferenced. This is a change from previous behaviour, which
used to take the relevant time from the symbolic link; see the HISTORY
section below.</dd>
<dt>
-perm
</dt>
<dd>Supported. If the <strong>POSIXLY_CORRECT</strong> environment variable is
not set, some mode arguments (for example +a+x) which are not valid in
POSIX are supported for backward-compatibility.</dd>
<dt>
Other primaries
</dt>
<dd>The primaries <strong>-atime</strong>, <strong>-ctime</strong>, <strong>-depth</strong>,
<strong>-exec</strong>, <strong>-group</strong>, <strong>-links</strong>, <strong>-mtime</strong>, <strong>-nogroup</strong>, <strong>-nouser</strong>, <strong>-ok</strong>,
<strong>-path</strong>, <strong>-print</strong>, <strong>-prune</strong>, <strong>-size</strong>, <strong>-user</strong> and <strong>-xdev</strong> are all
supported.</dd>
</dl>
<p>The POSIX standard specifies parentheses `(&#39;, `)&#39;, negation `!&#39; and the
logical AND/OR operators <strong>-a</strong> and <strong>-o</strong>.</p>
<p>
All other options, predicates, expressions and so forth are extensions
beyond the POSIX standard. Many of these extensions are not unique to
GNU find, however.</p>
<p>
The POSIX standard requires that <strong>find</strong> detects loops:</p>
<blockquote>
<p>The <strong>find</strong> utility shall detect infinite loops; that is, entering a
previously visited directory that is an ancestor of the last file
encountered. When it detects an infinite loop, <strong>find</strong> shall write a
diagnostic message to standard error and shall either recover its
position in the hierarchy or terminate.</p>
</blockquote>
<p>
GNU <strong>find</strong> complies with these requirements. The link count of
directories which contain entries which are hard links to an ancestor
will often be lower than they otherwise should be. This can mean that
GNU find will sometimes optimize away the visiting of a subdirectory
which is actually a link to an ancestor. Since <strong>find</strong> does not actually
enter such a subdirectory, it is allowed to avoid emitting a diagnostic
message. Although this behaviour may be somewhat confusing, it is
unlikely that anybody actually depends on this behaviour. If the leaf
optimisation has been turned off with <strong>-noleaf</strong>, the directory entry
will always be examined and the diagnostic message will be issued where
it is appropriate. Symbolic links cannot be used to create filesystem
cycles as such, but if the <strong>-L</strong> option or the <strong>-follow</strong> option is in
use, a diagnostic message is issued when <strong>find</strong> encounters a loop of
symbolic links. As with loops containing hard links, the leaf
optimisation will often mean that <strong>find</strong> knows that it doesn&#39;t need to
call <em>stat()</em> or <em>chdir()</em> on the symbolic link, so this diagnostic is
frequently not necessary.</p>
<p>
The <strong>-d</strong> option is supported for compatibility with various BSD systems,
but you should use the POSIX-compliant option <strong>-depth</strong> instead.</p>
<p>
The <strong>POSIXLY_CORRECT</strong> environment variable does not affect the behaviour
of the <strong>-regex</strong> or <strong>-iregex</strong> tests because those tests aren&#39;t specified
in the POSIX standard.</p>
</div>
</div>
<div id="outline-container-headline-13" class="outline-2">
<h2 id="headline-13">
ENVIRONMENT VARIABLES
</h2>
<div id="outline-text-headline-13" class="outline-text-2">
<dl>
<dt>
LANG
</dt>
<dd>Provides a default value for the internationalization
variables that are unset or null.</dd>
<dt>
LC_ALL
</dt>
<dd>If set to a non-empty string value, override the values of
all the other internationalization variables.</dd>
<dt>
LC_COLLATE
</dt>
<dd>The POSIX standard specifies that this variable affects
the pattern matching to be used for the <strong>-name</strong> option. GNU find uses
the <strong>fnmatch*(3) library function, and so support for *LC_COLLATE</strong>
depends on the system library. This variable also affects the
interpretation of the response to <strong>-ok</strong>; while the <strong>LC_MESSAGES</strong>
variable selects the actual pattern used to interpret the response to
<strong>-ok</strong>, the interpretation of any bracket expressions in the pattern
will be affected by <strong>LC_COLLATE</strong>.</dd>
<dt>
LC_CTYPE
</dt>
<dd>This variable affects the treatment of character classes
used in regular expressions and also with the <strong>-name</strong> test, if the
system&#39;s *fnmatch*(3) library function supports this. This variable
also affects the interpretation of any character classes in the
regular expressions used to interpret the response to the prompt
issued by <strong>-ok</strong>. The <strong>LC_CTYPE</strong> environment variable will also affect
which characters are considered to be unprintable when filenames are
printed; see the section UNUSUAL FILENAMES.</dd>
<dt>
LC_MESSAGES
</dt>
<dd>Determines the locale to be used for internationalised
messages. If the <strong>POSIXLY_CORRECT</strong> environment variable is set, this
also determines the interpretation of the response to the prompt made
by the <strong>-ok</strong> action.</dd>
<dt>
NLSPATH
</dt>
<dd>Determines the location of the internationalisation message
catalogues.</dd>
<dt>
PATH
</dt>
<dd>Affects the directories which are searched to find the
executables invoked by <strong>-exec</strong>, <strong>-execdir</strong>, <strong>-ok</strong> and <strong>-okdir</strong>.</dd>
<dt>
POSIXLY_CORRECT
</dt>
<dd>Determines the block size used by <strong>-ls</strong> and <strong>-fls</strong>.
If <strong>POSIXLY_CORRECT</strong> is set, blocks are units of 512 bytes. Otherwise
they are units of 1024 bytes.

Setting this variable also turns off warning messages (that is,
implies <strong>-nowarn</strong>) by default, because POSIX requires that apart from
the output for <strong>-ok</strong>, all messages printed on stderr are diagnostics
and must result in a non-zero exit status.

When <strong>POSIXLY_CORRECT</strong> is not set, <strong>-perm <em>+zzz</em></strong> is treated just like
<strong>-perm <em>/zzz</em></strong> if <em>+zzz</em> is not a valid symbolic mode. When
<strong>POSIXLY_CORRECT</strong> is set, such constructs are treated as an error.

When <strong>POSIXLY_CORRECT</strong> is set, the response to the prompt made by the
<strong>-ok</strong> action is interpreted according to the system&#39;s message
catalogue, as opposed to according to <strong>find</strong>&#39;s own message
translations.</dd>
<dt>
TZ
</dt>
<dd>Affects the time zone used for some of the time-related format
directives of <strong>-printf</strong> and <strong>-fprintf</strong>.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-14" class="outline-2">
<h2 id="headline-14">
EXAMPLES
</h2>
<div id="outline-text-headline-14" class="outline-text-2">
<div id="outline-container-headline-15" class="outline-3">
<h3 id="headline-15">
Simple `find|xargs` approach
</h3>
<div id="outline-text-headline-15" class="outline-text-3">
<ul>
<li>Find files named <em>core</em> in or below the directory <em>/tmp</em> and delete
them.</li>
</ul>
<pre class="example">
$ find /tmp -name core -type f -print | xargs /bin/rm -f
</pre>
<p>
Note that this will work incorrectly if there are any filenames
containing newlines, single or double quotes, or spaces.</p>
</div>
</div>
<div id="outline-container-headline-16" class="outline-3">
<h3 id="headline-16">
Safer `find -print0 | xargs -0` approach
</h3>
<div id="outline-text-headline-16" class="outline-text-3">
<ul>
<li>Find files named <em>core</em> in or below the directory <em>/tmp</em> and delete
them, processing filenames in such a way that file or directory names
containing single or double quotes, spaces or newlines are correctly
handled.</li>
</ul>
<pre class="example">
$ find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f
</pre>
<p>
The <strong>-name</strong> test comes before the <strong>-type</strong> test in order to avoid having
to call *stat*(2) on every file.</p>
<p>
Note that there is still a race between the time <strong>find</strong> traverses the
hierarchy printing the matching filenames, and the time the process
executed by <strong>xargs</strong> works with that file.</p>
</div>
</div>
<div id="outline-container-headline-17" class="outline-3">
<h3 id="headline-17">
Processing arbitrary starting points
</h3>
<div id="outline-text-headline-17" class="outline-text-3">
<ul>
<li>Given that another program <em>proggy</em> pre-filters and creates a huge
NUL-separated list of files, process those as starting points, and
find all regular, empty files among them:</li>
</ul>
<pre class="example">
$ proggy | find -files0-from - -maxdepth 0 -type f -empty
</pre>
<p>
The use of <strong>`-files0-from -`</strong> means to read the names of the starting
points from <em>standard input</em>, i.e., from the pipe; and <strong>-maxdepth 0</strong>
ensures that only explicitly those entries are examined without
recursing into directories (in the case one of the starting points is
one).</p>
</div>
</div>
<div id="outline-container-headline-18" class="outline-3">
<h3 id="headline-18">
Executing a command for each file
</h3>
<div id="outline-text-headline-18" class="outline-text-3">
<ul>
<li>Run <em>file</em> on every file in or below the current directory.</li>
</ul>
<pre class="example">
$ find . -type f -exec file &#39;{}&#39; \;
</pre>
<p>
Notice that the braces are enclosed in single quote marks to protect
them from interpretation as shell script punctuation. The semicolon is
similarly protected by the use of a backslash, though single quotes
could have been used in that case also.</p>
<p>
In many cases, one might prefer the <strong>`-exec … +`</strong> or better the
<strong>`-execdir … +`</strong> syntax for performance and security reasons.</p>
</div>
</div>
<div id="outline-container-headline-19" class="outline-3">
<h3 id="headline-19">
Traversing the filesystem just once - for 2 different actions
</h3>
<div id="outline-text-headline-19" class="outline-text-3">
<ul>
<li>Traverse the filesystem just once, listing set-user-ID files and
directories into <em>/root/suid.txt</em> and large files into
<em>/root/big.txt</em>.</li>
</ul>
<pre class="example">
$ find / \
\( -perm -4000 -fprintf /root/suid.txt &#39;%#m %u %p\n&#39; \) , \


\( -size +100M -fprintf /root/big.txt &#39;%-10s %p\n&#39; \)
</pre>
<p>
This example uses the line-continuation character &#39;\&#39; on the first two
lines to instruct the shell to continue reading the command on the next
line.</p>
</div>
</div>
<div id="outline-container-headline-20" class="outline-3">
<h3 id="headline-20">
Searching files by age
</h3>
<div id="outline-text-headline-20" class="outline-text-3">
<ul>
<li>Search for files in your home directory which have been modified in
the last twenty-four hours.</li>
</ul>
<pre class="example">
$ find $HOME -mtime 0
</pre>
<p>
This command works this way because the time since each file was last
modified is divided by 24 hours and any remainder is discarded. That
means that to match <strong>-mtime</strong> <strong>0</strong>, a file will have to have a
modification in the past which is less than 24 hours ago.</p>
</div>
</div>
<div id="outline-container-headline-21" class="outline-3">
<h3 id="headline-21">
Searching files by permissions
</h3>
<div id="outline-text-headline-21" class="outline-text-3">
<ul>
<li>Search for files which are executable but not readable.</li>
</ul>
<pre class="example">
$ find /sbin /usr/sbin -executable \! -readable -print
</pre>
<ul>
<li>Search for files which have read and write permission for their owner,
and group, but which other users can read but not write to.</li>
</ul>
<pre class="example">
$ find . -perm 664
</pre>
<p>
Files which meet these criteria but have other permissions bits set (for
example if someone can execute the file) will not be matched.</p>
<ul>
<li>Search for files which have read and write permission for their owner
and group, and which other users can read, without regard to the
presence of any extra permission bits (for example the executable
bit).</li>
</ul>
<pre class="example">
$ find . -perm -664
</pre>
<p>
This will match a file which has mode <em>0777</em>, for example.</p>
<ul>
<li>Search for files which are writable by somebody (their owner, or their
group, or anybody else).</li>
</ul>
<pre class="example">
$ find . -perm /222
</pre>
<ul>
<li>Search for files which are writable by either their owner or their
group.</li>
</ul>
<pre class="example">
$ find . -perm /220
$ find . -perm /u+w,g+w
$ find . -perm /u=w,g=w
</pre>
<p>
All three of these commands do the same thing, but the first one uses
the octal representation of the file mode, and the other two use the
symbolic form. The files don&#39;t have to be writable by both the owner and
group to be matched; either will do.</p>
<ul>
<li>Search for files which are writable by both their owner and their
group.</li>
</ul>
<pre class="example">
$ find . -perm -220
$ find . -perm -g+w,u+w
</pre>
<p>
Both these commands do the same thing.</p>
<ul>
<li>A more elaborate search on permissions.</li>
</ul>
<pre class="example">
$ find . -perm -444 -perm /222 \! -perm /111
$ find . -perm -a+r -perm /a+w \! -perm /a+x
</pre>
<p>
These two commands both search for files that are readable for everybody
(<strong>-perm -444</strong> or <strong>-perm -a+r</strong>), have at least one write bit set (<strong>-perm
/222</strong> or <strong>-perm /a+w</strong>) but are not executable for anybody (<strong>! -perm
/111</strong> or <strong>! -perm /a+x</strong> respectively).</p>
</div>
</div>
<div id="outline-container-headline-22" class="outline-3">
<h3 id="headline-22">
Pruning - omitting files and subdirectories
</h3>
<div id="outline-text-headline-22" class="outline-text-3">
<ul>
<li>Copy the contents of <em>/source-dir</em> to <em>/dest-dir</em>, but omit files and
directories named <em>.snapshot</em> (and anything in them). It also omits
files or directories whose name ends in `~&#39;, but not their contents.</li>
</ul>
<pre class="example">
$ cd /source-dir
$ find . -name .snapshot -prune -o \( \! -name &#39;*~&#39; -print0 \) \


| cpio -pmd0 /dest-dir
</pre>
<p>
The construct <strong>-prune -o \( ... -print0 \)</strong> is quite common. The idea
here is that the expression before <strong>-prune</strong> matches things which are to
be pruned. However, the <strong>-prune</strong> action itself returns true, so the
following <strong>-o</strong> ensures that the right hand side is evaluated only for
those directories which didn&#39;t get pruned (the contents of the pruned
directories are not even visited, so their contents are irrelevant). The
expression on the right hand side of the <strong>-o</strong> is in parentheses only for
clarity. It emphasises that the <strong>-print0</strong> action takes place only for
things that didn&#39;t have <strong>-prune</strong> applied to them. Because the default
`and&#39; condition between tests binds more tightly than <strong>-o</strong>, this is the
default anyway, but the parentheses help to show what is going on.</p>
<ul>
<li>Given the following directory of projects and their associated SCM
administrative directories, perform an efficient search for the
projects&#39; roots:</li>
</ul>
<pre class="example">
$ find repo/ \
\( -exec test -d &#39;{}/.svn&#39; \; \
-or -exec test -d &#39;{}/.git&#39; \; \
-or -exec test -d &#39;{}/CVS&#39; \; \
\) -print -prune
</pre>
<p>
Sample output:</p>
<pre class="example">
repo/project1/CVS
repo/gnu/project2/.svn
repo/gnu/project3/.svn
repo/gnu/project3/src/.svn
repo/project4/.git
</pre>
<p>
In this example, <strong>-prune</strong> prevents unnecessary descent into directories
that have already been discovered (for example we do not search
<em>project3/src</em> because we already found <em>project3</em>.svn/), but ensures
sibling directories (<em>project2</em> and <em>project3</em>) are found.</p>
</div>
</div>
<div id="outline-container-headline-23" class="outline-3">
<h3 id="headline-23">
Other useful examples
</h3>
<div id="outline-text-headline-23" class="outline-text-3">
<ul>
<li>Search for several file types.</li>
</ul>
<pre class="example">
$ find /tmp -type f,d,l
</pre>
<p>
Search for files, directories, and symbolic links in the directory
<em>/tmp</em> passing these types as a comma-separated list (GNU extension),
which is otherwise equivalent to the longer, yet more portable:</p>
<pre class="example">
$ find /tmp \( -type f -o -type d -o -type l \)
</pre>
<ul>
<li>Search for files with the particular name <em>needle</em> and stop
immediately when we find the first one.</li>
</ul>
<pre class="example">
$ find / -name needle -print -quit
</pre>
<ul>
<li>Demonstrate the interpretation of the <strong>%f</strong> and <strong>%h</strong> format directives
of the <strong>-printf</strong> action for some corner-cases. Here is an example
including some output.</li>
</ul>
<pre class="example">
$ find . .. / /tmp /tmp/TRACE compile compile/64/tests/find -maxdepth 0 -printf &#39;[%h][%f]\n&#39;
[.][.]
[.][..]
[][/]
[][tmp]
[/tmp][TRACE]
[.][compile]
[compile/64/tests][find]
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-24" class="outline-2">
<h2 id="headline-24">
EXIT STATUS
</h2>
<div id="outline-text-headline-24" class="outline-text-2">
<p><strong>find</strong> exits with status 0 if all files are processed successfully,
greater than 0 if errors occur. This is deliberately a very broad
description, but if the return value is non-zero, you should not rely on
the correctness of the results of <strong>find</strong>.</p>
<p>
When some error occurs, <strong>find</strong> may stop immediately, without completing
all the actions specified. For example, some starting points may not
have been examined or some pending program invocations for <strong>-exec … {}
+</strong> or <strong>&#34;-execdir … {} +</strong> may not have been performed.</p>
</div>
</div>
<div id="outline-container-headline-25" class="outline-2">
<h2 id="headline-25">
HISTORY
</h2>
<div id="outline-text-headline-25" class="outline-text-2">
<p>A <strong>find</strong> program appeared in Version 5 Unix as part of the Programmer&#39;s
Workbench project and was written by Dick Haight. Doug McIlroy&#39;s /A
Research UNIX Reader: Annotated Excerpts from the Programmer&#39;s Manual,
1971-1986/ provides some additional details; you can read it on-line at
&lt;<a href="https://www.cs.dartmouth.edu/~doug/reader.pdf">https://www.cs.dartmouth.edu/~doug/reader.pdf</a>&gt;.</p>
<p>
GNU <strong>find</strong> was originally written by Eric Decker, with enhancements by
David MacKenzie, Jay Plett, and Tim Wood. The idea for <strong>find -print0</strong>
and <strong>xargs -0</strong> came from Dan Bernstein.</p>
</div>
</div>
<div id="outline-container-headline-26" class="outline-2">
<h2 id="headline-26">
COMPATIBILITY
</h2>
<div id="outline-text-headline-26" class="outline-text-2">
<p>As of findutils-4.2.2, shell metacharacters (`*&#39;, `?&#39; or `[]&#39; for
example) used in filename patterns match a leading `.&#39;, because IEEE
POSIX interpretation 126 requires this.</p>
<p>
As of findutils-4.3.3, <strong>-perm /000</strong> now matches all files instead of
none.</p>
<p>
Nanosecond-resolution timestamps were implemented in findutils-4.3.3.</p>
<p>
As of findutils-4.3.11, the <strong>-delete</strong> action sets <strong>find</strong>&#39;s exit status
to a nonzero value when it fails. However, <strong>find</strong> will not exit
immediately. Previously, <strong>find</strong>&#39;s exit status was unaffected by the
failure of <strong>-delete</strong>.</p>
<table>
<tbody>
<tr>
<td>Feature</td>
<td>Added in</td>
<td>Also occurs in</td>
</tr>
<tr>
<td>-files0-from</td>
<td>4.9.0</td>
<td></td>
</tr>
<tr>
<td>-newerXY</td>
<td>4.3.3</td>
<td>BSD</td>
</tr>
<tr>
<td>-D</td>
<td>4.3.1</td>
<td></td>
</tr>
<tr>
<td>-O</td>
<td>4.3.1</td>
<td></td>
</tr>
<tr>
<td>-readable</td>
<td>4.3.0</td>
<td></td>
</tr>
<tr>
<td>-writable</td>
<td>4.3.0</td>
<td></td>
</tr>
<tr>
<td>-executable</td>
<td>4.3.0</td>
<td></td>
</tr>
<tr>
<td>-regextype</td>
<td>4.2.24</td>
<td></td>
</tr>
<tr>
<td>-exec … +</td>
<td>4.2.12</td>
<td>POSIX</td>
</tr>
<tr>
<td>-execdir</td>
<td>4.2.12</td>
<td>BSD</td>
</tr>
<tr>
<td>-okdir</td>
<td>4.2.12</td>
<td></td>
</tr>
<tr>
<td>-samefile</td>
<td>4.2.11</td>
<td></td>
</tr>
<tr>
<td>-H</td>
<td>4.2.5</td>
<td>POSIX</td>
</tr>
<tr>
<td>-L</td>
<td>4.2.5</td>
<td>POSIX</td>
</tr>
<tr>
<td>-P</td>
<td>4.2.5</td>
<td>BSD</td>
</tr>
<tr>
<td>-delete</td>
<td>4.2.3</td>
<td></td>
</tr>
<tr>
<td>-quit</td>
<td>4.2.3</td>
<td></td>
</tr>
<tr>
<td>-d</td>
<td>4.2.3</td>
<td>BSD</td>
</tr>
<tr>
<td>-wholename</td>
<td>4.2.0</td>
<td></td>
</tr>
<tr>
<td>-iwholename</td>
<td>4.2.0</td>
<td></td>
</tr>
<tr>
<td>-ignore_readdir_race</td>
<td>4.2.0</td>
<td></td>
</tr>
<tr>
<td>-fls</td>
<td>4.0</td>
<td></td>
</tr>
<tr>
<td>-ilname</td>
<td>3.8</td>
<td></td>
</tr>
<tr>
<td>-iname</td>
<td>3.8</td>
<td></td>
</tr>
<tr>
<td>-ipath</td>
<td>3.8</td>
<td></td>
</tr>
<tr>
<td>-iregex</td>
<td>3.8</td>
<td></td>
</tr>
</tbody>
</table>
<p>
The syntax .B -perm +MODE was removed in findutils-4.5.12, in favour of
.B -perm <strong>/MODE</strong>. The <strong>+MODE</strong> syntax had been deprecated since
findutils-4.2.21 which was released in 2005.</p>
</div>
</div>
<div id="outline-container-headline-27" class="outline-2">
<h2 id="headline-27">
NON-BUGS
</h2>
<div id="outline-text-headline-27" class="outline-text-2">
<div id="outline-container-headline-28" class="outline-3">
<h3 id="headline-28">
Operator precedence surprises
</h3>
<div id="outline-text-headline-28" class="outline-text-3">
<p>The command <strong>find . -name afile -o -name bfile -print</strong> will never print
<em>afile</em> because this is actually equivalent to <strong>find . -name afile -o \(
-name bfile -a -print \)</strong>. Remember that the precedence of <strong>-a</strong> is
higher than that of <strong>-o</strong> and when there is no operator specified between
tests, <strong>-a</strong> is assumed.</p>
</div>
</div>
<div id="outline-container-headline-29" class="outline-3">
<h3 id="headline-29">
“paths must precede expression” error message
</h3>
<div id="outline-text-headline-29" class="outline-text-3">
<pre class="example">
$ find . -name *.c -print
find: paths must precede expression
find: possible unquoted pattern after predicate `-name&#39;?
</pre>
<p>
This happens when the shell could expand the pattern <em>*.c</em> to more than
one file name existing in the current directory, and passing the
resulting file names in the command line to <strong>find</strong> like this:</p>
<pre class="example">
find . -name frcode.c locate.c word_io.c -print
</pre>
<p>
That command is of course not going to work, because the <strong>-name</strong>
predicate allows exactly only one pattern as argument. Instead of doing
things this way, you should enclose the pattern in quotes or escape the
wildcard, thus allowing <strong>find</strong> to use the pattern with the wildcard
during the search for file name matching instead of file names expanded
by the parent shell:</p>
<pre class="example">
$ find . -name &#39;*.c&#39; -print
$ find . -name \*.c -print
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-30" class="outline-2">
<h2 id="headline-30">
BUGS
</h2>
<div id="outline-text-headline-30" class="outline-text-2">
<p>There are security problems inherent in the behaviour that the POSIX
standard specifies for <strong>find</strong>, which therefore cannot be fixed. For
example, the <strong>-exec</strong> action is inherently insecure, and <strong>-execdir</strong>
should be used instead.</p>
<p>
The environment variable <strong>LC_COLLATE</strong> has no effect on the <strong>-ok</strong> action.</p>
</div>
</div>
<div id="outline-container-headline-31" class="outline-2">
<h2 id="headline-31">
REPORTING BUGS
</h2>
<div id="outline-text-headline-31" class="outline-text-2">
<p>GNU findutils online help:
&lt;<a href="https://www.gnu.org/software/findutils/#get-help">https://www.gnu.org/software/findutils/#get-help</a>&gt;<br>
Report any translation bugs to &lt;<a href="https://translationproject.org/team/">https://translationproject.org/team/</a>&gt;</p>
<p>
Report any other issue via the form at the GNU Savannah bug tracker:</p>
<blockquote>
<p>&lt;https://savannah.gnu.org/bugs/?group=findutils&gt;</p>
</blockquote>
<p>
General topics about the GNU findutils package are discussed at the
<em>bug-findutils</em> mailing list:</p>
<blockquote>
<p>&lt;https://lists.gnu.org/mailman/listinfo/bug-findutils&gt;</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-32" class="outline-2">
<h2 id="headline-32">
COPYRIGHT
</h2>
<div id="outline-text-headline-32" class="outline-text-2">
<p>Copyright © 1990–2024 Free Software Foundation, Inc. License GPLv3+:
GNU GPL version 3 or later &lt;<a href="https://gnu.org/licenses/gpl.html">https://gnu.org/licenses/gpl.html</a>&gt;.<br>
This is free software: you are free to change and redistribute it. There
is NO WARRANTY, to the extent permitted by law.</p>
</div>
</div>
<div id="outline-container-headline-33" class="outline-2">
<h2 id="headline-33">
SEE ALSO
</h2>
<div id="outline-text-headline-33" class="outline-text-2">
<p>*chmod*(1), *locate*(1), *ls*(1), *updatedb*(1), *xargs*(1), *lstat*(2),
*stat*(2), *ctime*(3) *fnmatch*(3), *printf*(3), *strftime*(3),
*locatedb*(5), *regex*(7)</p>
<p>
Full documentation &lt;<a href="https://www.gnu.org/software/findutils/find">https://www.gnu.org/software/findutils/find</a>&gt;<br>
or available locally via: <strong>info find</strong></p>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.js"></script>
    </body>
</html>
