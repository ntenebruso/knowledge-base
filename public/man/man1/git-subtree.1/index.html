<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - git-subtree.1 | Technical Notes</title>

    <link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - git-subtree.1</h1>
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
NAME
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>git-subtree - Merge subtrees together and split repository into subtrees</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
SYNOPSIS
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<pre class="example">
git subtree [&lt;options&gt;] -P &lt;prefix&gt; add &lt;local-commit&gt;
git subtree [&lt;options&gt;] -P &lt;prefix&gt; add &lt;repository&gt; &lt;remote-ref&gt;
git subtree [&lt;options&gt;] -P &lt;prefix&gt; merge &lt;local-commit&gt; [&lt;repository&gt;]
git subtree [&lt;options&gt;] -P &lt;prefix&gt; split [&lt;local-commit&gt;]
</pre>
<pre class="example">
git subtree [&lt;options&gt;] -P &lt;prefix&gt; pull &lt;repository&gt; &lt;remote-ref&gt;
git subtree [&lt;options&gt;] -P &lt;prefix&gt; push &lt;repository&gt; &lt;refspec&gt;
</pre>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
DESCRIPTION
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p>Subtrees allow subprojects to be included within a subdirectory of the
main project, optionally including the subproject&#39;s entire history.</p>
<p>
For example, you could include the source code for a library as a
subdirectory of your application.</p>
<p>
Subtrees are not to be confused with submodules, which are meant for the
same task. Unlike submodules, subtrees do not need any special
constructions (like <em>.gitmodules</em> files or gitlinks) be present in your
repository, and do not force end-users of your repository to do anything
special or to understand how subtrees work. A subtree is just a
subdirectory that can be committed to, branched, and merged along with
your project in any way you want.</p>
<p>
They are also not to be confused with using the subtree merge strategy.
The main difference is that, besides merging the other project as a
subdirectory, you can also extract the entire history of a subdirectory
from your project and make it into a standalone project. Unlike the
subtree merge strategy you can alternate back and forth between these
two operations. If the standalone library gets updated, you can
automatically merge the changes into your project; if you update the
library inside your project, you can &#34;split&#34; the changes back out again
and merge them back into the library project.</p>
<p>
For example, if a library you made for one application ends up being
useful elsewhere, you can extract its entire history and publish that as
its own git repository, without accidentally intermingling the history
of your application project.</p>
<blockquote>
<p>\\</p>
<p>
<strong>Tip</strong></p>
<p>
\\</p>
<p>
In order to keep your commit messages clean, we recommend that people
split their commits between the subtrees and the main project as much as
possible. That is, if you make a change that affects both the library
and the main application, commit it in two pieces. That way, when you
split the library commits out later, their descriptions will still make
sense. But if this isn&#39;t important to you, it&#39;s not <strong>necessary</strong>. <em>git
subtree</em> will simply leave out the non-library-related parts of the
commit when it splits it out into the subproject later.</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
COMMANDS
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<p>add &lt;local-commit&gt;, add &lt;repository&gt; &lt;remote-ref&gt;</p>
<blockquote>
<p>Create the &lt;prefix&gt; subtree by importing its contents from the given
&lt;local-commit&gt; or &lt;repository&gt; and &lt;remote-ref&gt;. A new commit is created
automatically, joining the imported project&#39;s history with your own.
With <em>–squash</em>, import only a single commit from the subproject, rather
than its entire history.</p>
</blockquote>
<p>
merge &lt;local-commit&gt; [&lt;repository&gt;]</p>
<blockquote>
<p>Merge recent changes up to &lt;local-commit&gt; into the &lt;prefix&gt; subtree. As
with normal <em>git merge</em>, this doesn&#39;t remove your own local changes; it
just merges those changes into the latest &lt;local-commit&gt;. With
<em>–squash</em>, create only one commit that contains all the changes, rather
than merging in the entire history.</p>
<p>
If you use <em>–squash</em>, the merge direction doesn&#39;t always have to be
forward; you can use this command to go back in time from v2.5 to v2.4,
for example. If your merge introduces a conflict, you can resolve it in
the usual ways.</p>
<p>
When using <em>–squash</em>, and the previous merge with <em>–squash</em> merged an
annotated tag of the subtree repository, that tag needs to be available
locally. If &lt;repository&gt; is given, a missing tag will automatically be
fetched from that repository.</p>
</blockquote>
<p>
split [&lt;local-commit&gt;] [&lt;repository&gt;]</p>
<blockquote>
<p>Extract a new, synthetic project history from the history of the
&lt;prefix&gt; subtree of &lt;local-commit&gt;, or of HEAD if no &lt;local-commit&gt; is
given. The new history includes only the commits (including merges) that
affected &lt;prefix&gt;, and each of those commits now has the contents of
&lt;prefix&gt; at the root of the project instead of in a subdirectory. Thus,
the newly created history is suitable for export as a separate git
repository.</p>
<p>
After splitting successfully, a single commit ID is printed to stdout.
This corresponds to the HEAD of the newly created tree, which you can
manipulate however you want.</p>
<p>
Repeated splits of exactly the same history are guaranteed to be
identical (i.e. to produce the same commit IDs) as long as the settings
passed to <em>split</em> (such as <em>–annotate</em>) are the same. Because of this,
if you add new commits and then re-split, the new commits will be
attached as commits on top of the history you generated last time, so
<em>git merge</em> and friends will work as expected.</p>
<p>
When a previous merge with <em>–squash</em> merged an annotated tag of the
subtree repository, that tag needs to be available locally. If
&lt;repository&gt; is given, a missing tag will automatically be fetched from
that repository.</p>
</blockquote>
<p>
pull &lt;repository&gt; &lt;remote-ref&gt;</p>
<blockquote>
<p>Exactly like <em>merge</em>, but parallels <em>git pull</em> in that it fetches the
given ref from the specified remote repository.</p>
</blockquote>
<p>
push &lt;repository&gt; [+][&lt;local-commit&gt;:]&lt;remote-ref&gt;</p>
<blockquote>
<p>Does a <em>split</em> using the &lt;prefix&gt; subtree of &lt;local-commit&gt; and then
does a <em>git push</em> to push the result to the &lt;repository&gt; and
&lt;remote-ref&gt;. This can be used to push your subtree to different
branches of the remote repository. Just as with <em>split</em>, if no
&lt;local-commit&gt; is given, then HEAD is used. The optional leading <em>+</em> is
ignored.</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-5" class="outline-2">
<h2 id="headline-5">
OPTIONS FOR ALL COMMANDS
</h2>
<div id="outline-text-headline-5" class="outline-text-2">
<p>-q, –quiet</p>
<blockquote>
<p>Suppress unnecessary output messages on stderr.</p>
</blockquote>
<p>
-d, –debug</p>
<blockquote>
<p>Produce even more unnecessary output messages on stderr.</p>
</blockquote>
<p>
-P &lt;prefix&gt;, –prefix=&lt;prefix&gt;</p>
<blockquote>
<p>Specify the path in the repository to the subtree you want to
manipulate. This option is mandatory for all commands.</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-6" class="outline-2">
<h2 id="headline-6">
OPTIONS FOR FIADDFR AND FIMERGEFR (ALSO: FIPULLFR, FISPLIT –REJOINFR, AND FIPUSH –REJOINFR)
</h2>
<div id="outline-text-headline-6" class="outline-text-2">
<p>These options for <em>add</em> and <em>merge</em> may also be given to <em>pull</em> (which
wraps <em>merge</em>), <em>split –rejoin</em> (which wraps either <em>add</em> or <em>merge</em> as
appropriate), and <em>push –rejoin</em> (which wraps <em>split –rejoin</em>).</p>
<p>
–squash</p>
<blockquote>
<p>Instead of merging the entire history from the subtree project, produce
only a single commit that contains all the differences you want to
merge, and then merge that new commit into your project.</p>
<p>
Using this option helps to reduce log clutter. People rarely want to see
every change that happened between v1.0 and v1.1 of the library they&#39;re
using, since none of the interim versions were ever included in their
application.</p>
<p>
Using <em>–squash</em> also helps avoid problems when the same subproject is
included multiple times in the same project, or is removed and then
re-added. In such a case, it doesn&#39;t make sense to combine the histories
anyway, since it&#39;s unclear which part of the history belongs to which
subtree.</p>
<p>
Furthermore, with <em>–squash</em>, you can switch back and forth between
different versions of a subtree, rather than strictly forward. <em>git
subtree merge –squash</em> always adjusts the subtree to match the exactly
specified commit, even if getting to that commit would require undoing
some changes that were added earlier.</p>
<p>
Whether or not you use <em>–squash</em>, changes made in your local repository
remain intact and can be later split and send upstream to the
subproject.</p>
</blockquote>
<p>
-m &lt;message&gt;, –message=&lt;message&gt;</p>
<blockquote>
<p>Specify &lt;message&gt; as the commit message for the merge commit.</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-7" class="outline-2">
<h2 id="headline-7">
OPTIONS FOR FISPLITFR (ALSO: FIPUSHFR)
</h2>
<div id="outline-text-headline-7" class="outline-text-2">
<p>These options for <em>split</em> may also be given to <em>push</em> (which wraps
<em>split</em>).</p>
<p>
–annotate=&lt;annotation&gt;</p>
<blockquote>
<p>When generating synthetic history, add &lt;annotation&gt; as a prefix to each
commit message. Since we&#39;re creating new commits with the same commit
message, but possibly different content, from the original commits, this
can help to differentiate them and avoid confusion.</p>
<p>
Whenever you split, you need to use the same &lt;annotation&gt;, or else you
don&#39;t have a guarantee that the new re-created history will be identical
to the old one. That will prevent merging from working correctly. git
subtree tries to make it work anyway, particularly if you use
<em>–rejoin</em>, but it may not always be effective.</p>
</blockquote>
<p>
-b &lt;branch&gt;, –branch=&lt;branch&gt;</p>
<blockquote>
<p>After generating the synthetic history, create a new branch called
&lt;branch&gt; that contains the new history. This is suitable for immediate
pushing upstream. &lt;branch&gt; must not already exist.</p>
</blockquote>
<p>
–ignore-joins</p>
<blockquote>
<p>If you use <em>–rejoin</em>, git subtree attempts to optimize its history
reconstruction to generate only the new commits since the last
<em>–rejoin</em>. <em>–ignore-joins</em> disables this behavior, forcing it to
regenerate the entire history. In a large project, this can take a long
time.</p>
</blockquote>
<p>
–onto=&lt;onto&gt;</p>
<blockquote>
<p>If your subtree was originally imported using something other than git
subtree, its history may not match what git subtree is expecting. In
that case, you can specify the commit ID &lt;onto&gt; that corresponds to the
first revision of the subproject&#39;s history that was imported into your
project, and git subtree will attempt to build its history from there.</p>
<p>
If you used <em>git subtree add</em>, you should never need this option.</p>
</blockquote>
<p>
–rejoin</p>
<blockquote>
<p>After splitting, merge the newly created synthetic history back into
your main project. That way, future splits can search only the part of
history that has been added since the most recent <em>–rejoin</em>.</p>
<p>
If your split commits end up merged into the upstream subproject, and
then you want to get the latest upstream version, this will allow git&#39;s
merge algorithm to more intelligently avoid conflicts (since it knows
these synthetic commits are already part of the upstream repository).</p>
<p>
Unfortunately, using this option results in <em>git log</em> showing an extra
copy of every new commit that was created (the original, and the
synthetic one).</p>
<p>
If you do all your merges with <em>–squash</em>, make sure you also use
<em>–squash</em> when you <em>split –rejoin</em>.</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-8" class="outline-2">
<h2 id="headline-8">
EXAMPLE 1. FIADDFR COMMAND
</h2>
<div id="outline-text-headline-8" class="outline-text-2">
<p>Let&#39;s assume that you have a local repository that you would like to add
an external vendor library to. In this case we will add the git-subtree
repository as a subdirectory of your already existing git-extensions
repository in ~/git-extensions/:</p>
<blockquote>
<pre class="example">
$ git subtree add --prefix=git-subtree --squash \
        git://github.com/apenwarr/git-subtree.git master
</pre>
</blockquote>
<p>
<em>master</em> needs to be a valid remote ref and can be a different branch
name</p>
<p>
You can omit the <em>–squash</em> flag, but doing so will increase the number
of commits that are included in your local repository.</p>
<p>
We now have a ~/git-extensions/git-subtree directory containing code
from the master branch of git://github.com/apenwarr/git-subtree.git in
our git-extensions repository.</p>
</div>
</div>
<div id="outline-container-headline-9" class="outline-2">
<h2 id="headline-9">
EXAMPLE 2. EXTRACT A SUBTREE USING FICOMMITFR, FIMERGEFR AND FIPULLFR
</h2>
<div id="outline-text-headline-9" class="outline-text-2">
<p>Let&#39;s use the repository for the git source code as an example. First,
get your own copy of the git.git repository:</p>
<blockquote>
<pre class="example">
$ git clone git://git.kernel.org/pub/scm/git/git.git test-git
$ cd test-git
</pre>
</blockquote>
<p>
gitweb (commit 1130ef3) was merged into git as of commit 0a8f4f0, after
which it was no longer maintained separately. But imagine it had been
maintained separately, and we wanted to extract git&#39;s changes to gitweb
since that time, to share with the upstream. You could do this:</p>
<blockquote>
<pre class="example">
$ git subtree split --prefix=gitweb --annotate=(split)  \
        0a8f4f0^.. --onto=1130ef3 --rejoin \
        --branch gitweb-latest
$ gitk gitweb-latest
$ git push git@github.com:whatever/gitweb.git gitweb-latest:master
</pre>
</blockquote>
<p>
(We use <em>0a8f4f0^..</em> because that means &#34;all the changes from 0a8f4f0 to
the current version, including 0a8f4f0 itself.&#34;)</p>
<p>
If gitweb had originally been merged using <em>git subtree add</em> (or a
previous split had already been done with <em>–rejoin</em> specified) then you
can do all your splits without having to remember any weird commit IDs:</p>
<blockquote>
<pre class="example">
$ git subtree split --prefix=gitweb --annotate=(split)  --rejoin \
        --branch gitweb-latest2
</pre>
</blockquote>
<p>
And you can merge changes back in from the upstream project just as
easily:</p>
<blockquote>
<pre class="example">
$ git subtree pull --prefix=gitweb \
        git@github.com:whatever/gitweb.git master
</pre>
</blockquote>
<p>
Or, using <em>–squash</em>, you can actually rewind to an earlier version of
gitweb:</p>
<blockquote>
<pre class="example">
$ git subtree merge --prefix=gitweb --squash gitweb-latest~10
</pre>
</blockquote>
<p>
Then make some changes:</p>
<blockquote>
<pre class="example">
$ date &gt;gitweb/myfile
$ git add gitweb/myfile
$ git commit -m created myfile
</pre>
</blockquote>
<p>
And fast forward again:</p>
<blockquote>
<pre class="example">
$ git subtree merge --prefix=gitweb --squash gitweb-latest
</pre>
</blockquote>
<p>
And notice that your change is still intact:</p>
<blockquote>
<pre class="example">
$ ls -l gitweb/myfile
</pre>
</blockquote>
<p>
And you can split it out and look at your changes versus the standard
gitweb:</p>
<blockquote>
<pre class="example">
git log gitweb-latest..$(git subtree split --prefix=gitweb)
</pre>
</blockquote>
</div>
</div>
<div id="outline-container-headline-10" class="outline-2">
<h2 id="headline-10">
EXAMPLE 3. EXTRACT A SUBTREE USING A BRANCH
</h2>
<div id="outline-text-headline-10" class="outline-text-2">
<p>Suppose you have a source directory with many files and subdirectories,
and you want to extract the lib directory to its own git project. Here&#39;s
a short way to do it:</p>
<p>
First, make the new repository wherever you want:</p>
<blockquote>
<pre class="example">
$ &lt;go to the new location&gt;
$ git init --bare
</pre>
</blockquote>
<p>
Back in your original directory:</p>
<blockquote>
<pre class="example">
$ git subtree split --prefix=lib --annotate=&#34;(split)&#34; -b split
</pre>
</blockquote>
<p>
Then push the new branch onto the new empty repository:</p>
<blockquote>
<pre class="example">
$ git push &lt;new-repo&gt; split:master
</pre>
</blockquote>
</div>
</div>
<div id="outline-container-headline-11" class="outline-2">
<h2 id="headline-11">
AUTHOR
</h2>
<div id="outline-text-headline-11" class="outline-text-2">
<p>Written by Avery Pennarun &lt;*apenwarr@gmail.com*[1]&gt;</p>
</div>
</div>
<div id="outline-container-headline-12" class="outline-2">
<h2 id="headline-12">
GIT
</h2>
<div id="outline-text-headline-12" class="outline-text-2">
<p>Part of the *git*(1) suite</p>
</div>
</div>
<div id="outline-container-headline-13" class="outline-2">
<h2 id="headline-13">
NOTES
</h2>
<div id="outline-text-headline-13" class="outline-text-2">
<dl>
<dt>
1.
</dt>
<dd>apenwarr@gmail.com

mailto:apenwarr@gmail.com</dd>
</dl>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.js"></script>
    </body>
</html>
