<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - zshtcpsys.1 | Technical Notes</title>

      <link rel="stylesheet" href="/css/main.min.a9ecaac9d4f7845fc2de4738f7709cab0bd1c3d19c3466fadd637a6987603257.css" integrity="sha256-qeyqydT3hF/C3kc493CcqwvRw9GcNGb63WN6aYdgMlc=" crossorigin="anonymous">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - zshtcpsys.1</h1>
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
NAME
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>zshtcpsys - zsh tcp system</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
DESCRIPTION
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p>A module <strong>zsh/net/tcp</strong> is provided to provide network I/O over TCP/IP
from within the shell; see its description in /zshmodules/(1). This
manual page describes a function suite based on the module. If the
module is installed, the functions are usually installed at the same
time, in which case they will be available for autoloading in the
default function search path. In addition to the <strong>zsh/net/tcp</strong> module,
the <strong>zsh/zselect</strong> module is used to implement timeouts on read
operations. For troubleshooting tips, consult the corresponding advice
for the <strong>zftp</strong> functions described in /zshzftpsys/(1).</p>
<p>
There are functions corresponding to the basic I/O operations open,
close, read and send, named <strong>tcp_open</strong> etc., as well as a function
<strong>tcp_expect</strong> for pattern match analysis of data read as input. The
system makes it easy to receive data from and send data to multiple
named sessions at once. In addition, it can be linked with the shell&#39;s
line editor in such a way that input data is automatically shown at the
terminal. Other facilities available including logging, filtering and
configurable output prompts.</p>
<p>
To use the system where it is available, it should be enough to
`*autoload -U tcp_open*&#39; and run <strong>tcp_open</strong> as documented below to start
a session. The <strong>tcp_open</strong> function will autoload the remaining
functions.</p>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
TCP USER FUNCTIONS
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<div id="outline-container-headline-4" class="outline-3">
<h3 id="headline-4">
Basic I/O
</h3>
<div id="outline-text-headline-4" class="outline-text-3">
<p><strong>tcp_open</strong> [ <strong>-qz</strong> ] <em>host port</em> [ <em>sess</em> ]</p>
<p>
<strong>tcp_open</strong> [ <strong>-qz</strong> ] [ <strong>-s</strong> <em>sess</em> | <strong>-l</strong> <em>sess</em>[*,*…] ] …</p>
<p>
<strong>tcp_open</strong> [ <strong>-qz</strong> ] [ <strong>-a</strong> <em>fd</em> | <strong>-f</strong> <em>fd</em> ] [ <em>sess</em> ] Open a new
session. In the first and simplest form, open a TCP connection to host
<em>host</em> at port <em>port</em>; numeric and symbolic forms are understood for
both.</p>
<blockquote>
<p>If <em>sess</em> is given, this becomes the name of the session which can be
used to refer to multiple different TCP connections. If <em>sess</em> is not
given, the function will invent a numeric name value (note this is <em>not</em>
the same as the file descriptor to which the session is attached). It is
recommended that session names not include `funny&#39; characters, where
funny characters are not well-defined but certainly do not include
alphanumerics or underscores, and certainly do include whitespace.</p>
<p>
In the second case, one or more sessions to be opened are given by name.
A single session name is given after <strong>-s</strong> and a comma-separated list
after <strong>-l</strong>; both options may be repeated as many times as necessary. A
failure to open any session causes <strong>tcp_open</strong> to abort. The host and
port are read from the file <strong>.ztcp_sessions</strong> in the same directory as
the user&#39;s zsh initialisation files, i.e. usually the home directory,
but <strong>$ZDOTDIR</strong> if that is set. The file consists of lines each giving a
session name and the corresponding host and port, in that order (note
the session name comes first, not last), separated by whitespace.</p>
<p>
The third form allows passive and fake TCP connections. If the option
<strong>-a</strong> is used, its argument is a file descriptor open for listening for
connections. No function front-end is provided to open such a file
descriptor, but a call to `*ztcp -l* <em>port</em>&#39; will create one with the
file descriptor stored in the parameter <strong>$REPLY</strong>. The listening port can
be closed with `*ztcp -c* <em>fd</em>&#39;. A call to `*tcp_open -a* <em>fd</em>&#39; will
block until a remote TCP connection is made to <em>port</em> on the local
machine. At this point, a session is created in the usual way and is
largely indistinguishable from an active connection created with one of
the first two forms.</p>
<p>
If the option <strong>-f</strong> is used, its argument is a file descriptor which is
used directly as if it were a TCP session. How well the remainder of the
TCP function system copes with this depends on what actually underlies
this file descriptor. A regular file is likely to be unusable; a FIFO
(pipe) of some sort will work better, but note that it is not a good
idea for two different sessions to attempt to read from the same FIFO at
once.</p>
<p>
If the option <strong>-q</strong> is given with any of the three forms, <strong>tcp_open</strong> will
not print informational messages, although it will in any case exit with
an appropriate status.</p>
<p>
If the line editor (zle) is in use, which is typically the case if the
shell is interactive, <strong>tcp_open</strong> installs a handler inside zle which
will check for new data at the same time as it checks for keyboard
input. This is convenient as the shell consumes no CPU time while
waiting; the test is performed by the operating system. Giving the
option <strong>-z</strong> to any of the forms of <strong>tcp_open</strong> prevents the handler from
being installed, so data must be read explicitly. Note, however, this is
not necessary for executing complete sets of send and read commands from
a function, as zle is not active at this point. Generally speaking, the
handler is only active when the shell is waiting for input at a command
prompt or in the <strong>vared</strong> builtin. The option has no effect if zle is not
active; `*<a href=" -o zle"> -o zle</a>*&#39; will test for this.</p>
<p>
The first session to be opened becomes the current session and
subsequent calls to <strong>tcp_open</strong> do not change it. The current session is
stored in the parameter <strong>$TCP_SESS</strong>; see below for more detail about the
parameters used by the system.</p>
<p>
The function <strong>tcp_on_open</strong>, if defined, is called when a session is
opened. See the description below.</p>
</blockquote>
<ul>
<li><strong>tcp_close</strong> [ <strong>-qn</strong> ] [ <strong>-a</strong> | <strong>-l</strong> <em>sess</em>[*,*…] | <em>sess</em> …
] :: Close the named sessions, or the current session if none is
given, or all open sessions if <strong>-a</strong> is given. The options <strong>-l</strong> and
<strong>-s</strong> are both handled for consistency with <strong>tcp_open</strong>, although the
latter is redundant.

If the session being closed is the current one, <strong>$TCP_SESS</strong> is unset,
leaving no current session, even if there are other sessions still
open.

If the session was opened with <strong>tcp_open -f</strong>, the file descriptor is
closed so long as it is in the range 0 to 9 accessible directly from
the command line. If the option <strong>-n</strong> is given, no attempt will be made
to close file descriptors in this case. The <strong>-n</strong> option is not used
for genuine <strong>ztcp</strong> session; the file descriptors are always closed
with the session.

If the option <strong>-q</strong> is given, no informational messages will be
printed.</li>
</ul>
<p><strong>tcp_read *[ *-bdq</strong> ] [ <strong>-t</strong> <em>TO</em> ] [ <strong>-T</strong> <em>TO</em> ]</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-5" class="outline-2">
<h2 id="headline-5">
<strong>[ *-a</strong> | <strong>-u</strong> <em>fd</em>[*,*…] | <strong>-l</strong> <em>sess</em>[*,*…] | <strong>-s</strong> <em>sess</em> … ]
</h2>
<div id="outline-text-headline-5" class="outline-text-2">
<p>Perform a read operation on the current session, or on a list of
sessions if any are given with <strong>-u</strong>, <strong>-l</strong> or <strong>-s</strong>, or all open sessions
if the option <strong>-a</strong> is given. Any of the <strong>-u</strong>, <strong>-l</strong> or <strong>-s</strong> options may
be repeated or mixed together. The <strong>-u</strong> option specifies a file
descriptor directly (only those managed by this system are useful), the
other two specify sessions as described for <strong>tcp_open</strong> above.</p>
<blockquote>
<p>The function checks for new data available on all the sessions listed.
Unless the <strong>-b</strong> option is given, it will not block waiting for new data.
Any one line of data from any of the available sessions will be read,
stored in the parameter <strong>$TCP_LINE</strong>, and displayed to standard output
unless <strong>$TCP_SILENT</strong> contains a non-empty string. When printed to
standard output the string <strong>$TCP_PROMPT</strong> will be shown at the start of
the line; the default form for this includes the name of the session
being read. See below for more information on these parameters. In this
mode, <strong>tcp_read</strong> can be called repeatedly until it returns status 2
which indicates all pending input from all specified sessions has been
handled.</p>
<p>
With the option <strong>-b</strong>, equivalent to an infinite timeout, the function
will block until a line is available to read from one of the specified
sessions. However, only a single line is returned.</p>
<p>
The option <strong>-d</strong> indicates that all pending input should be drained. In
this case <strong>tcp_read</strong> may process multiple lines in the manner given
above; only the last is stored in <strong>$TCP_LINE</strong>, but the complete set is
stored in the array <strong>$tcp_lines</strong>. This is cleared at the start of each
call to <strong>tcp_read</strong>.</p>
<p>
The options <strong>-t</strong> and <strong>-T</strong> specify a timeout in seconds, which may be a
floating point number for increased accuracy. With <strong>-t</strong> the timeout is
applied before each line read. With <strong>-T</strong>, the timeout applies to the
overall operation, possibly including multiple read operations if the
option <strong>-d</strong> is present; without this option, there is no distinction
between <strong>-t</strong> and <strong>-T</strong>.</p>
<p>
The function does not print informational messages, but if the option
<strong>-q</strong> is given, no error message is printed for a non-existent session.</p>
<p>
A return status of 2 indicates a timeout or no data to read. Any other
non-zero return status indicates some error condition.</p>
<p>
See <strong>tcp_log</strong> for how to control where data is sent by <strong>tcp_read</strong>.</p>
</blockquote>
<p>
<strong>tcp_send</strong> [ <strong>-cnq</strong> ] [ <strong>-s</strong> <em>sess</em> | <strong>-l</strong> <em>sess</em>[*,*…] ] <em>data</em> …</p>
<p>
<strong>tcp_send</strong> [ <strong>-cnq</strong> ] <strong>-a</strong> <em>data</em> … Send the supplied data strings to
all the specified sessions in turn. The underlying operation differs
little from a `*print -r*&#39; to the session&#39;s file descriptor, although it
attempts to prevent the shell from dying owing to a <strong>SIGPIPE</strong> caused by
an attempt to write to a defunct session.</p>
<blockquote>
<p>The option <strong>-c</strong> causes <strong>tcp_send</strong> to behave like <strong>cat</strong>. It reads lines
from standard input until end of input and sends them in turn to the
specified session(s) exactly as if they were given as <em>data</em> arguments
to individual <strong>tcp_send</strong> commands.</p>
<p>
The option <strong>-n</strong> prevents <strong>tcp_send</strong> from putting a newline at the end of
the data strings.</p>
<p>
The remaining options all behave as for <strong>tcp_read</strong>.</p>
<p>
The data arguments are not further processed once they have been passed
to <strong>tcp_send</strong>; they are simply passed down to <strong>print -r</strong>.</p>
<p>
If the parameter <strong>$TCP_OUTPUT</strong> is a non-empty string and logging is
enabled then the data sent to each session will be echoed to the log
file(s) with <strong>$TCP_OUTPUT</strong> in front where appropriate, much in the
manner of <strong>$TCP_PROMPT</strong>.</p>
</blockquote>
<div id="outline-container-headline-6" class="outline-3">
<h3 id="headline-6">
Session Management
</h3>
<div id="outline-text-headline-6" class="outline-text-3">
<p><strong>tcp_alias</strong> [ <strong>-q</strong> ] <em>alias/*=*/sess</em> …</p>
<p>
<strong>tcp_alias</strong> [ <strong>-q</strong> ] [ <em>alias</em> … ]</p>
<p>
<strong>tcp_alias</strong> <strong>-d</strong> [ <strong>-q</strong> ] <em>alias</em> … This function is not particularly
well tested.</p>
<blockquote>
<p>The first form creates an alias for a session name; <em>alias</em> can then be
used to refer to the existing session <em>sess</em>. As many aliases may be
listed as required.</p>
<p>
The second form lists any aliases specified, or all aliases if none.</p>
<p>
The third form deletes all the aliases listed. The underlying sessions
are not affected.</p>
<p>
The option <strong>-q</strong> suppresses an inconsistently chosen subset of error
messages.</p>
</blockquote>
<dl>
<dt>
<strong>tcp_log</strong> [ <strong>-asc</strong> ] [ <strong>-n</strong> | <strong>-N</strong> ] [ <em>logfile</em> ]
</dt>
<dd>With an argument
<em>logfile</em>, all future input from <strong>tcp_read</strong> will be logged to the
named file. Unless <strong>-a</strong> (append) is given, this file will first be
truncated or created empty. With no arguments, show the current status
of logging.

With the option <strong>-s</strong>, per-session logging is enabled. Input from
<strong>tcp_read</strong> is output to the file <em>logfile/*.*/sess</em>. As the session is
automatically discriminated by the filename, the contents are raw (no
<strong>$TCP_PROMPT</strong>). The option <strong>-a</strong> applies as above. Per-session logging
and logging of all data in one file are not mutually exclusive.

The option <strong>-c</strong> closes all logging, both complete and per-session
logs.

The options <strong>-n</strong> and <strong>-N</strong> respectively turn off or restore output of
data read by <strong>tcp_read</strong> to standard output; hence `*tcp_log -cn*&#39;
turns off all output by <strong>tcp_read</strong>.

The function is purely a convenient front end to setting the
parameters <strong>$TCP_LOG</strong>, <strong>$TCP_LOG_SESS</strong>, <strong>$TCP_SILENT</strong>, which are
described below.</dd>
<dt>
<strong>tcp_rename</strong> <em>old</em> <em>new</em>
</dt>
<dd>Rename session <em>old</em> to session <em>new</em>. The
old name becomes invalid.</dd>
<dt>
<strong>tcp_sess</strong> [ <em>sess</em> [ <em>command</em> [ <em>arg</em> … ] ] ]
</dt>
<dd>With no
arguments, list all the open sessions and associated file descriptors.
The current session is marked with a star. For use in functions,
direct access to the parameters <strong>$tcp_by_name</strong>, <strong>$tcp_by_fd</strong> and
<strong>$TCP_SESS</strong> is probably more convenient; see below.

With a <em>sess</em> argument, set the current session to <em>sess</em>. This is
equivalent to changing <strong>$TCP_SESS</strong> directly.

With additional arguments, temporarily set the current session while
executing `/command/ <em>arg</em> …&#39;. <em>command</em> is re-evaluated so as to
expand aliases etc., but the remaining /arg/s are passed through as
that appear to <strong>tcp_sess</strong>. The original session is restored when
<strong>tcp_sess</strong> exits.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-7" class="outline-3">
<h3 id="headline-7">
Advanced I/O
</h3>
<div id="outline-text-headline-7" class="outline-text-3">
<p><strong>tcp_command</strong> <em>send-option</em> … <em>send-argument</em> … This is a convenient
front-end to <strong>tcp_send</strong>. All arguments are passed to <strong>tcp_send</strong>, then
the function pauses waiting for data. While data is arriving at least
every <strong>$TCP_TIMEOUT</strong> (default 0.3) seconds, data is handled and printed
out according to the current settings. Status 0 is always returned.</p>
<blockquote>
<p>This is generally only useful for interactive use, to prevent the
display becoming fragmented by output returned from the connection.
Within a programme or function it is generally better to handle reading
data by a more explicit method.</p>
</blockquote>
<p>
<strong>tcp_expect *[ *-q</strong> ] [ <strong>-p</strong> <em>var</em> | <strong>-P</strong> <em>var</em> ] [ <strong>-t</strong> <em>TO</em> | <strong>-T</strong>
<em>TO</em> ]</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-8" class="outline-2">
<h2 id="headline-8">
<strong>[ *-a</strong> | <strong>-s</strong> <em>sess</em> | <strong>-l</strong> <em>sess</em>[*,*…] ] <em>pattern</em> … Wait for
</h2>
<div id="outline-text-headline-8" class="outline-text-2">
<p>input matching any of the given /pattern/s from any of the specified
sessions. Input is ignored until an input line matches one of the given
patterns; at this point status zero is returned, the matching line is
stored in <strong>$TCP_LINE</strong>, and the full set of lines read during the call to
<strong>tcp_expect</strong> is stored in the array <strong>$tcp_expect_lines</strong>.</p>
<blockquote>
<p>Sessions are specified in the same way as <strong>tcp_read</strong>: the default is to
use the current session, otherwise the sessions specified by <strong>-a</strong>, <strong>-s</strong>,
or <strong>-l</strong> are used.</p>
<p>
Each <em>pattern</em> is a standard zsh extended-globbing pattern; note that it
needs to be quoted to avoid it being expanded immediately by filename
generation. It must match the full line, so to match a substring there
must be a `***&#39; at the start and end. The line matched against includes
the <strong>$TCP_PROMPT</strong> added by <strong>tcp_read</strong>. It is possible to include the
globbing flags `*#b*&#39; or `*#m*&#39; in the patterns to make backreferences
available in the parameters <strong>$MATCH</strong>, <strong>$match</strong>, etc., as described in
the base zsh documentation on pattern matching.</p>
<p>
Unlike <strong>tcp_read</strong>, the default behaviour of <strong>tcp_expect</strong> is to block
indefinitely until the required input is found. This can be modified by
specifying a timeout with <strong>-t</strong> or <strong>-T</strong>; these function as in <strong>tcp_read</strong>,
specifying a per-read or overall timeout, respectively, in seconds, as
an integer or floating-point number. As <strong>tcp_read</strong>, the function returns
status 2 if a timeout occurs.</p>
<p>
The function returns as soon as any one of the patterns given match. If
the caller needs to know which of the patterns matched, the option <strong>-p</strong>
<em>var</em> can be used; on return, <strong>$var</strong> is set to the number of the pattern
using ordinary zsh indexing, i.e. the first is 1, and so on. Note the
absence of a `*$*&#39; in front of <em>var</em>. To avoid clashes, the parameter
cannot begin with `*_expect*&#39;. The index -1 is used if there is a
timeout and 0 if there is no match.</p>
<p>
The option <strong>-P</strong> <em>var</em> works similarly to <strong>-p</strong>, but instead of numerical
indexes the regular arguments must begin with a prefix followed by a
colon: that prefix is then used as a tag to which <em>var</em> is set when the
argument matches. The tag <strong>timeout</strong> is used if there is a timeout and
the empty string if there is no match. Note it is acceptable for
different arguments to start with the same prefix if the matches do not
need to be distinguished.</p>
<p>
The option <strong>-q</strong> is passed directly down to <strong>tcp_read</strong>.</p>
<p>
As all input is done via <strong>tcp_read</strong>, all the usual rules about output of
lines read apply. One exception is that the parameter <strong>$tcp_lines</strong> will
only reflect the line actually matched by <strong>tcp_expect</strong>; use
<strong>$tcp_expect_lines</strong> for the full set of lines read during the function
call.</p>
</blockquote>
<dl>
<dt>
<strong>tcp_proxy</strong>
</dt>
<dd>This is a simple-minded function to accept a TCP
connection and execute a command with I/O redirected to the
connection. Extreme caution should be taken as there is no security
whatsoever and this can leave your computer open to the world.
Ideally, it should only be used behind a firewall.

The first argument is a TCP port on which the function will listen.

The remaining arguments give a command and its arguments to execute
with standard input, standard output and standard error redirected to
the file descriptor on which the TCP session has been accepted. If no
command is given, a new zsh is started. This gives everyone on your
network direct access to your account, which in many cases will be a
bad thing.

The command is run in the background, so <strong>tcp_proxy</strong> can then accept
new connections. It continues to accept new connections until
interrupted.</dd>
<dt>
?
</dt>
<dd><strong>tcp_spam</strong> [ <strong>-ertv</strong> ] [ <strong>-a</strong> | <strong>-s</strong> <em>sess</em> | <strong>-l</strong> <em>sess</em>[*,*…] ]
<em>cmd</em> [ <em>arg</em> … ] :: Execute `/cmd/ [ <em>arg</em> … ]&#39; for each session
in turn. Note this executes the command and arguments; it does not
send the command line as data unless the <strong>-t</strong> (transmit) option is
given.

The sessions may be selected explicitly with the standard <strong>-a</strong>, <strong>-s</strong>
or <strong>-l</strong> options, or may be chosen implicitly. If none of the three
options is given the rules are: first, if the array <strong>$tcp_spam_list</strong>
is set, this is taken as the list of sessions, otherwise all sessions
are taken. Second, any sessions given in the array <strong>$tcp_no_spam_list</strong>
are removed from the list of sessions.

Normally, any sessions added by the `*-a*&#39; flag or when all sessions
are chosen implicitly are spammed in alphabetic order; sessions given
by the <strong>$tcp_spam_list</strong> array or on the command line are spammed in
the order given. The <strong>-r</strong> flag reverses the order however it was
arrived it.

The <strong>-v</strong> flag specifies that a <strong>$TCP_PROMPT</strong> will be output before
each session. This is output after any modification to <strong>TCP_SESS</strong> by
the user-defined <strong>tcp_on_spam</strong> function described below. (Obviously
that function is able to generate its own output.)

If the option <strong>-e</strong> is present, the line given as `/cmd/ [ <em>arg</em> … ]&#39;
is executed using <strong>eval</strong>, otherwise it is executed without any further
processing.</dd>
<dt>
<strong>tcp_talk</strong>
</dt>
<dd>This is a fairly simple-minded attempt to force input to
the line editor to go straight to the default <strong>TCP_SESS</strong>.

An escape string, <strong>$TCP_TALK_ESCAPE</strong>, default `*:*&#39;, is used to allow
access to normal shell operation. If it is on its own at the start of
the line, or followed only by whitespace, the line editor returns to
normal operation. Otherwise, the string and any following whitespace
are skipped and the remainder of the line executed as shell input
without any change of the line editor&#39;s operating mode.

The current implementation is somewhat deficient in terms of use of
the command history. For this reason, many users will prefer to use
some form of alternative approach for sending data easily to the
current session. One simple approach is to alias some special
character (such as `*%*&#39;) to `*tcp_command –*&#39;.</dd>
<dt>
<strong>tcp_wait</strong>
</dt>
<dd>The sole argument is an integer or floating point number
which gives the seconds to delay. The shell will do nothing for that
period except wait for input on all TCP sessions by calling <strong>tcp_read
-a</strong>. This is similar to the interactive behaviour at the command
prompt when zle handlers are installed.</dd>
</dl>
<div id="outline-container-headline-9" class="outline-3">
<h3 id="headline-9">
`One-shot&#39; file transfer
</h3>
<div id="outline-text-headline-9" class="outline-text-3">
<p><strong>tcp_point</strong> <em>port</em></p>
<p>
<strong>tcp_shoot</strong> <em>host</em> <em>port</em> This pair of functions provide a simple way to
transfer a file between two hosts within the shell. Note, however, that
bulk data transfer is currently done using <strong>cat</strong>. <strong>tcp_point</strong> reads any
data arriving at <em>port</em> and sends it to standard output; <strong>tcp_shoot</strong>
connects to <em>port</em> on <em>host</em> and sends its standard input. Any unused
<em>port</em> may be used; the standard mechanism for picking a port is to
think of a random four-digit number above 1024 until one works.</p>
<blockquote>
<p>To transfer a file from host <strong>woodcock</strong> to host <strong>springes</strong>, on
<strong>springes</strong>:</p>
<blockquote>
<pre class="example">
tcp_point 8091 &gt;output_file
</pre>
</blockquote>
<p>
and on <strong>woodcock</strong>:</p>
<blockquote>
<pre class="example">
tcp_shoot springes 8091 &lt;input_file
</pre>
</blockquote>
<p>
As these two functions do not require <strong>tcp_open</strong> to set up a TCP
connection first, they may need to be autoloaded separately.</p>
</blockquote>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-10" class="outline-2">
<h2 id="headline-10">
TCP USER-DEFINED FUNCTIONS
</h2>
<div id="outline-text-headline-10" class="outline-text-2">
<p>Certain functions, if defined by the user, will be called by the
function system in certain contexts. This facility depends on the module
<strong>zsh/parameter</strong>, which is usually available in interactive shells as the
completion system depends on it. None of the functions need be defined;
they simply provide convenient hooks when necessary.</p>
<p>
Typically, these are called after the requested action has been taken,
so that the various parameters will reflect the new state.</p>
<p>
<strong>tcp_on_alias</strong> <em>alias</em> <em>fd</em> When an alias is defined, this function will
be called with two arguments: the name of the alias, and the file
descriptor of the corresponding session.</p>
<dl>
<dt>
<strong>tcp_on_awol</strong> <em>sess</em> <em>fd</em>
</dt>
<dd>If the function <strong>tcp_fd_handler</strong> is
handling input from the line editor and detects that the file
descriptor is no longer reusable, by default it removes it from the
list of file descriptors handled by this method and prints a message.
If the function <strong>tcp_on_awol</strong> is defined it is called immediately
before this point. It may return status 100, which indicates that the
normal handling should still be performed; any other return status
indicates that no further action should be taken and the
<strong>tcp_fd_handler</strong> should return immediately with the given status.
Typically the action of <strong>tcp_on_awol</strong> will be to close the session.

The variable <strong>TCP_INVALIDATE_ZLE</strong> will be a non-empty string if it is
necessary to invalidate the line editor display using `*zle -I*&#39;
before printing output from the function.

(`AWOL&#39; is military jargon for `absent without leave&#39; or some
variation. It has no pre-existing technical meaning known to the
author.)</dd>
<dt>
<strong>tcp_on_close</strong> <em>sess</em> <em>fd</em>
</dt>
<dd>This is called with the name of a
session being closed and the file descriptor which corresponded to
that session. Both will be invalid by the time the function is called.</dd>
<dt>
<strong>tcp_on_open</strong> <em>sess</em> <em>fd</em>
</dt>
<dd>This is called after a new session has
been defined with the session name and file descriptor as arguments.
If it returns a non-zero status, opening the session is assumed to
fail and the session is closed again; however, <strong>tcp_open</strong> will
continue to attempt to open any remaining sessions given on the
command line.</dd>
<dt>
<strong>tcp_on_rename</strong> <em>oldsess</em> <em>fd</em> <em>newsess</em>
</dt>
<dd>This is called after a
session has been renamed with the three arguments old session name,
file descriptor, new session name.</dd>
<dt>
<strong>tcp_on_spam</strong> <em>sess</em> <em>command …</em>
</dt>
<dd>This is called once for each
session spammed, just <em>before</em> a command is executed for a session by
<strong>tcp_spam</strong>. The arguments are the session name followed by the command
list to be executed. If <strong>tcp_spam</strong> was called with the option <strong>-t</strong>,
the first command will be <strong>tcp_send</strong>.

This function is called after <strong>$TCP_SESS</strong> is set to reflect the
session to be spammed, but before any use of it is made. Hence it is
possible to alter the value of <strong>$TCP_SESS</strong> within this function. For
example, the session arguments to <strong>tcp_spam</strong> could include extra
information to be stripped off and processed in <strong>tcp_on_spam</strong>.

If the function sets the parameter <strong>$REPLY</strong> to `*done*&#39;, the command
line is not executed; in addition, no prompt is printed for the <strong>-v</strong>
option to <strong>tcp_spam</strong>.</dd>
<dt>
<strong>tcp_on_unalias</strong> <em>alias</em> <em>fd</em>
</dt>
<dd>This is called with the name of an
alias and the corresponding session&#39;s file descriptor after an alias
has been deleted.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-11" class="outline-2">
<h2 id="headline-11">
TCP UTILITY FUNCTIONS
</h2>
<div id="outline-text-headline-11" class="outline-text-2">
<p>The following functions are used by the TCP function system but will
rarely if ever need to be called directly.</p>
<p>
<strong>tcp_fd_handler</strong> This is the function installed by <strong>tcp_open</strong> for
handling input from within the line editor, if that is required. It is
in the format documented for the builtin `*zle -F*&#39; in /zshzle/(1) .</p>
<blockquote>
<p>While active, the function sets the parameter <strong>TCP_HANDLER_ACTIVE</strong> to 1.
This allows shell code called internally (for example, by setting
<strong>tcp_on_read</strong>) to tell if is being called when the shell is otherwise
idle at the editor prompt.</p>
</blockquote>
<dl>
<dt>
<strong>tcp_output</strong> [ <strong>-q</strong> ] <strong>-P</strong> <em>prompt</em> <strong>-F</strong> <em>fd</em> <strong>-S</strong> <em>sess</em>
</dt>
<dd>
<p>This
function is used for both logging and handling output to standard
output, from within <strong>tcp_read</strong> and (if <strong>$TCP_OUTPUT</strong> is set)
<strong>tcp_send</strong>.</p>
<p>
The <em>prompt</em> to use is specified by <strong>-P</strong>; the default is the empty
string. It can contain:</p>
<p>
<strong>%c</strong> Expands to 1 if the session is the current session, otherwise 0.
Used with ternary expressions such as `*%(c.-.+)*&#39; to output `*+*&#39; for
the current session and `*-*&#39; otherwise.</p>
<dl>
<dt>
<strong>%f</strong>
</dt>
<dd>Replaced by the session&#39;s file descriptor.</dd>
<dt>
<strong>%s</strong>
</dt>
<dd>Replaced by the session name.</dd>
<dt>
<strong>%%</strong>
</dt>
<dd>Replaced by a single `*%*&#39;.</dd>
</dl>
<p>The option <strong>-q</strong> suppresses output to standard output, but not to any
log files which are configured.</p>
<p>
The <strong>-S</strong> and <strong>-F</strong> options are used to pass in the session name and
file descriptor for possible replacement in the prompt.</p>
</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-12" class="outline-2">
<h2 id="headline-12">
TCP USER PARAMETERS
</h2>
<div id="outline-text-headline-12" class="outline-text-2">
<p>Parameters follow the usual convention that uppercase is used for
scalars and integers, while lowercase is used for normal and associative
array. It is always safe for user code to read these parameters. Some
parameters may also be set; these are noted explicitly. Others are
included in this group as they are set by the function system for the
user&#39;s benefit, i.e. setting them is typically not useful but is benign.</p>
<p>
It is often also useful to make settable parameters local to a function.
For example, `*local TCP_SILENT=1*&#39; specifies that data read during the
function call will not be printed to standard output, regardless of the
setting outside the function. Likewise, `*local TCP_SESS=*/sess/&#39; sets a
session for the duration of a function, and `*local* TCP_PROMPT=&#39;
specifies that no prompt is used for input during the function.</p>
<p>
<strong>tcp_expect_lines</strong> Array. The set of lines read during the last call to
<strong>tcp_expect</strong>, including the last (<strong>$TCP_LINE</strong>).</p>
<dl>
<dt>
<strong>tcp_filter</strong>
</dt>
<dd>Array. May be set directly. A set of extended globbing
patterns which, if matched in <strong>tcp_output</strong>, will cause the line not to
be printed to standard output. The patterns should be defined as
described for the arguments to <strong>tcp_expect</strong>. Output of line to log
files is not affected.</dd>
<dt>
<strong>TCP_HANDLER_ACTIVE</strong>
</dt>
<dd>Scalar. Set to 1 within <strong>tcp_fd_handler</strong> to
indicate to functions called recursively that they have been called
during an editor session. Otherwise unset.</dd>
<dt>
<strong>TCP_LINE</strong>
</dt>
<dd>The last line read by <strong>tcp_read</strong>, and hence also
<strong>tcp_expect</strong>.</dd>
<dt>
<strong>TCP_LINE_FD</strong>
</dt>
<dd>The file descriptor from which <strong>$TCP_LINE</strong> was read.
<strong>${tcp_by_fd[$TCP_LINE_FD]}</strong> will give the corresponding session name.</dd>
<dt>
<strong>tcp_lines</strong>
</dt>
<dd>Array. The set of lines read during the last call to
<strong>tcp_read</strong>, including the last (<strong>$TCP_LINE</strong>).</dd>
<dt>
<strong>TCP_LOG</strong>
</dt>
<dd>May be set directly, although it is also controlled by
<strong>tcp_log</strong>. The name of a file to which output from all sessions will
be sent. The output is proceeded by the usual <strong>$TCP_PROMPT</strong>. If it is
not an absolute path name, it will follow the user&#39;s current
directory.</dd>
<dt>
<strong>TCP_LOG_SESS</strong>
</dt>
<dd>May be set directly, although it is also controlled
by <strong>tcp_log</strong>. The prefix for a set of files to which output from each
session separately will be sent; the full filename is
*${TCP_LOG_SESS}.*/sess/. Output to each file is raw; no prompt is
added. If it is not an absolute path name, it will follow the user&#39;s
current directory.</dd>
<dt>
<strong>tcp_no_spam_list</strong>
</dt>
<dd>Array. May be set directly. See <strong>tcp_spam</strong> for
how this is used.</dd>
<dt>
<strong>TCP_OUTPUT</strong>
</dt>
<dd>May be set directly. If a non-empty string, any data
sent to a session by <strong>tcp_send</strong> will be logged. This parameter gives
the prompt to be used in a file specified by <strong>$TCP_LOG</strong> but not in a
file generated from <strong>$TCP_LOG_SESS</strong>. The prompt string has the same
format as <strong>TCP_PROMPT</strong> and the same rules for its use apply.</dd>
<dt>
<strong>TCP_PROMPT</strong>
</dt>
<dd>May be set directly. Used as the prefix for data read
by <strong>tcp_read</strong> which is printed to standard output or to the log file
given by <strong>$TCP_LOG</strong>, if any. Any `*%s*&#39;, `*%f*&#39; or `*%%*&#39; occurring in
the string will be replaced by the name of the session, the session&#39;s
underlying file descriptor, or a single `*%*&#39;, respectively. The
expression `*%c*&#39; expands to 1 if the session being read is the
current session, else 0; this is most useful in ternary expressions
such as `*%(c.-.+)*&#39; which outputs `*+*&#39; if the session is the current
one, else `*-*&#39;.

If the prompt starts with <strong>%P</strong>, this is stripped and the complete
result of the previous stage is passed through standard prompt
<strong>%</strong>-style formatting before being output.</dd>
<dt>
<strong>TCP_READ_DEBUG</strong>
</dt>
<dd>May be set directly. If this has non-zero length,
<strong>tcp_read</strong> will give some limited diagnostics about data being read.</dd>
<dt>
<strong>TCP_SECONDS_START</strong>
</dt>
<dd>This value is created and initialised to zero
by tcp_open.

The functions <strong>tcp_read</strong> and <strong>tcp_expect</strong> use the shell&#39;s <strong>SECONDS</strong>
parameter for their own timing purposes. If that parameter is not of
floating point type on entry to one of the functions, it will create a
local parameter <strong>SECONDS</strong> which is floating point and set the
parameter <strong>TCP_SECONDS_START</strong> to the previous value of <strong>$SECONDS</strong>. If
the parameter is already floating point, it is used without a local
copy being created and <strong>TCP_SECONDS_START</strong> is not set. As the global
value is zero, the shell elapsed time is guaranteed to be the sum of
<strong>$SECONDS</strong> and <strong>$TCP_SECONDS_START</strong>.

This can be avoided by setting <strong>SECONDS</strong> globally to a floating point
value using `*typeset -F SECONDS*&#39;; then the TCP functions will never
make a local copy and never set <strong>TCP_SECONDS_START</strong> to a non-zero
value.</dd>
<dt>
<strong>TCP_SESS</strong>
</dt>
<dd>May be set directly. The current session; must refer to
one of the sessions established by <strong>tcp_open</strong>.</dd>
<dt>
<strong>TCP_SILENT</strong>
</dt>
<dd>May be set directly, although it is also controlled by
<strong>tcp_log</strong>. If of non-zero length, data read by <strong>tcp_read</strong> will not be
written to standard output, though may still be written to a log file.</dd>
<dt>
<strong>tcp_spam_list</strong>
</dt>
<dd>Array. May be set directly. See the description of
the function <strong>tcp_spam</strong> for how this is used.</dd>
<dt>
<strong>TCP_TALK_ESCAPE</strong>
</dt>
<dd>May be set directly. See the description of the
function <strong>tcp_talk</strong> for how this is used.</dd>
<dt>
<strong>TCP_TIMEOUT</strong>
</dt>
<dd>May be set directly. Currently this is only used by
the function <strong>tcp_command</strong>, see above.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-13" class="outline-2">
<h2 id="headline-13">
TCP USER-DEFINED PARAMETERS
</h2>
<div id="outline-text-headline-13" class="outline-text-2">
<p>The following parameters are not set by the function system, but have a
special effect if set by the user.</p>
<p>
<strong>tcp_on_read</strong> This should be an associative array; if it is not, the
behaviour is undefined. Each key is the name of a shell function or
other command, and the corresponding value is a shell pattern (using
<strong>EXTENDED_GLOB</strong>). Every line read from a TCP session directly or
indirectly using <strong>tcp_read</strong> (which includes lines read by <strong>tcp_expect</strong>)
is compared against the pattern. If the line matches, the command given
in the key is called with two arguments: the name of the session from
which the line was read, and the line itself.</p>
<blockquote>
<p>If any function called to handle a line returns a non-zero status, the
line is not output. Thus a <strong>tcp_on_read</strong> handler containing only the
instruction `*return 1*&#39; can be used to suppress output of particular
lines (see, however, <strong>tcp_filter</strong> above). However, the line is still
stored in <strong>TCP_LINE</strong> and <strong>tcp_lines</strong>; this occurs after all
<strong>tcp_on_read</strong> processing.</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-14" class="outline-2">
<h2 id="headline-14">
TCP UTILITY PARAMETERS
</h2>
<div id="outline-text-headline-14" class="outline-text-2">
<p>These parameters are controlled by the function system; they may be read
directly, but should not usually be set by user code.</p>
<p>
<strong>tcp_aliases</strong> Associative array. The keys are the names of sessions
established with <strong>tcp_open</strong>; each value is a space-separated list of
aliases which refer to that session.</p>
<dl>
<dt>
<strong>tcp_by_fd</strong>
</dt>
<dd>Associative array. The keys are session file
descriptors; each value is the name of that session.</dd>
<dt>
<strong>tcp_by_name</strong>
</dt>
<dd>Associative array. The keys are the names of
sessions; each value is the file descriptor associated with that
session.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-15" class="outline-2">
<h2 id="headline-15">
TCP EXAMPLES
</h2>
<div id="outline-text-headline-15" class="outline-text-2">
<p>Here is a trivial example using a remote calculator.</p>
<p>
To create a calculator server on port 7337 (see the <strong>dc</strong> manual page for
quite how infuriating the underlying command is):</p>
<blockquote>
<pre class="example">
tcp_proxy 7337 dc
</pre>
</blockquote>
<p>
To connect to this from the same host with a session also named `*dc*&#39;:</p>
<blockquote>
<pre class="example">
tcp_open localhost 7337 dc
</pre>
</blockquote>
<p>
To send a command to the remote session and wait a short while for
output (assuming <strong>dc</strong> is the current session):</p>
<blockquote>
<pre class="example">
tcp_command 2 4 + p
</pre>
</blockquote>
<p>
To close the session:</p>
<blockquote>
<pre class="example">
tcp_close
</pre>
</blockquote>
<p>
The <strong>tcp_proxy</strong> needs to be killed to be stopped. Note this will not
usually kill any connections which have already been accepted, and also
that the port is not immediately available for reuse.</p>
<p>
The following chunk of code puts a list of sessions into an xterm
header, with the current session followed by a star.</p>
<blockquote>
<pre class="example">
print -n &#34;\033]2;TCP:&#34; ${(k)tcp_by_name:/$TCP_SESS/$TCP_SESS\*} &#34;\a&#34;
</pre>
</blockquote>
</div>
</div>
<div id="outline-container-headline-16" class="outline-2">
<h2 id="headline-16">
TCP BUGS
</h2>
<div id="outline-text-headline-16" class="outline-text-2">
<p>The function <strong>tcp_read</strong> uses the shell&#39;s normal <strong>read</strong> builtin. As this
reads a complete line at once, data arriving without a terminating
newline can cause the function to block indefinitely.</p>
<p>
Though the function suite works well for interactive use and for data
arriving in small amounts, the performance when large amounts of data
are being exchanged is likely to be extremely poor.</p>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.95916b5b8c09add4922ea47e674b5da7fc4b6347a3e8c4e25e98b4b7d236080b.js" integrity="sha256-lZFrW4wJrdSSLqR&#43;Z0tdp/xLY0ej6MTiXpi0t9I2CAs=" crossorigin="anonymous"></script>
    </body>
</html>
