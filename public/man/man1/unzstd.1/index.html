<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - unzstd.1 | Technical Notes</title>

      <link rel="stylesheet" href="/css/main.min.a9ecaac9d4f7845fc2de4738f7709cab0bd1c3d19c3466fadd637a6987603257.css" integrity="sha256-qeyqydT3hF/C3kc493CcqwvRw9GcNGb63WN6aYdgMlc=" crossorigin="anonymous">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - unzstd.1</h1>
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
NAME
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p><strong>zstd</strong> - zstd, zstdmt, unzstd, zstdcat - Compress or decompress .zst
files</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
SYNOPSIS
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p><strong>zstd</strong> [/OPTIONS/] [-|/INPUT-FILE/] [-o /OUTPUT-FILE/]</p>
<p>
<strong>zstdmt</strong> is equivalent to <strong>zstd -T0</strong></p>
<p>
<strong>unzstd</strong> is equivalent to <strong>zstd -d</strong></p>
<p>
<strong>zstdcat</strong> is equivalent to <strong>zstd -dcf</strong></p>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
DESCRIPTION
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p><strong>zstd</strong> is a fast lossless compression algorithm and data compression
tool, with command line syntax similar to <strong>gzip*(1) and *xz*(1). It is
based on the *LZ77</strong> family, with further FSE &amp; huff0 entropy stages.
<strong>zstd</strong> offers highly configurable compression speed, from fast modes at
&gt; 200 MB/s per core, to strong modes with excellent compression ratios.
It also features a very fast decoder, with speeds &gt; 500 MB/s per core,
which remains roughly stable at all compression settings.</p>
<p>
<strong>zstd</strong> command line syntax is generally similar to gzip, but features
the following few differences:</p>
<ul>
<li>Source files are preserved by default. It&#39;s possible to remove them
automatically by using the <strong>–rm</strong> command.</li>
<li>When compressing a single file, <strong>zstd</strong> displays progress notifications
and result summary by default. Use <strong>-q</strong> to turn them off.</li>
<li><strong>zstd</strong> displays a short help page when command line is an error. Use
<strong>-q</strong> to turn it off.</li>
<li><strong>zstd</strong> does not accept input from console, though it does accept
<strong>stdin</strong> when it&#39;s not the console.</li>
<li><strong>zstd</strong> does not store the input&#39;s filename or attributes, only its
contents.</li>
<li>:: </li>
</ul>
<p><strong>zstd</strong> processes each <em>file</em> according to the selected operation mode.
If no <em>files</em> are given or <em>file</em> is <strong>-</strong>, <strong>zstd</strong> reads from standard
input and writes the processed data to standard output. <strong>zstd</strong> will
refuse to write compressed data to standard output if it is a terminal:
it will display an error message and skip the file. Similarly, <strong>zstd</strong>
will refuse to read compressed data from standard input if it is a
terminal.</p>
<p>
Unless <strong>–stdout</strong> or <strong>-o</strong> is specified, <em>files</em> are written to a new
file whose name is derived from the source <em>file</em> name:</p>
<ul>
<li>When compressing, the suffix <strong>.zst</strong> is appended to the source filename
to get the target filename.</li>
<li>When decompressing, the <strong>.zst</strong> suffix is removed from the source
filename to get the target filename</li>
<li>:: </li>
</ul>
<div id="outline-container-headline-4" class="outline-3">
<h3 id="headline-4">
Concatenation with .zst Files
</h3>
<div id="outline-text-headline-4" class="outline-text-3">
<p>It is possible to concatenate multiple <strong>.zst</strong> files. <strong>zstd</strong> will
decompress such agglomerated file as if it was a single <strong>.zst</strong> file.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-5" class="outline-2">
<h2 id="headline-5">
OPTIONS
</h2>
<div id="outline-text-headline-5" class="outline-text-2">
<div id="outline-container-headline-6" class="outline-3">
<h3 id="headline-6">
Integer Suffixes and Special Values
</h3>
<div id="outline-text-headline-6" class="outline-text-3">
<p>In most places where an integer argument is expected, an optional suffix
is supported to easily indicate large integers. There must be no space
between the integer and the suffix.</p>
<dl>
<dt>
<strong>KiB</strong>
</dt>
<dd>Multiply the integer by 1,024 (2^10). <strong>Ki</strong>, <strong>K</strong>, and <strong>KB</strong> are
accepted as synonyms for <strong>KiB</strong>.</dd>
<dt>
<strong>MiB</strong>
</dt>
<dd>Multiply the integer by 1,048,576 (2^20). <strong>Mi</strong>, <strong>M</strong>, and <strong>MB</strong>
are accepted as synonyms for <strong>MiB</strong>.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-7" class="outline-3">
<h3 id="headline-7">
Operation Mode
</h3>
<div id="outline-text-headline-7" class="outline-text-3">
<p>If multiple operation mode options are given, the last one takes effect.</p>
<dl>
<dt>
<strong>-z</strong>, <strong>–compress</strong>
</dt>
<dd>Compress. This is the default operation mode
when no operation mode option is specified and no other operation mode
is implied from the command name (for example, <strong>unzstd</strong> implies
<strong>–decompress</strong>).</dd>
<dt>
<strong>-d</strong>, <strong>–decompress</strong>, <strong>–uncompress</strong>
</dt>
<dd>Decompress.</dd>
<dt>
<strong>-t</strong>, <strong>–test</strong>
</dt>
<dd>Test the integrity of compressed <em>files</em>. This
option is equivalent to <strong>–decompress –stdout &gt; /dev/null</strong>,
decompressed data is discarded and checksummed for errors. No files
are created or removed.</dd>
<dt>
<strong>-b#</strong>
</dt>
<dd>Benchmark file(s) using compression level <em>#</em>. See
<em>BENCHMARK</em> below for a description of this operation.</dd>
<dt>
<strong>–train FILES</strong>
</dt>
<dd>Use <em>FILES</em> as a training set to create a
dictionary. The training set should contain a lot of small files (&gt;
100). See <em>DICTIONARY BUILDER</em> below for a description of this
operation.</dd>
<dt>
<strong>-l</strong>, <strong>–list</strong>
</dt>
<dd>Display information related to a zstd compressed
file, such as size, ratio, and checksum. Some of these fields may not
be available. This command&#39;s output can be augmented with the <strong>-v</strong>
modifier.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-8" class="outline-3">
<h3 id="headline-8">
Operation Modifiers
</h3>
<div id="outline-text-headline-8" class="outline-text-3">
<ul>
<li><strong>-#</strong>: selects <strong>#</strong> compression level [1-19] (default: 3). Higher
compression levels <em>generally</em> produce higher compression ratio at the
expense of speed and memory. A rough rule of thumb is that compression
speed is expected to be divided by 2 every 2 levels. Technically, each
level is mapped to a set of advanced parameters (that can also be
modified individually, see below). Because the compressor&#39;s behavior
highly depends on the content to compress, there&#39;s no guarantee of a
smooth progression from one level to another.</li>
<li><strong>–ultra</strong>: unlocks high compression levels 20+ (maximum 22), using a
lot more memory. Note that decompression will also require more memory
when using these levels.</li>
<li><strong>–fast[=#]</strong>: switch to ultra-fast compression levels. If <strong>=#</strong> is not
present, it defaults to <strong>1</strong>. The higher the value, the faster the
compression speed, at the cost of some compression ratio. This setting
overwrites compression level if one was set previously. Similarly, if
a compression level is set after <strong>–fast</strong>, it overrides it.</li>
<li><strong>-T#</strong>, <strong>–threads=#</strong>: Compress using <strong>#</strong> working threads (default: 1).
If <strong>#</strong> is 0, attempt to detect and use the number of physical CPU
cores. In all cases, the nb of threads is capped to
<strong>ZSTDMT_NBWORKERS_MAX</strong>, which is either 64 in 32-bit mode, or 256 for
64-bit environments. This modifier does nothing if <strong>zstd</strong> is compiled
without multithread support.</li>
<li><strong>–single-thread</strong>: Use a single thread for both I/O and compression.
As compression is serialized with I/O, this can be slightly slower.
Single-thread mode features significantly lower memory usage, which
can be useful for systems with limited amount of memory, such as
32-bit systems.

Note 1: this mode is the only available one when multithread support
is disabled.

Note 2: this mode is different from <strong>-T1</strong>, which spawns 1 compression
thread in parallel with I/O. Final compressed result is also slightly
different from <strong>-T1</strong>.</li>
<li><strong>–auto-threads={physical,logical} (default: physical)</strong>: When using a
default amount of threads via <strong>-T0</strong>, choose the default based on the
number of detected physical or logical cores.</li>
<li><strong>–adapt[=min=#,max=#]</strong>: <strong>zstd</strong> will dynamically adapt compression
level to perceived I/O conditions. Compression level adaptation can be
observed live by using command <strong>-v</strong>. Adaptation can be constrained
between supplied <strong>min</strong> and <strong>max</strong> levels. The feature works when
combined with multi-threading and <strong>–long</strong> mode. It does not work with
<strong>–single-thread</strong>. It sets window size to 8 MiB by default (can be
changed manually, see <strong>wlog</strong>). Due to the chaotic nature of dynamic
adaptation, compressed result is not reproducible.

<em>Note</em>: at the time of this writing, <strong>–adapt</strong> can remain stuck at low
speed when combined with multiple worker threads (&gt;=2).</li>
<li><strong>–long[=#]</strong>: enables long distance matching with <strong>#</strong> <strong>windowLog</strong>, if
<strong>#</strong> is not present it defaults to <strong>27</strong>. This increases the window size
(<strong>windowLog</strong>) and memory usage for both the compressor and
decompressor. This setting is designed to improve the compression
ratio for files with long matches at a large distance.

Note: If <strong>windowLog</strong> is set to larger than 27, <strong>–long=windowLog</strong> or
<strong>–memory=windowSize</strong> needs to be passed to the decompressor.</li>
<li><strong>-D DICT</strong>: use <strong>DICT</strong> as Dictionary to compress or decompress FILE(s)</li>
<li><strong>–patch-from FILE</strong>: Specify the file to be used as a reference point
for zstd&#39;s diff engine. This is effectively dictionary compression
with some convenient parameter selection, namely that <em>windowSize</em> &gt;
<em>srcSize</em>.

Note: cannot use both this and <strong>-D</strong> together.

Note: <strong>–long</strong> mode will be automatically activated if <em>chainLog</em> &lt;
<em>fileLog</em> (<em>fileLog</em> being the <em>windowLog</em> required to cover the whole
file). You can also manually force it.

Note: for all levels, you can use <strong>–patch-from</strong> in <strong>–single-thread</strong>
mode to improve compression ratio at the cost of speed.

Note: for level 19, you can get increased compression ratio at the
cost of speed by specifying <strong>–zstd=targetLength=</strong> to be something
large (i.e. 4096), and by setting a large <strong>–zstd=chainLog=</strong>.</li>
<li><strong>–rsyncable</strong>: <strong>zstd</strong> will periodically synchronize the compression
state to make the compressed file more rsync-friendly. There is a
negligible impact to compression ratio, and a potential impact to
compression speed, perceptible at higher speeds, for example when
combining <strong>–rsyncable</strong> with many parallel worker threads. This
feature does not work with <strong>–single-thread</strong>. You probably don&#39;t want
to use it with long range mode, since it will decrease the
effectiveness of the synchronization points, but your mileage may
vary.</li>
<li><strong>-C</strong>, <strong>–[no-]check</strong>: add integrity check computed from uncompressed
data (default: enabled)</li>
<li><strong>–[no-]content-size</strong>: enable / disable whether or not the original
size of the file is placed in the header of the compressed file. The
default option is <strong>–content-size</strong> (meaning that the original size
will be placed in the header).</li>
<li><strong>–no-dictID</strong>: do not store dictionary ID within frame header
(dictionary compression). The decoder will have to rely on implicit
knowledge about which dictionary to use, it won&#39;t be able to check if
it&#39;s correct.</li>
<li><strong>-M#</strong>, <strong>–memory=#</strong>: Set a memory usage limit. By default, <strong>zstd</strong> uses
128 MiB for decompression as the maximum amount of memory the
decompressor is allowed to use, but you can override this manually if
need be in either direction (i.e. you can increase or decrease it).

This is also used during compression when using with <strong>–patch-from=</strong>.
In this case, this parameter overrides that maximum size allowed for a
dictionary. (128 MiB).

Additionally, this can be used to limit memory for dictionary
training. This parameter overrides the default limit of 2 GiB. zstd
will load training samples up to the memory limit and ignore the rest.</li>
<li><strong>–stream-size=#</strong>: Sets the pledged source size of input coming from a
stream. This value must be exact, as it will be included in the
produced frame header. Incorrect stream sizes will cause an error.
This information will be used to better optimize compression
parameters, resulting in better and potentially faster compression,
especially for smaller source sizes.</li>
<li><strong>–size-hint=#</strong>: When handling input from a stream, <strong>zstd</strong> must guess
how large the source size will be when optimizing compression
parameters. If the stream size is relatively small, this guess may be
a poor one, resulting in a higher compression ratio than expected.
This feature allows for controlling the guess when needed. Exact
guesses result in better compression ratios. Overestimates result in
slightly degraded compression ratios, while underestimates may result
in significant degradation.</li>
<li><strong>–target-compressed-block-size=#</strong>: Attempt to produce compressed
blocks of approximately this size. This will split larger blocks in
order to approach this target. This feature is notably useful for
improved latency, when the receiver can leverage receiving early
incomplete data. This parameter defines a loose target: compressed
blocks will target this size &#34;on average&#34;, but individual blocks can
still be larger or smaller. Enabling this feature can decrease
compression speed by up to ~10% at level 1. Higher levels will see
smaller relative speed regression, becoming invisible at higher
settings.</li>
<li><strong>-f</strong>, <strong>–force</strong>: disable input and output checks. Allows overwriting
existing files, input from console, output to stdout, operating on
links, block devices, etc. During decompression and when the output
destination is stdout, pass-through unrecognized formats as-is.</li>
<li><strong>-c</strong>, <strong>–stdout</strong>: write to standard output (even if it is the
console); keep original files (disable <strong>–rm</strong>).</li>
<li><strong>-o FILE</strong>: save result into <strong>FILE</strong>. Note that this operation is in
conflict with <strong>-c</strong>. If both operations are present on the command
line, the last expressed one wins.</li>
<li><strong>–[no-]sparse</strong>: enable / disable sparse FS support, to make files
with many zeroes smaller on disk. Creating sparse files may save disk
space and speed up decompression by reducing the amount of disk I/O.
default: enabled when output is into a file, and disabled when output
is stdout. This setting overrides default and can force sparse mode
over stdout.</li>
<li><strong>–[no-]pass-through</strong> enable / disable passing through uncompressed
files as-is. During decompression when pass-through is enabled,
unrecognized formats will be copied as-is from the input to the
output. By default, pass-through will occur when the output
destination is stdout and the force (<strong>-f</strong>) option is set.</li>
<li><strong>–rm</strong>: remove source file(s) after successful compression or
decompression. This command is silently ignored if output is <strong>stdout</strong>.
If used in combination with <strong>-o</strong>, triggers a confirmation prompt
(which can be silenced with <strong>-f</strong>), as this is a destructive operation.</li>
<li><strong>-k</strong>, <strong>–keep</strong>: keep source file(s) after successful compression or
decompression. This is the default behavior.</li>
<li><strong>-r</strong>: operate recursively on directories. It selects all files in the
named directory and all its subdirectories. This can be useful both to
reduce command line typing, and to circumvent shell expansion
limitations, when there are a lot of files and naming breaks the
maximum size of a command line.</li>
<li><strong>–filelist FILE</strong> read a list of files to process as content from
<strong>FILE</strong>. Format is compatible with <strong>ls</strong> output, with one file per line.</li>
<li><strong>–output-dir-flat DIR</strong>: resulting files are stored into target <strong>DIR</strong>
directory, instead of same directory as origin file. Be aware that
this command can introduce name collision issues, if multiple files,
from different directories, end up having the same name. Collision
resolution ensures first file with a given name will be present in
<strong>DIR</strong>, while in combination with <strong>-f</strong>, the last file will be present
instead.</li>
<li><strong>–output-dir-mirror DIR</strong>: similar to <strong>–output-dir-flat</strong>, the output
files are stored underneath target <strong>DIR</strong> directory, but this option
will replicate input directory hierarchy into output <strong>DIR</strong>.

If input directory contains &#34;..&#34;, the files in this directory will be
ignored. If input directory is an absolute directory (i.e.
&#34;/var/tmp/abc&#34;), it will be stored into the &#34;output-dir/var/tmp/abc&#34;.
If there are multiple input files or directories, name collision
resolution will follow the same rules as <strong>–output-dir-flat</strong>.</li>
<li><strong>–format=FORMAT</strong>: compress and decompress in other formats. If
compiled with support, zstd can compress to or decompress from other
compression algorithm formats. Possibly available options are <strong>zstd</strong>,
<strong>gzip</strong>, <strong>xz</strong>, <strong>lzma</strong>, and <strong>lz4</strong>. If no such format is provided, <strong>zstd</strong>
is the default.</li>
<li><strong>-h*/</strong>-H*, <strong>–help</strong>: display help/long help and exit</li>
<li><strong>-V</strong>, <strong>–version</strong>: display version number and immediately exit. note
that, since it exits, flags specified after <strong>-V</strong> are effectively
ignored. Advanced: <strong>-vV</strong> also displays supported formats. <strong>-vvV</strong> also
displays POSIX support. <strong>-qV</strong> will only display the version number,
suitable for machine reading.</li>
<li><strong>-v</strong>, <strong>–verbose</strong>: verbose mode, display more information</li>
<li><strong>-q</strong>, <strong>–quiet</strong>: suppress warnings, interactivity, and notifications.
specify twice to suppress errors too.</li>
<li><strong>–no-progress</strong>: do not display the progress bar, but keep all other
messages.</li>
<li><strong>–show-default-cparams</strong>: shows the default compression parameters
that will be used for a particular input file, based on the provided
compression level and the input size. If the provided file is not a
regular file (e.g. a pipe), this flag will output the parameters used
for inputs of unknown size.</li>
<li><strong>–exclude-compressed</strong>: only compress files that are not already
compressed.</li>
<li><strong>–</strong>: All arguments after <strong>–</strong> are treated as files</li>
<li>:: </li>
</ul>
</div>
</div>
<div id="outline-container-headline-9" class="outline-3">
<h3 id="headline-9">
gzip Operation Modifiers
</h3>
<div id="outline-text-headline-9" class="outline-text-3">
<p>When invoked via a <strong>gzip</strong> symlink, <strong>zstd</strong> will support further options
that intend to mimic the <strong>gzip</strong> behavior:</p>
<dl>
<dt>
<strong>-n</strong>, <strong>–no-name</strong>
</dt>
<dd>do not store the original filename and timestamps
when compressing a file. This is the default behavior and hence a
no-op.</dd>
<dt>
<strong>–best</strong>
</dt>
<dd>alias to the option <strong>-9</strong>.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-10" class="outline-3">
<h3 id="headline-10">
Environment Variables
</h3>
<div id="outline-text-headline-10" class="outline-text-3">
<p>Employing environment variables to set parameters has security
implications. Therefore, this avenue is intentionally limited. Only
<strong>ZSTD_CLEVEL</strong> and <strong>ZSTD_NBTHREADS</strong> are currently supported. They set the
default compression level and number of threads to use during
compression, respectively.</p>
<p>
<strong>ZSTD_CLEVEL</strong> can be used to set the level between 1 and 19 (the
&#34;normal&#34; range). If the value of <strong>ZSTD_CLEVEL</strong> is not a valid integer,
it will be ignored with a warning message. <strong>ZSTD_CLEVEL</strong> just replaces
the default compression level (<strong>3</strong>).</p>
<p>
<strong>ZSTD_NBTHREADS</strong> can be used to set the number of threads <strong>zstd</strong> will
attempt to use during compression. If the value of <strong>ZSTD_NBTHREADS</strong> is
not a valid unsigned integer, it will be ignored with a warning message.
<strong>ZSTD_NBTHREADS</strong> has a default value of (<strong>1</strong>), and is capped at
ZSTDMT_NBWORKERS_MAX==200. <strong>zstd</strong> must be compiled with multithread
support for this variable to have any effect.</p>
<p>
They can both be overridden by corresponding command line arguments:
<strong>-#</strong> for compression level and <strong>-T#</strong> for number of compression threads.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-11" class="outline-2">
<h2 id="headline-11">
ADVANCED COMPRESSION OPTIONS
</h2>
<div id="outline-text-headline-11" class="outline-text-2">
<p><strong>zstd</strong> provides 22 predefined regular compression levels plus the fast
levels. A compression level is translated internally into multiple
advanced parameters that control the behavior of the compressor (one can
observe the result of this translation with <strong>–show-default-cparams</strong>).
These advanced parameters can be overridden using advanced compression
options.</p>
<div id="outline-container-headline-12" class="outline-3">
<h3 id="headline-12">
–zstd[=options]:
</h3>
<div id="outline-text-headline-12" class="outline-text-3">
<p>The <em>options</em> are provided as a comma-separated list. You may specify
only the options you want to change and the rest will be taken from the
selected or default compression level. The list of available <em>options</em>:</p>
<dl>
<dt>
*strategy*=/strat/, *strat*=/strat/
</dt>
<dd>Specify a strategy used by a
match finder.

There are 9 strategies numbered from 1 to 9, from fastest to
strongest: 1=*ZSTD_fast*, 2=*ZSTD_dfast*, 3=*ZSTD_greedy*,
4=*ZSTD_lazy*, 5=*ZSTD_lazy2*, 6=*ZSTD_btlazy2*, 7=*ZSTD_btopt*,
8=*ZSTD_btultra*, 9=*ZSTD_btultra2*.</dd>
<dt>
*windowLog*=/wlog/, *wlog*=/wlog/
</dt>
<dd>Specify the maximum number of
bits for a match distance.

The higher number of increases the chance to find a match which
usually improves compression ratio. It also increases memory
requirements for the compressor and decompressor. The minimum <em>wlog</em>
is 10 (1 KiB) and the maximum is 30 (1 GiB) on 32-bit platforms and 31
(2 GiB) on 64-bit platforms.

Note: If <strong>windowLog</strong> is set to larger than 27, <strong>–long=windowLog</strong> or
<strong>–memory=windowSize</strong> needs to be passed to the decompressor.</dd>
<dt>
*hashLog*=/hlog/, *hlog*=/hlog/
</dt>
<dd>Specify the maximum number of bits
for a hash table.

Bigger hash tables cause fewer collisions which usually makes
compression faster, but requires more memory during compression.

The minimum <em>hlog</em> is 6 (64 entries / 256 B) and the maximum is 30 (1B
entries / 4 GiB).</dd>
<dt>
*chainLog*=/clog/, *clog*=/clog/
</dt>
<dd>Specify the maximum number of bits
for the secondary search structure, whose form depends on the selected
<strong>strategy</strong>.

Higher numbers of bits increases the chance to find a match which
usually improves compression ratio. It also slows down compression
speed and increases memory requirements for compression. This option
is ignored for the <strong>ZSTD_fast</strong> <strong>strategy</strong>, which only has the primary
hash table.

The minimum <em>clog</em> is 6 (64 entries / 256 B) and the maximum is 29
(512M entries / 2 GiB) on 32-bit platforms and 30 (1B entries / 4 GiB)
on 64-bit platforms.</dd>
<dt>
*searchLog*=/slog/, *slog*=/slog/
</dt>
<dd>Specify the maximum number of
searches in a hash chain or a binary tree using logarithmic scale.

More searches increases the chance to find a match which usually
increases compression ratio but decreases compression speed.

The minimum <em>slog</em> is 1 and the maximum is &#39;windowLog&#39; - 1.</dd>
<dt>
*minMatch*=/mml/, *mml*=/mml/
</dt>
<dd>Specify the minimum searched length
of a match in a hash table.

Larger search lengths usually decrease compression ratio but improve
decompression speed.

The minimum <em>mml</em> is 3 and the maximum is 7.</dd>
<dt>
*targetLength*=/tlen/, *tlen*=/tlen/
</dt>
<dd>The impact of this field vary
depending on selected strategy.

For <strong>ZSTD_btopt</strong>, <strong>ZSTD_btultra</strong> and <strong>ZSTD_btultra2</strong>, it specifies the
minimum match length that causes match finder to stop searching. A
larger <strong>targetLength</strong> usually improves compression ratio but decreases
compression speed.

For <strong>ZSTD_fast</strong>, it triggers ultra-fast mode when &gt; 0. The value
represents the amount of data skipped between match sampling. Impact
is reversed: a larger <strong>targetLength</strong> increases compression speed but
decreases compression ratio.

For all other strategies, this field has no impact.

The minimum <em>tlen</em> is 0 and the maximum is 128 KiB.</dd>
<dt>
*overlapLog*=/ovlog/, *ovlog*=/ovlog/
</dt>
<dd>Determine <strong>overlapSize</strong>,
amount of data reloaded from previous job. This parameter is only
available when multithreading is enabled. Reloading more data improves
compression ratio, but decreases speed.

The minimum <em>ovlog</em> is 0, and the maximum is 9. 1 means &#34;no overlap&#34;,
hence completely independent jobs. 9 means &#34;full overlap&#34;, meaning up
to <strong>windowSize</strong> is reloaded from previous job. Reducing <em>ovlog</em> by 1
reduces the reloaded amount by a factor 2. For example, 8 means
&#34;windowSize/2&#34;, and 6 means &#34;windowSize/8&#34;. Value 0 is special and
means &#34;default&#34;: <em>ovlog</em> is automatically determined by <strong>zstd</strong>. In
which case, <em>ovlog</em> will range from 6 to 9, depending on selected
<em>strat</em>.</dd>
<dt>
*ldmHashLog*=/lhlog/, *lhlog*=/lhlog/
</dt>
<dd>Specify the maximum size for
a hash table used for long distance matching.

This option is ignored unless long distance matching is enabled.

Bigger hash tables usually improve compression ratio at the expense of
more memory during compression and a decrease in compression speed.

The minimum <em>lhlog</em> is 6 and the maximum is 30 (default: 20).</dd>
<dt>
*ldmMinMatch*=/lmml/, *lmml*=/lmml/
</dt>
<dd>Specify the minimum searched
length of a match for long distance matching.

This option is ignored unless long distance matching is enabled.

Larger/very small values usually decrease compression ratio.

The minimum <em>lmml</em> is 4 and the maximum is 4096 (default: 64).</dd>
<dt>
*ldmBucketSizeLog*=/lblog/, *lblog*=/lblog/
</dt>
<dd>Specify the size of
each bucket for the hash table used for long distance matching.

This option is ignored unless long distance matching is enabled.

Larger bucket sizes improve collision resolution but decrease
compression speed.

The minimum <em>lblog</em> is 1 and the maximum is 8 (default: 3).</dd>
<dt>
*ldmHashRateLog*=/lhrlog/, *lhrlog*=/lhrlog/
</dt>
<dd>Specify the frequency
of inserting entries into the long distance matching hash table.

This option is ignored unless long distance matching is enabled.

Larger values will improve compression speed. Deviating far from the
default value will likely result in a decrease in compression ratio.

The default value is <strong>wlog - lhlog</strong>.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-13" class="outline-3">
<h3 id="headline-13">
Example
</h3>
<div id="outline-text-headline-13" class="outline-text-3">
<p>The following parameters sets advanced compression options to something
similar to predefined level 19 for files bigger than 256 KB:</p>
<p>
*–zstd*=wlog=23,clog=23,hlog=22,slog=6,mml=3,tlen=48,strat=6</p>
</div>
</div>
<div id="outline-container-headline-14" class="outline-3">
<h3 id="headline-14">
-B#:
</h3>
<div id="outline-text-headline-14" class="outline-text-3">
<p>Specify the size of each compression job. This parameter is only
available when multi-threading is enabled. Each compression job is run
in parallel, so this value indirectly impacts the nb of active threads.
Default job size varies depending on compression level (generally <strong>4 *
windowSize</strong>). <strong>-B#</strong> makes it possible to manually select a custom size.
Note that job size must respect a minimum value which is enforced
transparently. This minimum is either 512 KB, or <strong>overlapSize</strong>,
whichever is largest. Different job sizes will lead to non-identical
compressed frames.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-15" class="outline-2">
<h2 id="headline-15">
DICTIONARY BUILDER
</h2>
<div id="outline-text-headline-15" class="outline-text-2">
<p><strong>zstd</strong> offers <em>dictionary</em> compression, which greatly improves
efficiency on small files and messages. It&#39;s possible to train <strong>zstd</strong>
with a set of samples, the result of which is saved into a file called a
<strong>dictionary</strong>. Then, during compression and decompression, reference the
same dictionary, using command <strong>-D dictionaryFileName</strong>. Compression of
small files similar to the sample set will be greatly improved.</p>
<dl>
<dt>
<strong>–train FILEs</strong>
</dt>
<dd>Use FILEs as training set to create a dictionary.
The training set should ideally contain a lot of samples (&gt; 100), and
weight typically 100x the target dictionary size (for example, ~10 MB
for a 100 KB dictionary). <strong>–train</strong> can be combined with <strong>-r</strong> to
indicate a directory rather than listing all the files, which can be
useful to circumvent shell expansion limits.

Since dictionary compression is mostly effective for small files, the
expectation is that the training set will only contain small files. In
the case where some samples happen to be large, only the first 128 KiB
of these samples will be used for training.

<strong>–train</strong> supports multithreading if <strong>zstd</strong> is compiled with threading
support (default). Additional advanced parameters can be specified
with <strong>–train-fastcover</strong>. The legacy dictionary builder can be
accessed with <strong>–train-legacy</strong>. The slower cover dictionary builder
can be accessed with <strong>–train-cover</strong>. Default <strong>–train</strong> is equivalent
to <strong>–train-fastcover=d=8,steps=4</strong>.</dd>
<dt>
<strong>-o FILE</strong>
</dt>
<dd>Dictionary saved into <strong>FILE</strong> (default name: dictionary).</dd>
<dt>
<strong>–maxdict=#</strong>
</dt>
<dd>Limit dictionary to specified size (default: 112640
bytes). As usual, quantities are expressed in bytes by default, and
it&#39;s possible to employ suffixes (like <strong>KB</strong> or <strong>MB</strong>) to specify larger
values.</dd>
<dt>
<strong>-#</strong>
</dt>
<dd>Use <strong>#</strong> compression level during training (optional). Will
generate statistics more tuned for selected compression level,
resulting in a <em>small</em> compression ratio improvement for this level.</dd>
<dt>
<strong>-B#</strong>
</dt>
<dd>Split input files into blocks of size # (default: no split)</dd>
<dt>
<strong>-M#</strong>, <strong>–memory=#</strong>
</dt>
<dd>Limit the amount of sample data loaded for
training (default: 2 GB). Note that the default (2 GB) is also the
maximum. This parameter can be useful in situations where the training
set size is not well controlled and could be potentially very large.
Since speed of the training process is directly correlated to the size
of the training sample set, a smaller sample set leads to faster
training.

In situations where the training set is larger than maximum memory,
the CLI will randomly select samples among the available ones, up to
the maximum allowed memory budget. This is meant to improve dictionary
relevance by mitigating the potential impact of clustering, such as
selecting only files from the beginning of a list sorted by
modification date, or sorted by alphabetical order. The randomization
process is deterministic, so training of the same list of files with
the same parameters will lead to the creation of the same dictionary.</dd>
<dt>
<strong>–dictID=#</strong>
</dt>
<dd>A dictionary ID is a locally unique ID. The decoder
will use this value to verify it is using the right dictionary. By
default, zstd will create a 4-bytes random number ID. It&#39;s possible to
provide an explicit number ID instead. It&#39;s up to the dictionary
manager to not assign twice the same ID to 2 different dictionaries.
Note that short numbers have an advantage: an ID &lt; 256 will only need
1 byte in the compressed frame header, and an ID &lt; 65536 will only
need 2 bytes. This compares favorably to 4 bytes default.

Note that RFC8878 reserves IDs less than 32768 and greater than or
equal to 2^31, so they should not be used in public.</dd>
<dt>
<strong>–train-cover[=k#,d=#,steps=#,split=#,shrink[=#]]</strong>
</dt>
<dd>Select
parameters for the default dictionary builder algorithm named cover.
If <em>d</em> is not specified, then it tries <em>d</em> = 6 and <em>d</em> = 8. If <em>k</em> is
not specified, then it tries <em>steps</em> values in the range [50, 2000].
If <em>steps</em> is not specified, then the default value of 40 is used. If
<em>split</em> is not specified or split &lt;= 0, then the default value of 100
is used. Requires that <em>d</em> &lt;= <em>k</em>. If <em>shrink</em> flag is not used, then
the default value for <em>shrinkDict</em> of 0 is used. If <em>shrink</em> is not
specified, then the default value for <em>shrinkDictMaxRegression</em> of 1
is used.

Selects segments of size <em>k</em> with highest score to put in the
dictionary. The score of a segment is computed by the sum of the
frequencies of all the subsegments of size <em>d</em>. Generally <em>d</em> should
be in the range [6, 8], occasionally up to 16, but the algorithm will
run faster with d &lt;= <em>8</em>. Good values for <em>k</em> vary widely based on the
input data, but a safe range is [2 * <em>d</em>, 2000]. If <em>split</em> is 100,
all input samples are used for both training and testing to find
optimal <em>d</em> and <em>k</em> to build dictionary. Supports multithreading if
<strong>zstd</strong> is compiled with threading support. Having <em>shrink</em> enabled
takes a truncated dictionary of minimum size and doubles in size until
compression ratio of the truncated dictionary is at most
<em>shrinkDictMaxRegression%</em> worse than the compression ratio of the
largest dictionary.

Examples:

<strong>zstd –train-cover FILEs</strong>

<strong>zstd –train-cover=k=50,d=8 FILEs</strong>

<strong>zstd –train-cover=d=8,steps=500 FILEs</strong>

<strong>zstd –train-cover=k=50 FILEs</strong>

<strong>zstd –train-cover=k=50,split=60 FILEs</strong>

<strong>zstd –train-cover=shrink FILEs</strong>

<strong>zstd –train-cover=shrink=2 FILEs</strong></dd>
<dt>
<strong>–train-fastcover[=k#,d=#,f=#,steps=#,split=#,accel=#]</strong>
</dt>
<dd>Same as
cover but with extra parameters <em>f</em> and <em>accel</em> and different default
value of split If <em>split</em> is not specified, then it tries <em>split</em>
= 75. If <em>f</em> is not specified, then it tries <em>f</em> = 20. Requires that 0
&lt; <em>f</em> &lt; 32. If <em>accel</em> is not specified, then it tries <em>accel</em> = 1.
Requires that 0 &lt; <em>accel</em> &lt;= 10. Requires that <em>d</em> = 6 or <em>d</em> = 8.

<em>f</em> is log of size of array that keeps track of frequency of
subsegments of size <em>d</em>. The subsegment is hashed to an index in the
range [0,2^/f/ - 1]. It is possible that 2 different subsegments are
hashed to the same index, and they are considered as the same
subsegment when computing frequency. Using a higher <em>f</em> reduces
collision but takes longer.

Examples:

<strong>zstd –train-fastcover FILEs</strong>

<strong>zstd –train-fastcover=d=8,f=15,accel=2 FILEs</strong></dd>
<dt>
<strong>–train-legacy[=selectivity=#]</strong>
</dt>
<dd>Use legacy dictionary builder
algorithm with the given dictionary <em>selectivity</em> (default: 9). The
smaller the <em>selectivity</em> value, the denser the dictionary, improving
its efficiency but reducing its achievable maximum size.
<strong>–train-legacy=s=#</strong> is also accepted.

Examples:

<strong>zstd –train-legacy FILEs</strong>

<strong>zstd –train-legacy=selectivity=8 FILEs</strong></dd>
</dl>
</div>
</div>
<div id="outline-container-headline-16" class="outline-2">
<h2 id="headline-16">
BENCHMARK
</h2>
<div id="outline-text-headline-16" class="outline-text-2">
<p>The <strong>zstd</strong> CLI provides a benchmarking mode that can be used to easily
find suitable compression parameters, or alternatively to benchmark a
computer&#39;s performance. Note that the results are highly dependent on
the content being compressed.</p>
<dl>
<dt>
<strong>-b#</strong>
</dt>
<dd>benchmark file(s) using compression level #</dd>
<dt>
<strong>-e#</strong>
</dt>
<dd>benchmark file(s) using multiple compression levels, from
<strong>-b#</strong> to <strong>-e#</strong> (inclusive)</dd>
<dt>
<strong>-d</strong>
</dt>
<dd>benchmark decompression speed only (requires providing an
already zstd-compressed content)</dd>
<dt>
<strong>-i#</strong>
</dt>
<dd>minimum evaluation time, in seconds (default: 3s), benchmark
mode only</dd>
<dt>
<strong>-B#</strong>, <strong>–block-size=#</strong>
</dt>
<dd>cut file(s) into independent chunks of size
​# (default: no chunking)</dd>
<dt>
<strong>–priority=rt</strong>
</dt>
<dd>set process priority to real-time (Windows)</dd>
</dl>
<p><strong>Output Format:</strong> CompressionLevel#Filename: InputSize -&gt; OutputSize
(CompressionRatio), CompressionSpeed, DecompressionSpeed</p>
<p>
<strong>Methodology:</strong> For both compression and decompression speed, the entire
input is compressed/decompressed in-memory to measure speed. A run lasts
at least 1 sec, so when files are small, they are
compressed/decompressed several times per run, in order to improve
measurement accuracy.</p>
</div>
</div>
<div id="outline-container-headline-17" class="outline-2">
<h2 id="headline-17">
SEE ALSO
</h2>
<div id="outline-text-headline-17" class="outline-text-2">
<p>*zstdgrep*(1), *zstdless*(1), *gzip*(1), *xz*(1)</p>
<p>
The <em>zstandard</em> format is specified in Y. Collet, &#34;Zstandard Compression
and the &#39;application/zstd&#39; Media Type&#34;,
<a href="https://www.ietf.org/rfc/rfc8878.txt,">https://www.ietf.org/rfc/rfc8878.txt,</a> Internet RFC 8878 (February 2021).</p>
</div>
</div>
<div id="outline-container-headline-18" class="outline-2">
<h2 id="headline-18">
BUGS
</h2>
<div id="outline-text-headline-18" class="outline-text-2">
<p>Report bugs at: <a href="https://github.com/facebook/zstd/issues">https://github.com/facebook/zstd/issues</a></p>
</div>
</div>
<div id="outline-container-headline-19" class="outline-2">
<h2 id="headline-19">
AUTHOR
</h2>
<div id="outline-text-headline-19" class="outline-text-2">
<p>Yann Collet</p>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.95916b5b8c09add4922ea47e674b5da7fc4b6347a3e8c4e25e98b4b7d236080b.js" integrity="sha256-lZFrW4wJrdSSLqR&#43;Z0tdp/xLY0ej6MTiXpi0t9I2CAs=" crossorigin="anonymous"></script>
    </body>
</html>
