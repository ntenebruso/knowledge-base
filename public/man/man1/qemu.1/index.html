<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - qemu.1 | Technical Notes</title>

      <link rel="stylesheet" href="/css/main.min.a9ecaac9d4f7845fc2de4738f7709cab0bd1c3d19c3466fadd637a6987603257.css" integrity="sha256-qeyqydT3hF/C3kc493CcqwvRw9GcNGb63WN6aYdgMlc=" crossorigin="anonymous">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - qemu.1</h1>
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
NAME
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>qemu - QEMU User Documentation</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
SYNOPSIS
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 [options] [disk_image]
</pre>
</blockquote>
</blockquote>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
DESCRIPTION
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p>The QEMU PC System emulator simulates the following peripherals:</p>
<blockquote>
<ul>
<li>i440FX host PCI bridge and PIIX3 PCI to ISA bridge</li>
<li>Cirrus CLGD 5446 PCI VGA card or dummy VGA card with Bochs VESA
extensions (hardware level, including all non standard modes).</li>
<li>PS/2 mouse and keyboard</li>
<li>2 PCI IDE interfaces with hard disk and CD-ROM support</li>
<li>Floppy disk</li>
<li>PCI and ISA network adapters</li>
<li>Serial ports</li>
<li>IPMI BMC, either and internal or external one</li>
<li>Creative SoundBlaster 16 sound card</li>
<li>ENSONIQ AudioPCI ES1370 sound card</li>
<li>Intel 82801AA AC97 Audio compatible sound card</li>
<li>Intel HD Audio Controller and HDA codec</li>
<li>Adlib (OPL2) - Yamaha YM3812 compatible chip</li>
<li>Gravis Ultrasound GF1 sound card</li>
<li>CS4231A compatible sound card</li>
<li>PC speaker</li>
<li>PCI UHCI, OHCI, EHCI or XHCI USB controller and a virtual USB-1.1 hub.</li>
</ul>
</blockquote>
<p>
SMP is supported with a large number of virtual CPUs (upper limit is
configuration dependent).</p>
<p>
QEMU uses the PC BIOS from the Seabios project and the Plex86/Bochs LGPL
VGA BIOS.</p>
<p>
QEMU uses YM3812 emulation by Tatsuyuki Satoh.</p>
<p>
QEMU uses GUS emulation (GUSEMU32 <em><a href="http://www.deinmeister.de/gusemu/">http://www.deinmeister.de/gusemu/</a></em>)
by Tibor &#34;TS&#34; Schütz.</p>
<p>
Note that, by default, GUS shares IRQ(7) with parallel ports and so QEMU
must be told to not have parallel ports to have working GUS.</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 dos.img -device gus -parallel none
</pre>
</blockquote>
</blockquote>
<p>
Alternatively:</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 dos.img -device gus,irq=5
</pre>
</blockquote>
</blockquote>
<p>
Or some other unclaimed IRQ.</p>
<p>
CS4231A is the chip used in Windows Sound System and GUSMAX products</p>
<p>
The PC speaker audio device can be configured using the pcspk-audiodev
machine property, i.e.</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 some.img -audiodev &lt;backend&gt;,id=&lt;name&gt; -machine pcspk-audiodev=&lt;name&gt;
</pre>
</blockquote>
</blockquote>
<div id="outline-container-headline-4" class="outline-3">
<h3 id="headline-4">
Machine-specific options
</h3>
<div id="outline-text-headline-4" class="outline-text-3">
<p>It supports the following machine-specific options:</p>
<blockquote>
<ul>
<li><strong>x-south-bridge=PIIX3|piix4-isa</strong> (Experimental option to select a
particular south bridge. Default: <strong>PIIX3</strong>)</li>
</ul>
</blockquote>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-5" class="outline-2">
<h2 id="headline-5">
OPTIONS
</h2>
<div id="outline-text-headline-5" class="outline-text-2">
<p>disk_image is a raw hard disk image for IDE hard disk 0. Some targets do
not need a disk image.</p>
<p>
When dealing with options parameters as arbitrary strings containing
commas, such as in &#34;file=my,file&#34; and &#34;string=a,b&#34;, it&#39;s necessary to
double the commas. For instance,&#34;-fw_cfg name=z,string=a,,b&#34; will be
parsed as &#34;-fw_cfg name=z,string=a,b&#34;.</p>
<div id="outline-container-headline-6" class="outline-3">
<h3 id="headline-6">
Standard options
</h3>
<div id="outline-text-headline-6" class="outline-text-3">
<blockquote>
<dl>
<dt>
<strong><strong>-h</strong></strong>
</dt>
<dd>Display help and exit</dd>
<dt>
<strong><strong>-version</strong></strong>
</dt>
<dd>Display version information and exit</dd>
<dt>
<strong>*-machine</strong> [type=]name[,prop=value[,…]]*
</dt>
<dd>
<p>Select the emulated
machine by name. Use <strong>-machine help</strong> to list available machines.</p>
<p>
For architectures which aim to support live migration compatibility
across releases, each release will introduce a new versioned machine
type. For example, the 2.8.0 release introduced machine types
&#34;pc-i440fx-2.8&#34; and &#34;pc-q35-2.8&#34; for the x86_64/i686 architectures.</p>
<p>
To allow live migration of guests from QEMU version 2.8.0, to QEMU
version 2.9.0, the 2.9.0 version must support the &#34;pc-i440fx-2.8&#34; and
&#34;pc-q35-2.8&#34; machines too. To allow users live migrating VMs to skip
multiple intermediate releases when upgrading, new releases of QEMU
will support machine types from many previous versions.</p>
<p>
Supported machine properties are:</p>
<dl>
<dt>
<strong><strong>accel=accels1[:accels2[:…]]</strong></strong>
</dt>
<dd>This is used to enable an
accelerator. Depending on the target architecture, kvm, xen, hvf,
nvmm, whpx or tcg can be available. By default, tcg is used. If
there is more than one accelerator specified, the next one is used
if the previous one fails to initialize.</dd>
<dt>
<strong><strong>vmport=on|off|auto</strong></strong>
</dt>
<dd>Enables emulation of VMWare IO port, for
vmmouse etc. auto says to select the value based on accel and i8042.
For accel=xen or i8042=off the default is off otherwise the default
is on.</dd>
<dt>
<strong><strong>dump-guest-core=on|off</strong></strong>
</dt>
<dd>Include guest memory in a core dump.
The default is on.</dd>
<dt>
<strong><strong>mem-merge=on|off</strong></strong>
</dt>
<dd>Enables or disables memory merge support.
This feature, when supported by the host, de-duplicates identical
memory pages among VMs instances (enabled by default).</dd>
<dt>
<strong><strong>aes-key-wrap=on|off</strong></strong>
</dt>
<dd>Enables or disables AES key wrapping
support on s390-ccw hosts. This feature controls whether AES
wrapping keys will be created to allow execution of AES
cryptographic functions. The default is on.</dd>
<dt>
<strong><strong>dea-key-wrap=on|off</strong></strong>
</dt>
<dd>Enables or disables DEA key wrapping
support on s390-ccw hosts. This feature controls whether DEA
wrapping keys will be created to allow execution of DEA
cryptographic functions. The default is on.</dd>
<dt>
<strong><strong>nvdimm=on|off</strong></strong>
</dt>
<dd>Enables or disables NVDIMM support. The default
is off.</dd>
<dt>
<strong><strong>memory-encryption=</strong></strong>
</dt>
<dd>Memory encryption object to use. The
default is none.</dd>
<dt>
<strong><strong>hmat=on|off</strong></strong>
</dt>
<dd>Enables or disables ACPI Heterogeneous Memory
Attribute Table (HMAT) support. The default is off.</dd>
<dt>
<strong><strong>memory-backend=&#39;id&#39;</strong></strong>
</dt>
<dd>
<p>An alternative to legacy <strong>-mem-path</strong> and
<strong>mem-prealloc</strong> options. Allows to use a memory backend as main RAM.</p>
<p>
For example:</p>
<blockquote>
<pre class="example">
-object memory-backend-file,id=pc.ram,size=512M,mem-path=/hugetlbfs,prealloc=on,share=on
-machine memory-backend=pc.ram
-m 512M
</pre>
</blockquote>
</dd>
</dl>
<p>Migration compatibility note:</p>
<blockquote>
<ul>
<li>as backend id one shall use value of &#39;default-ram-id&#39;, advertised by
machine type (available via <strong>query-machines</strong> QMP command), if
migration to/from old QEMU (&lt;5.0) is expected.</li>
<li>for machine types 4.0 and older, user shall use
<strong>x-use-canonical-path-for-ramblock-id=off</strong> backend option if
migration to/from old QEMU (&lt;5.0) is expected.</li>
</ul>
</blockquote>
<p>
For example:</p>
<blockquote>
<blockquote>
<pre class="example">
-object memory-backend-ram,id=pc.ram,size=512M,x-use-canonical-path-for-ramblock-id=off
-machine memory-backend=pc.ram
-m 512M
</pre>
</blockquote>
</blockquote>
<dl>
<dt>
<strong><strong>cxl-fmw.0.targets.0=firsttarget,cxl-fmw.0.targets.1=secondtarget,cxl-fmw.0.size=size[,cxl-fmw.0.interleave-granularity=granularity]</strong></strong>
</dt>
<dd>
<p>Define
a CXL Fixed Memory Window (CFMW).</p>
<p>
Described in the CXL 2.0 ECN: CEDT CFMWS &amp; QTG _DSM.</p>
<p>
They are regions of Host Physical Addresses (HPA) on a system which
may be interleaved across one or more CXL host bridges. The system
software will assign particular devices into these windows and
configure the downstream Host-managed Device Memory (HDM) decoders
in root ports, switch ports and devices appropriately to meet the
interleave requirements before enabling the memory devices.</p>
<p>
<strong>targets.X=target</strong> provides the mapping to CXL host bridges which
may be identified by the id provided in the -device entry. Multiple
entries are needed to specify all the targets when the fixed memory
window represents interleaved memory. X is the target index from 0.</p>
<p>
<strong>size=size</strong> sets the size of the CFMW. This must be a multiple of
256MiB. The region will be aligned to 256MiB but the location is
platform and configuration dependent.</p>
<p>
<strong>interleave-granularity=granularity</strong> sets the granularity of
interleave. Default 256 (bytes). Only 256, 512, 1k, 2k, 4k, 8k and
16k granularities supported.</p>
<p>
Example:</p>
<blockquote>
<pre class="example">
-machine cxl-fmw.0.targets.0=cxl.0,cxl-fmw.0.targets.1=cxl.1,cxl-fmw.0.size=128G,cxl-fmw.0.interleave-granularity=512
</pre>
</blockquote>
</dd>
</dl>
</dd>
<dt>
<strong><strong>sgx-epc.0.memdev=@var{memid},sgx-epc.0.node=@var{numaid}</strong></strong>
</dt>
<dd>Define
an SGX EPC section.</dd>
<dt>
<strong>*-cpu</strong> model*
</dt>
<dd>Select CPU model (<strong>-cpu help</strong> for list and
additional feature selection)</dd>
<dt>
<strong>*-accel</strong> name[,prop=value[,…]]*
</dt>
<dd>
<p>This is used to enable an
accelerator. Depending on the target architecture, kvm, xen, hvf,
nvmm, whpx or tcg can be available. By default, tcg is used. If there
is more than one accelerator specified, the next one is used if the
previous one fails to initialize.</p>
<dl>
<dt>
<strong><strong>igd-passthru=on|off</strong></strong>
</dt>
<dd>When Xen is in use, this option controls
whether Intel integrated graphics devices can be passed through to
the guest (default=off)</dd>
<dt>
<strong><strong>kernel-irqchip=on|off|split</strong></strong>
</dt>
<dd>Controls KVM in-kernel irqchip
support. The default is full acceleration of the interrupt
controllers. On x86, split irqchip reduces the kernel attack
surface, at a performance cost for non-MSI interrupts. Disabling the
in-kernel irqchip completely is not recommended except for debugging
purposes.</dd>
<dt>
<strong><strong>kvm-shadow-mem=size</strong></strong>
</dt>
<dd>Defines the size of the KVM shadow MMU.</dd>
<dt>
<strong><strong>one-insn-per-tb=on|off</strong></strong>
</dt>
<dd>Makes the TCG accelerator put only one
guest instruction into each translation block. This slows down
emulation a lot, but can be useful in some situations, such as when
trying to analyse the logs produced by the <strong>-d</strong> option.</dd>
<dt>
<strong><strong>split-wx=on|off</strong></strong>
</dt>
<dd>Controls the use of split w^x mapping for the
TCG code generation buffer. Some operating systems require this to
be enabled, and in such a case this will default on. On other
operating systems, this will default off, but one may enable this
for testing or debugging.</dd>
<dt>
<strong><strong>tb-size=n</strong></strong>
</dt>
<dd>Controls the size (in MiB) of the TCG translation
block cache.</dd>
<dt>
<strong><strong>thread=single|multi</strong></strong>
</dt>
<dd>Controls number of TCG threads. When the
TCG is multi-threaded there will be one thread per vCPU therefore
taking advantage of additional host cores. The default is to enable
multi-threading where both the back-end and front-ends support it
and no incompatible TCG features have been enabled (e.g.
icount/replay).</dd>
<dt>
<strong><strong>dirty-ring-size=n</strong></strong>
</dt>
<dd>When the KVM accelerator is used, it
controls the size of the per-vCPU dirty page ring buffer (number of
entries for each vCPU). It should be a value that is power of two,
and it should be 1024 or bigger (but still less than the maximum
value that the kernel supports). 4096 could be a good initial value
if you have no idea which is the best. Set this value to 0 to
disable the feature. By default, this feature is disabled
(dirty-ring-size=0). When enabled, KVM will instead record dirty
pages in a bitmap.</dd>
<dt>
<strong><strong>eager-split-size=n</strong></strong>
</dt>
<dd>KVM implements dirty page logging at the
PAGE_SIZE granularity and enabling dirty-logging on a huge-page
requires breaking it into PAGE_SIZE pages in the first place. KVM on
ARM does this splitting lazily by default. There are performance
benefits in doing huge-page split eagerly, especially in situations
where TLBI costs associated with break-before-make sequences are
considerable and also if guest workloads are read intensive. The
size here specifies how many pages to break at a time and needs to
be a valid block size which is 1GB/2MB/4KB, 32MB/16KB and 512MB/64KB
for 4KB/16KB/64KB PAGE_SIZE respectively. Be wary of specifying a
higher size as it will have an impact on the memory. By default,
this feature is disabled (eager-split-size=0).</dd>
<dt>
<strong><strong>notify-vmexit=run|internal-error|disable,notify-window=n</strong></strong>
</dt>
<dd>Enables
or disables notify VM exit support on x86 host and specify the
corresponding notify window to trigger the VM exit if enabled. <strong>run</strong>
option enables the feature. It does nothing and continue if the exit
happens. <strong>internal-error</strong> option enables the feature. It raises a
internal error. <strong>disable</strong> option doesn&#39;t enable the feature. This
feature can mitigate the CPU stuck issue due to event windows don&#39;t
open up for a specified of time (i.e. notify-window). Default:
notify-vmexit=run,notify-window=0.</dd>
<dt>
<strong><strong>device=path</strong></strong>
</dt>
<dd>Sets the path to the KVM device node. Defaults to
<strong>/dev/kvm</strong>. This option can be used to pass the KVM device to use
via a file descriptor by setting the value to <strong>/dev/fdset/NN</strong>.</dd>
</dl>
</dd>
<dt>
?
</dt>
<dd>
<p><strong>*-smp</strong>
[[cpus=]n][,maxcpus=maxcpus][,drawers=drawers][,books=books][,sockets=sockets][,dies=dies][,clusters=clusters][,modules=modules][,cores=cores][,threads=threads]* :: Simulate
a SMP system with &#39;<strong>n</strong>&#39; CPUs initially present on the machine type
board. On boards supporting CPU hotplug, the optional &#39;<strong>maxcpus</strong>&#39;
parameter can be set to enable further CPUs to be added at runtime.
When both parameters are omitted, the maximum number of CPUs will be
calculated from the provided topology members and the initial CPU
count will match the maximum number. When only one of them is given
then the omitted one will be set to its counterpart&#39;s value. Both
parameters may be specified, but the maximum number of CPUs must be
equal to or greater than the initial CPU count. Product of the CPU
topology hierarchy must be equal to the maximum number of CPUs. Both
parameters are subject to an upper limit that is determined by the
specific machine type chosen.</p>
<p>
To control reporting of CPU topology information, values of the
topology parameters can be specified. Machines may only support a
subset of the parameters and different machines may have different
subsets supported which vary depending on capacity of the
corresponding CPU targets. So for a particular machine type board, an
expected topology hierarchy can be defined through the supported
sub-option. Unsupported parameters can also be provided in addition to
the sub-option, but their values must be set as 1 in the purpose of
correct parsing.</p>
<p>
Either the initial CPU count, or at least one of the topology
parameters must be specified. The specified parameters must be greater
than zero, explicit configuration like &#34;cpus=0&#34; is not allowed. Values
for any omitted parameters will be computed from those which are
given.</p>
<p>
For example, the following sub-option defines a CPU topology hierarchy
(2 sockets totally on the machine, 2 cores per socket, 2 threads per
core) for a machine that only supports sockets/cores/threads. Some
members of the option can be omitted but their values will be
automatically computed:</p>
<blockquote>
<pre class="example">
-smp 8,sockets=2,cores=2,threads=2,maxcpus=8
</pre>
</blockquote>
</dd>
</dl>
<p>The following sub-option defines a CPU topology hierarchy (2 sockets
totally on the machine, 2 dies per socket, 2 modules per die, 2 cores
per module, 2 threads per core) for PC machines which support
sockets/dies /modules/cores/threads. Some members of the option can be
omitted but their values will be automatically computed:</p>
<blockquote>
<blockquote>
<pre class="example">
-smp 32,sockets=2,dies=2,modules=2,cores=2,threads=2,maxcpus=32
</pre>
</blockquote>
</blockquote>
<p>
The following sub-option defines a CPU topology hierarchy (2 sockets
totally on the machine, 2 clusters per socket, 2 cores per cluster, 2
threads per core) for ARM virt machines which support sockets/clusters
/cores/threads. Some members of the option can be omitted but their
values will be automatically computed:</p>
<blockquote>
<blockquote>
<pre class="example">
-smp 16,sockets=2,clusters=2,cores=2,threads=2,maxcpus=16
</pre>
</blockquote>
</blockquote>
<p>
Historically preference was given to the coarsest topology parameters
when computing missing values (ie sockets preferred over cores, which
were preferred over threads), however, this behaviour is considered
liable to change. Prior to 6.2 the preference was sockets over cores
over threads. Since 6.2 the preference is cores over sockets over
threads.</p>
<p>
For example, the following option defines a machine board with 2 sockets
of 1 core before 6.2 and 1 socket of 2 cores after 6.2:</p>
<blockquote>
<blockquote>
<pre class="example">
-smp 2
</pre>
</blockquote>
</blockquote>
<p>
Note: The cluster topology will only be generated in ACPI and exposed to
guest if it&#39;s explicitly specified in -smp.</p>
<ul>
<li>
<p><strong>*-numa</strong>
node[,mem=size][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=initiator]* :: - <strong>*-numa</strong>
  node[,memdev=id][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=initiator]* :: - <strong>*-numa</strong>
    dist,src=source,dst=destination,val=distance* :: - <strong>*-numa</strong>
      cpu,node-id=node[,socket-id=x][,core-id=y][,thread-id=z]* :: - <strong>*-numa</strong>
        hmat-lb,initiator=node,target=node,hierarchy=hierarchy,data-type=type[,latency=lat][,bandwidth=bw]* :: - <strong>*-numa</strong>
          hmat-cache,node-id=node,size=size,level=level[,associativity=str][,policy=str][,line=size]* :: Define
          a NUMA node and assign RAM and VCPUs to it. Set the NUMA
          distance from a source node to a destination node. Set the
          ACPI Heterogeneous Memory Attributes for the given nodes.</p>
<p>
          Legacy VCPU assignment uses &#39;<strong>cpus</strong>&#39; option where firstcpu
          and lastcpu are CPU indexes. Each &#39;<strong>cpus</strong>&#39; option represent
          a contiguous range of CPU indexes (or a single VCPU if
          lastcpu is omitted). A non-contiguous set of VCPUs can be
          represented by providing multiple &#39;<strong>cpus</strong>&#39; options. If
          &#39;<strong>cpus</strong>&#39; is omitted on all nodes, VCPUs are automatically
          split between them.</p>
<p>
          For example, the following option assigns VCPUs 0, 1, 2 and
          5 to a NUMA node:</p>
<blockquote>
<pre class="example">
-numa node,cpus=0-2,cpus=5
</pre>
</blockquote>
</li>
</ul>
<p>&#39;<strong>cpu</strong>&#39; option is a new alternative to &#39;<strong>cpus</strong>&#39; option which uses
&#39;<strong>socket-id|core-id|thread-id</strong>&#39; properties to assign CPU objects to a
node using topology layout properties of CPU. The set of properties is
machine specific, and depends on used machine type/&#39;<strong>smp</strong>&#39; options. It
could be queried with &#39;<strong>hotpluggable-cpus</strong>&#39; monitor command. &#39;<strong>node-id</strong>&#39;
property specifies node to which CPU object will be assigned, it&#39;s
required for node to be declared with &#39;<strong>node</strong>&#39; option before it&#39;s used
with &#39;<strong>cpu</strong>&#39; option.</p>
<p>
For example:</p>
<blockquote>
<blockquote>
<pre class="example">
-M pc \
-smp 1,sockets=2,maxcpus=2 \
-numa node,nodeid=0 -numa node,nodeid=1 \
-numa cpu,node-id=0,socket-id=0 -numa cpu,node-id=1,socket-id=1
</pre>
</blockquote>
</blockquote>
<p>
&#39;<strong>memdev</strong>&#39; option assigns RAM from a given memory backend device to a
node. It is recommended to use &#39;<strong>memdev</strong>&#39; option over legacy &#39;<strong>mem</strong>&#39;
option. This is because &#39;<strong>memdev</strong>&#39; option provides better performance
and more control over the backend&#39;s RAM (e.g. &#39;<strong>prealloc</strong>&#39; parameter of
&#39;<strong>-memory-backend-ram</strong>&#39; allows memory preallocation).</p>
<p>
For compatibility reasons, legacy &#39;<strong>mem</strong>&#39; option is supported in 5.0 and
older machine types. Note that &#39;<strong>mem</strong>&#39; and &#39;<strong>memdev</strong>&#39; are mutually
exclusive. If one node uses &#39;<strong>memdev</strong>&#39;, the rest nodes have to use
&#39;<strong>memdev</strong>&#39; option, and vice versa.</p>
<p>
Users must specify memory for all NUMA nodes by &#39;<strong>memdev</strong>&#39; (or legacy
&#39;<strong>mem</strong>&#39; if available). In QEMU 5.2, the support for &#39;<strong>-numa node</strong>&#39;
without memory specified was removed.</p>
<p>
&#39;<strong>initiator</strong>&#39; is an additional option that points to an initiator NUMA
node that has best performance (the lowest latency or largest bandwidth)
to this NUMA node. Note that this option can be set only when the
machine property &#39;hmat&#39; is set to &#39;on&#39;.</p>
<p>
Following example creates a machine with 2 NUMA nodes, node 0 has CPU.
node 1 has only memory, and its initiator is node 0. Note that because
node 0 has CPU, by default the initiator of node 0 is itself and must be
itself.</p>
<blockquote>
<blockquote>
<pre class="example">
-machine hmat=on \
-m 2G,slots=2,maxmem=4G \
-object memory-backend-ram,size=1G,id=m0 \
-object memory-backend-ram,size=1G,id=m1 \
-numa node,nodeid=0,memdev=m0 \
-numa node,nodeid=1,memdev=m1,initiator=0 \
-smp 2,sockets=2,maxcpus=2  \
-numa cpu,node-id=0,socket-id=0 \
-numa cpu,node-id=0,socket-id=1
</pre>
</blockquote>
</blockquote>
<p>
source and destination are NUMA node IDs. distance is the NUMA distance
from source to destination. The distance from a node to itself is
always 10. If any pair of nodes is given a distance, then all pairs must
be given distances. Although, when distances are only given in one
direction for each pair of nodes, then the distances in the opposite
directions are assumed to be the same. If, however, an asymmetrical pair
of distances is given for even one node pair, then all node pairs must
be provided distance values for both directions, even when they are
symmetrical. When a node is unreachable from another node, set the
pair&#39;s distance to 255.</p>
<p>
Note that the -<strong>numa</strong> option doesn&#39;t allocate any of the specified
resources, it just assigns existing resources to NUMA nodes. This means
that one still has to use the <strong>-m</strong>, <strong>-smp</strong> options to allocate RAM and
VCPUs respectively.</p>
<p>
Use &#39;<strong>hmat-lb</strong>&#39; to set System Locality Latency and Bandwidth Information
between initiator and target NUMA nodes in ACPI Heterogeneous Attribute
Memory Table (HMAT). Initiator NUMA node can create memory requests,
usually it has one or more processors. Target NUMA node contains
addressable memory.</p>
<p>
In &#39;<strong>hmat-lb</strong>&#39; option, node are NUMA node IDs. hierarchy is the memory
hierarchy of the target NUMA node: if hierarchy is &#39;memory&#39;, the
structure represents the memory performance; if hierarchy is
&#39;first-level|second-level|third-level&#39;, this structure represents
aggregated performance of memory side caches for each domain. type of
&#39;data-type&#39; is type of data represented by this structure instance: if
&#39;hierarchy&#39; is &#39;memory&#39;, &#39;data-type&#39; is &#39;access|read|write&#39; latency or
&#39;access|read|write&#39; bandwidth of the target memory; if &#39;hierarchy&#39; is
&#39;first-level|second-level|third-level&#39;, &#39;data-type&#39; is
&#39;access|read|write&#39; hit latency or &#39;access|read|write&#39; hit bandwidth of
the target memory side cache.</p>
<p>
lat is latency value in nanoseconds. bw is bandwidth value, the possible
value and units are NUM[M|G|T], mean that the bandwidth value are NUM
byte per second (or MB/s, GB/s or TB/s depending on used suffix). Note
that if latency or bandwidth value is 0, means the corresponding latency
or bandwidth information is not provided.</p>
<p>
In &#39;<strong>hmat-cache</strong>&#39; option, node-id is the NUMA-id of the memory belongs.
size is the size of memory side cache in bytes. level is the cache level
described in this structure, note that the cache level 0 should not be
used with &#39;<strong>hmat-cache</strong>&#39; option. associativity is the cache
associativity, the possible value is
&#39;none/direct(direct-mapped)/complex(complex cache indexing)&#39;. policy is
the write policy. line is the cache Line size in bytes.</p>
<p>
For example, the following options describe 2 NUMA nodes. Node 0 has 2
cpus and a ram, node 1 has only a ram. The processors in node 0 access
memory in node 0 with access-latency 5 nanoseconds, access-bandwidth is
200 MB/s; The processors in NUMA node 0 access memory in NUMA node 1
with access-latency 10 nanoseconds, access-bandwidth is 100 MB/s. And
for memory side cache information, NUMA node 0 and 1 both have 1 level
memory cache, size is 10KB, policy is write-back, the cache Line size is
8 bytes:</p>
<blockquote>
<blockquote>
<pre class="example">
-machine hmat=on \
-m 2G \
-object memory-backend-ram,size=1G,id=m0 \
-object memory-backend-ram,size=1G,id=m1 \
-smp 2,sockets=2,maxcpus=2 \
-numa node,nodeid=0,memdev=m0 \
-numa node,nodeid=1,memdev=m1,initiator=0 \
-numa cpu,node-id=0,socket-id=0 \
-numa cpu,node-id=0,socket-id=1 \
-numa hmat-lb,initiator=0,target=0,hierarchy=memory,data-type=access-latency,latency=5 \
-numa hmat-lb,initiator=0,target=0,hierarchy=memory,data-type=access-bandwidth,bandwidth=200M \
-numa hmat-lb,initiator=0,target=1,hierarchy=memory,data-type=access-latency,latency=10 \
-numa hmat-lb,initiator=0,target=1,hierarchy=memory,data-type=access-bandwidth,bandwidth=100M \
-numa hmat-cache,node-id=0,size=10K,level=1,associativity=direct,policy=write-back,line=8 \
-numa hmat-cache,node-id=1,size=10K,level=1,associativity=direct,policy=write-back,line=8
</pre>
</blockquote>
</blockquote>
<dl>
<dt>
<strong>*-add-fd</strong> fd=fd,set=set[,opaque=opaque]*
</dt>
<dd>
<p>Add a file descriptor to
an fd set. Valid options are:</p>
<dl>
<dt>
<strong><strong>fd=fd</strong></strong>
</dt>
<dd>This option defines the file descriptor of which a
duplicate is added to fd set. The file descriptor cannot be stdin,
stdout, or stderr.</dd>
<dt>
<strong><strong>set=set</strong></strong>
</dt>
<dd>This option defines the ID of the fd set to add the
file descriptor to.</dd>
<dt>
<strong><strong>opaque=opaque</strong></strong>
</dt>
<dd>This option defines a free-form string that can
be used to describe fd.</dd>
</dl>
</dd>
</dl>
<p>You can open an image using pre-opened file descriptors from an fd set:</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 \
 -add-fd fd=3,set=2,opaque=&#34;rdwr:/path/to/file&#34; \
 -add-fd fd=4,set=2,opaque=&#34;rdonly:/path/to/file&#34; \
 -drive file=/dev/fdset/2,index=0,media=disk
</pre>
</blockquote>
</blockquote>
<dl>
<dt>
<strong>*-set</strong> group.id.arg=value*
</dt>
<dd>Set parameter arg for item id of type
group</dd>
<dt>
<strong>*-global</strong> driver.prop=value*
</dt>
<dd>
<ul>
<li>
<p><strong>*-global</strong>
 driver=driver,property=property,value=value* :: Set default value of
 driver&#39;s property prop to value, e.g.:</p>
<blockquote>
<pre class="example">
qemu-system-x86_64 -global ide-hd.physical_block_size=4096 disk-image.img
</pre>
</blockquote>
</li>
</ul>
</dd>
</dl>
<p>In particular, you can use this to set driver properties for devices
which are created automatically by the machine model. To create a device
which is not created automatically and set properties on it,
use -<strong>device</strong>.</p>
<p>
-global driver.prop=value is shorthand for -global
driver=driver,property=prop,value=value. The longhand syntax works even
when driver contains a dot.</p>
<ul>
<li>
<p><strong>*-boot</strong>
[order=drives][,once=drives][,menu=on|off][,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_timeout][,strict=on|off]* :: Specify
boot order drives as a string of drive letters. Valid drive letters
depend on the target architecture. The x86 PC uses: a, b (floppy 1 and
2), c (first hard disk), d (first CD-ROM), n-p (Etherboot from network
adapter 1-4), hard disk boot is the default. To apply a particular
boot order only on the first startup, specify it via <strong>once</strong>. Note that
the <strong>order</strong> or <strong>once</strong> parameter should not be used together with the
<strong>bootindex</strong> property of devices, since the firmware implementations
normally do not support both at the same time.</p>
<p>
Interactive boot menus/prompts can be enabled via <strong>menu=on</strong> as far as
firmware/BIOS supports them. The default is non-interactive boot.</p>
<p>
A splash picture could be passed to bios, enabling user to show it as
logo, when option splash=sp_name is given and menu=on, If
firmware/BIOS supports them. Currently Seabios for X86 system support
it. limitation: The splash file could be a jpeg file or a BMP file in
24 BPP format(true color). The resolution should be supported by the
SVGA mode, so the recommended is 320x240, 640x480, 800x640.</p>
<p>
A timeout could be passed to bios, guest will pause for rb_timeout ms
when boot failed, then reboot. If rb_timeout is &#39;-1&#39;, guest will not
reboot, qemu passes &#39;-1&#39; to bios by default. Currently Seabios for X86
system support it.</p>
<p>
Do strict boot via <strong>strict=on</strong> as far as firmware/BIOS supports it.
This only effects when boot priority is changed by bootindex options.
The default is non-strict boot.</p>
<blockquote>
<pre class="example">
# try to boot from network first, then from hard disk
qemu-system-x86_64 -boot order=nc
# boot from CD-ROM first, switch back to default order after reboot
qemu-system-x86_64 -boot once=d
# boot with a splash picture for 5 seconds.
qemu-system-x86_64 -boot menu=on,splash=/root/boot.bmp,splash-time=5000
</pre>
</blockquote>
</li>
</ul>
<p>Note: The legacy format &#39;-boot drives&#39; is still supported but its use is
discouraged as it may be removed from future versions.</p>
<dl>
<dt>
<strong>*-m</strong> [size=]megs[,slots=n,maxmem=size]*
</dt>
<dd>
<p>Sets guest startup RAM
size to megs megabytes. Default is 128 MiB. Optionally, a suffix of
&#34;M&#34; or &#34;G&#34; can be used to signify a value in megabytes or gigabytes
respectively. Optional pair slots, maxmem could be used to set amount
of hotpluggable memory slots and maximum amount of memory. Note that
maxmem must be aligned to the page size.</p>
<p>
For example, the following command-line sets the guest startup RAM
size to 1GB, creates 3 slots to hotplug additional memory and sets the
maximum memory the guest can reach to 4GB:</p>
<blockquote>
<pre class="example">
qemu-system-x86_64 -m 1G,slots=3,maxmem=4G
</pre>
</blockquote>
</dd>
</dl>
<p>If slots and maxmem are not specified, memory hotplug won&#39;t be enabled
and the guest startup RAM will never increase.</p>
<dl>
<dt>
<strong>*-mem-path</strong> path*
</dt>
<dd>Allocate guest RAM from a temporarily created
file in path.</dd>
<dt>
<strong><strong>-mem-prealloc</strong></strong>
</dt>
<dd>Preallocate memory when using -mem-path.</dd>
<dt>
<strong>*-k</strong> language*
</dt>
<dd>
<p>Use keyboard layout language (for example <strong>fr</strong> for
French). This option is only needed where it is not easy to get raw PC
keycodes (e.g. on Macs, with some X11 servers or with a VNC or curses
display). You don&#39;t normally need to use it on PC/Linux or PC/Windows
hosts.</p>
<p>
The available layouts are:</p>
<blockquote>
<pre class="example">
ar  de-ch  es  fo     fr-ca  hu  ja  mk     no  pt-br  sv
da  en-gb  et  fr     fr-ch  is  lt  nl     pl  ru     th
de  en-us  fi  fr-be  hr     it  lv  nl-be  pt  sl     tr
</pre>
</blockquote>
</dd>
</dl>
<p>The default is <strong>en-us</strong>.</p>
<dl>
<dt>
<strong>*-audio</strong> [driver=]driver[,model=value][,prop[=value][,…]]*
</dt>
<dd>
<p>If
the <strong>model</strong> option is specified, <strong>-audio</strong> is a shortcut for
configuring both the guest audio hardware and the host audio backend
in one go. The guest hardware model can be set with <strong>model=modelname</strong>.
Use <strong>model=help</strong> to list the available device types.</p>
<p>
The following two example do exactly the same, to show how <strong>-audio</strong>
can be used to shorten the command line length:</p>
<blockquote>
<pre class="example">
qemu-system-x86_64 -audiodev pa,id=pa -device sb16,audiodev=pa
qemu-system-x86_64 -audio pa,model=sb16
</pre>
</blockquote>
</dd>
</dl>
<p>If the <strong>model</strong> option is not specified, <strong>-audio</strong> is used to configure a
default audio backend that will be used whenever the <strong>audiodev</strong> property
is not set on a device or machine. In particular, <strong>-audio none</strong> ensures
that no audio is produced even for machines that have embedded sound
hardware.</p>
<p>
In both cases, the driver option is the same as with the corresponding
<strong>-audiodev</strong> option below. Use <strong>driver=help</strong> to list the available
drivers.</p>
<dl>
<dt>
<strong>*-audiodev</strong> [driver=]driver,id=id[,prop[=value][,…]]*
</dt>
<dd>
<p>Adds a new
audio backend driver identified by id. There are global and driver
specific properties. Some values can be set differently for input and
output, they&#39;re marked with <strong>in|out.</strong>. You can set the input&#39;s
property with <strong>in.prop</strong> and the output&#39;s property with <strong>out.prop</strong>. For
example:</p>
<blockquote>
<pre class="example">
-audiodev alsa,id=example,in.frequency=44110,out.frequency=8000
-audiodev alsa,id=example,out.channels=1 # leaves in.channels unspecified
</pre>
</blockquote>
</dd>
</dl>
<p>NOTE: parameter validation is known to be incomplete, in many cases
specifying an invalid option causes QEMU to print an error message and
continue emulation without sound.</p>
<p>
Valid global options are:</p>
<blockquote>
<dl>
<dt>
<strong><strong>id=identifier</strong></strong>
</dt>
<dd>Identifies the audio backend.</dd>
<dt>
<strong><strong>timer-period=period</strong></strong>
</dt>
<dd>Sets the timer period used by the audio
subsystem in microseconds. Default is 10000 (10 ms).</dd>
<dt>
<strong><strong>in|out.mixing-engine=on|off</strong></strong>
</dt>
<dd>Use QEMU&#39;s mixing engine to mix all
streams inside QEMU and convert audio formats when not supported by
the backend. When off, fixed-settings must be off too. Note that
disabling this option means that the selected backend must support
multiple streams and the audio formats used by the virtual cards,
otherwise you&#39;ll get no sound. It&#39;s not recommended to disable this
option unless you want to use 5.1 or 7.1 audio, as mixing engine only
supports mono and stereo audio. Default is on.</dd>
<dt>
<strong><strong>in|out.fixed-settings=on|off</strong></strong>
</dt>
<dd>Use fixed settings for host audio.
When off, it will change based on how the guest opens the sound card.
In this case you must not specify frequency, channels or format.
Default is on.</dd>
<dt>
<strong><strong>in|out.frequency=frequency</strong></strong>
</dt>
<dd>Specify the frequency to use when
using fixed-settings. Default is 44100Hz.</dd>
<dt>
<strong><strong>in|out.channels=channels</strong></strong>
</dt>
<dd>Specify the number of channels to use
when using fixed-settings. Default is 2 (stereo).</dd>
<dt>
<strong><strong>in|out.format=format</strong></strong>
</dt>
<dd>Specify the sample format to use when
using fixed-settings. Valid values are: <strong>s8</strong>, <strong>s16</strong>, <strong>s32</strong>, <strong>u8</strong>,
<strong>u16</strong>, <strong>u32</strong>, <strong>f32</strong>. Default is <strong>s16</strong>.</dd>
<dt>
<strong><strong>in|out.voices=voices</strong></strong>
</dt>
<dd>Specify the number of voices to use.
Default is 1.</dd>
<dt>
<strong><strong>in|out.buffer-length=usecs</strong></strong>
</dt>
<dd>Sets the size of the buffer in
microseconds.</dd>
</dl>
</blockquote>
<dl>
<dt>
<strong>*-audiodev</strong> none,id=id[,prop[=value][,…]]*
</dt>
<dd>Creates a dummy
backend that discards all outputs. This backend has no backend
specific properties.</dd>
<dt>
<strong>*-audiodev</strong> alsa,id=id[,prop[=value][,…]]*
</dt>
<dd>
<p>Creates backend using
the ALSA. This backend is only available on Linux.</p>
<p>
ALSA specific options are:</p>
<dl>
<dt>
<strong><strong>in|out.dev=device</strong></strong>
</dt>
<dd>Specify the ALSA device to use for input
and/or output. Default is <strong>default</strong>.</dd>
<dt>
<strong><strong>in|out.period-length=usecs</strong></strong>
</dt>
<dd>Sets the period length in
microseconds.</dd>
<dt>
<strong><strong>in|out.try-poll=on|off</strong></strong>
</dt>
<dd>Attempt to use poll mode with the
device. Default is on.</dd>
<dt>
<strong><strong>threshold=threshold</strong></strong>
</dt>
<dd>Threshold (in microseconds) when playback
starts. Default is 0.</dd>
</dl>
</dd>
<dt>
<strong>*-audiodev</strong> coreaudio,id=id[,prop[=value][,…]]*
</dt>
<dd>
<p>Creates a
backend using Apple&#39;s Core Audio. This backend is only available on
Mac OS and only supports playback.</p>
<p>
Core Audio specific options are:</p>
<dl>
<dt>
<strong><strong>in|out.buffer-count=count</strong></strong>
</dt>
<dd>Sets the count of the buffers.</dd>
</dl>
</dd>
<dt>
<strong>*-audiodev</strong> dsound,id=id[,prop[=value][,…]]*
</dt>
<dd>
<p>Creates a backend
using Microsoft&#39;s DirectSound. This backend is only available on
Windows and only supports playback.</p>
<p>
DirectSound specific options are:</p>
<dl>
<dt>
<strong><strong>latency=usecs</strong></strong>
</dt>
<dd>Add extra usecs microseconds latency to
playback. Default is 10000 (10 ms).</dd>
</dl>
</dd>
<dt>
<strong>*-audiodev</strong> oss,id=id[,prop[=value][,…]]*
</dt>
<dd>
<p>Creates a backend
using OSS. This backend is available on most Unix-like systems.</p>
<p>
OSS specific options are:</p>
<dl>
<dt>
<strong><strong>in|out.dev=device</strong></strong>
</dt>
<dd>Specify the file name of the OSS device to
use. Default is <strong>/dev/dsp</strong>.</dd>
<dt>
<strong><strong>in|out.buffer-count=count</strong></strong>
</dt>
<dd>Sets the count of the buffers.</dd>
<dt>
<strong><strong>in|out.try-poll=on|of</strong></strong>
</dt>
<dd>Attempt to use poll mode with the
device. Default is on.</dd>
<dt>
<strong><strong>try-mmap=on|off</strong></strong>
</dt>
<dd>Try using memory mapped device access.
Default is off.</dd>
<dt>
<strong><strong>exclusive=on|off</strong></strong>
</dt>
<dd>Open the device in exclusive mode (vmix
won&#39;t work in this case). Default is off.</dd>
<dt>
<strong><strong>dsp-policy=policy</strong></strong>
</dt>
<dd>Sets the timing policy (between 0 and 10,
where smaller number means smaller latency but higher CPU usage).
Use -1 to use buffer sizes specified by <strong>buffer</strong> and <strong>buffer-count</strong>.
This option is ignored if you do not have OSS 4. Default is 5.</dd>
</dl>
</dd>
<dt>
<strong>*-audiodev</strong> pa,id=id[,prop[=value][,…]]*
</dt>
<dd>
<p>Creates a backend using
PulseAudio. This backend is available on most systems.</p>
<p>
PulseAudio specific options are:</p>
<dl>
<dt>
<strong><strong>server=server</strong></strong>
</dt>
<dd>Sets the PulseAudio server to connect to.</dd>
<dt>
<strong><strong>in|out.name=sink</strong></strong>
</dt>
<dd>Use the specified source/sink for
recording/playback.</dd>
<dt>
<strong><strong>in|out.latency=usecs</strong></strong>
</dt>
<dd>Desired latency in microseconds. The
PulseAudio server will try to honor this value but actual latencies
may be lower or higher.</dd>
</dl>
</dd>
<dt>
<strong>*-audiodev</strong> pipewire,id=id[,prop[=value][,…]]*
</dt>
<dd>
<p>Creates a backend
using PipeWire. This backend is available on most systems.</p>
<p>
PipeWire specific options are:</p>
<dl>
<dt>
<strong><strong>in|out.latency=usecs</strong></strong>
</dt>
<dd>Desired latency in microseconds.</dd>
<dt>
<strong><strong>in|out.name=sink</strong></strong>
</dt>
<dd>Use the specified source/sink for
recording/playback.</dd>
<dt>
<strong><strong>in|out.stream-name</strong></strong>
</dt>
<dd>Specify the name of pipewire stream.</dd>
</dl>
</dd>
<dt>
<strong>*-audiodev</strong> sdl,id=id[,prop[=value][,…]]*
</dt>
<dd>
<p>Creates a backend
using SDL. This backend is available on most systems, but you should
use your platform&#39;s native backend if possible.</p>
<p>
SDL specific options are:</p>
<dl>
<dt>
<strong><strong>in|out.buffer-count=count</strong></strong>
</dt>
<dd>Sets the count of the buffers.</dd>
</dl>
</dd>
<dt>
<strong>*-audiodev</strong> sndio,id=id[,prop[=value][,…]]*
</dt>
<dd>
<p>Creates a backend
using SNDIO. This backend is available on OpenBSD and most other
Unix-like systems.</p>
<p>
Sndio specific options are:</p>
<dl>
<dt>
<strong><strong>in|out.dev=device</strong></strong>
</dt>
<dd>Specify the sndio device to use for input
and/or output. Default is <strong>default</strong>.</dd>
<dt>
<strong><strong>in|out.latency=usecs</strong></strong>
</dt>
<dd>Sets the desired period length in
microseconds.</dd>
</dl>
</dd>
<dt>
<strong>*-audiodev</strong> spice,id=id[,prop[=value][,…]]*
</dt>
<dd>Creates a backend
that sends audio through SPICE. This backend requires <strong>-spice</strong> and
automatically selected in that case, so usually you can ignore this
option. This backend has no backend specific properties.</dd>
<dt>
<strong>*-audiodev</strong> wav,id=id[,prop[=value][,…]]*
</dt>
<dd>
<p>Creates a backend that
writes audio to a WAV file.</p>
<p>
Backend specific options are:</p>
<dl>
<dt>
<strong><strong>path=path</strong></strong>
</dt>
<dd>Write recorded audio into the specified file.
Default is <strong>qemu.wav</strong>.</dd>
</dl>
</dd>
<dt>
<strong>*-device</strong> driver[,prop[=value][,…]]*
</dt>
<dd>Add device driver.
prop=value sets driver properties. Valid properties depend on the
driver. To get help on possible drivers and properties, use <strong>-device
help</strong> and <strong>-device driver,help</strong>.

Some drivers are:</dd>
<dt>
<strong>*-device</strong> ipmi-bmc-sim,id=id[,prop[=value][,…]]*
</dt>
<dd>
<p>Add an IPMI
BMC. This is a simulation of a hardware management interface processor
that normally sits on a system. It provides a watchdog and the ability
to reset and power control the system. You need to connect this to an
IPMI interface to make it useful</p>
<p>
The IPMI slave address to use for the BMC. The default is 0x20. This
address is the BMC&#39;s address on the I2C network of management
controllers. If you don&#39;t know what this means, it is safe to ignore
it.</p>
<dl>
<dt>
<strong><strong>id=id</strong></strong>
</dt>
<dd>The BMC id for interfaces to use this device.</dd>
<dt>
<strong><strong>slave_addr=val</strong></strong>
</dt>
<dd>Define slave address to use for the BMC. The
default is 0x20.</dd>
<dt>
<strong><strong>sdrfile=file</strong></strong>
</dt>
<dd>file containing raw Sensor Data Records (SDR)
data. The default is none.</dd>
<dt>
<strong><strong>fruareasize=val</strong></strong>
</dt>
<dd>size of a Field Replaceable Unit (FRU) area.
The default is 1024.</dd>
<dt>
<strong><strong>frudatafile=file</strong></strong>
</dt>
<dd>file containing raw Field Replaceable Unit
(FRU) inventory data. The default is none.</dd>
<dt>
<strong><strong>guid=uuid</strong></strong>
</dt>
<dd>value for the GUID for the BMC, in standard UUID
format. If this is set, get &#34;Get GUID&#34; command to the BMC will
return it. Otherwise &#34;Get GUID&#34; will return an error.</dd>
</dl>
</dd>
<dt>
<strong>*-device</strong> ipmi-bmc-extern,id=id,chardev=id[,slave_addr=val]*
</dt>
<dd>Add a
connection to an external IPMI BMC simulator. Instead of locally
emulating the BMC like the above item, instead connect to an external
entity that provides the IPMI services.

A connection is made to an external BMC simulator. If you do this, it
is strongly recommended that you use the &#34;reconnect=&#34; chardev option
to reconnect to the simulator if the connection is lost. Note that if
this is not used carefully, it can be a security issue, as the
interface has the ability to send resets, NMIs, and power off the VM.
It&#39;s best if QEMU makes a connection to an external simulator running
on a secure port on localhost, so neither the simulator nor QEMU is
exposed to any outside network.

See the &#34;lanserv/README.vm&#34; file in the OpenIPMI library for more
details on the external interface.</dd>
<dt>
<strong>*-device</strong> isa-ipmi-kcs,bmc=id[,ioport=val][,irq=val]*
</dt>
<dd>
<p>Add a KCS
IPMI interface on the ISA bus. This also adds a corresponding ACPI and
SMBIOS entries, if appropriate.</p>
<dl>
<dt>
<strong><strong>bmc=id</strong></strong>
</dt>
<dd>The BMC to connect to, one of ipmi-bmc-sim or
ipmi-bmc-extern above.</dd>
<dt>
<strong><strong>ioport=val</strong></strong>
</dt>
<dd>Define the I/O address of the interface. The
default is 0xca0 for KCS.</dd>
<dt>
<strong><strong>irq=val</strong></strong>
</dt>
<dd>Define the interrupt to use. The default is 5. To
disable interrupts, set this to 0.</dd>
</dl>
</dd>
<dt>
<strong>*-device</strong> isa-ipmi-bt,bmc=id[,ioport=val][,irq=val]*
</dt>
<dd>Like the KCS
interface, but defines a BT interface. The default port is 0xe4 and
the default interrupt is 5.</dd>
<dt>
<strong>*-device</strong> pci-ipmi-kcs,bmc=id*
</dt>
<dd>
<p>Add a KCS IPMI interface on the PCI
bus.</p>
<dl>
<dt>
<strong><strong>bmc=id</strong></strong>
</dt>
<dd>The BMC to connect to, one of ipmi-bmc-sim or
ipmi-bmc-extern above.</dd>
</dl>
</dd>
<dt>
<strong>*-device</strong> pci-ipmi-bt,bmc=id*
</dt>
<dd>Like the KCS interface, but defines
a BT interface on the PCI bus.</dd>
<dt>
<strong>*-device</strong> intel-iommu[,option=…]*
</dt>
<dd>
<p>This is only supported by
<strong>-machine q35</strong>, which will enable Intel VT-d emulation within the
guest. It supports below options:</p>
<dl>
<dt>
<strong>*intremap=on|off</strong> (default: auto)*
</dt>
<dd>This enables interrupt
remapping feature. It&#39;s required to enable complete x2apic.
Currently it only supports kvm kernel-irqchip modes <strong>off</strong> or
<strong>split</strong>, while full kernel-irqchip is not yet supported. The default
value is &#34;auto&#34;, which will be decided by the mode of
kernel-irqchip.</dd>
<dt>
<strong>*caching-mode=on|off</strong> (default: off)*
</dt>
<dd>This enables caching mode
for the VT-d emulated device. When caching-mode is enabled, each
guest DMA buffer mapping will generate an IOTLB invalidation from
the guest IOMMU driver to the vIOMMU device in a synchronous way. It
is required for <strong>-device vfio-pci</strong> to work with the VT-d device,
because host assigned devices requires to setup the DMA mapping on
the host before guest DMA starts.</dd>
<dt>
<strong>*device-iotlb=on|off</strong> (default: off)*
</dt>
<dd>This enables device-iotlb
capability for the emulated VT-d device. So far virtio/vhost should
be the only real user for this parameter, paired with ats=on
configured for the device.</dd>
<dt>
<strong>*aw-bits=39|48</strong> (default: 39)*
</dt>
<dd>This decides the address width of
IOVA address space. The address space has 39 bits width for 3-level
IOMMU page tables, and 48 bits for 4-level IOMMU page tables.</dd>
</dl>
</dd>
</dl>
<p>Please also refer to the wiki page for general scenarios of VT-d
emulation in QEMU: <em><a href="https://wiki.qemu.org/Features/VT-d">https://wiki.qemu.org/Features/VT-d</a></em>.</p>
<dl>
<dt>
<strong>*-device</strong> virtio-iommu-pci[,option=…]*
</dt>
<dd>
<p>This is only supported by
<strong>-machine q35</strong> (x86_64) and <strong>-machine virt</strong> (ARM). It supports below
options:</p>
<ul>
<li><strong>*granule=val</strong> (possible values are 4k, 8k, 16k, 64k and host;
default: host)* :: This decides the default granule to be be exposed
by the virtio-iommu. If host, the granule matches the host page
size.</li>
<li><strong>*aw-bits=val</strong> (val between 32 and 64, default depends on
machine)* :: This decides the address width of the IOVA address
space.</li>
</ul>
</dd>
<dt>
<strong>*-name</strong> name*
</dt>
<dd>Sets the name of the guest. This name will be
displayed in the SDL window caption. The name will also be used for
the VNC server. Also optionally set the top visible process name in
Linux. Naming of individual threads can also be enabled on Linux to
aid debugging.</dd>
<dt>
<strong>*-uuid</strong> uuid*
</dt>
<dd>Set system UUID.</dd>
</dl>
</blockquote>
</div>
</div>
<div id="outline-container-headline-7" class="outline-3">
<h3 id="headline-7">
Block device options
</h3>
<div id="outline-text-headline-7" class="outline-text-3">
<p>The QEMU block device handling options have a long history and have gone
through several iterations as the feature set and complexity of the
block layer have grown. Many online guides to QEMU often reference older
and deprecated options, which can lead to confusion.</p>
<p>
The most explicit way to describe disks is to use a combination of
<strong>-device</strong> to specify the hardware device and <strong>-blockdev</strong> to describe the
backend. The device defines what the guest sees and the backend
describes how QEMU handles the data. It is the only guaranteed stable
interface for describing block devices and as such is recommended for
management tools and scripting.</p>
<p>
The <strong>-drive</strong> option combines the device and backend into a single
command line option which is a more human friendly. There is however no
interface stability guarantee although some older board models still
need updating to work with the modern blockdev forms.</p>
<p>
Older options like <strong>-hda</strong> are essentially macros which expand into
<strong>-drive</strong> options for various drive interfaces. The original forms bake
in a lot of assumptions from the days when QEMU was emulating a legacy
PC, they are not recommended for modern configurations.</p>
<blockquote>
<dl>
<dt>
<strong>*-fda</strong> file*
</dt>
<dd>
<dl>
<dt>
<strong>*-fdb</strong> file*
</dt>
<dd>
<p>Use file as floppy disk 0/1 image
(see the <em>Disk Images</em> chapter in the System Emulation Users Guide).</p>
<dl>
<dt>
<strong>*-hda</strong> file*
</dt>
<dd>
<dl>
<dt>
<strong>*-hdb</strong> file*
</dt>
<dd>
<dl>
<dt>
<strong>*-hdc</strong> file*
</dt>
<dd>
<ul>
<li>
<p><strong>*-hdd</strong>
   file* :: Use file as hard disk 0, 1, 2 or 3 image on the
   default bus of the emulated machine (this is for example the
   IDE bus on most x86 machines, but it can also be SCSI, virtio
   or something else on other target architectures). See also the
   <em>Disk Images</em> chapter in the System Emulation Users Guide.</p>
<dl>
<dt>
<strong>*-cdrom</strong> file*
</dt>
<dd>Use file as CD-ROM image on the default bus
of the emulated machine (which is IDE1 master on x86, so you
cannot use <strong>-hdc</strong> and <strong>-cdrom</strong> at the same time there). On
systems that support it, you can use the host CD-ROM by using
<strong>/dev/cdrom</strong> as filename.</dd>
<dt>
<strong>*-blockdev</strong> option[,option[,option[,…]]]*
</dt>
<dd>
<p>Define a new
block driver node. Some of the options apply to all block
drivers, other options are only accepted for a specific block
driver. See below for a list of generic options and options
for the most common block drivers.</p>
<p>
Options that expect a reference to another node (e.g. <strong>file</strong>)
can be given in two ways. Either you specify the node name of
an already existing node (file=node-name), or you define a new
node inline, adding options for the referenced node after a
dot (file.filename=path,file.aio=native).</p>
<p>
A block driver node created with <strong>-blockdev</strong> can be used for a
guest device by specifying its node name for the <strong>drive</strong>
property in a <strong>-device</strong> argument that defines a block device.</p>
<dl>
<dt>
<strong>*Valid</strong> options for any block driver node:*
</dt>
<dd>
<blockquote>
<dl>
<dt>
<strong><strong>driver</strong></strong>
</dt>
<dd>Specifies the block driver to use for the
given node.</dd>
<dt>
<strong><strong>node-name</strong></strong>
</dt>
<dd>This defines the name of the block driver
node by which it will be referenced later. The name must
be unique, i.e. it must not match the name of a different
block driver node, or (if you use <strong>-drive</strong> as well) the ID
of a drive.

If no node name is specified, it is automatically
generated. The generated node name is not intended to be
predictable and changes between QEMU invocations. For the
top level, an explicit node name must be specified.</dd>
<dt>
<strong><strong>read-only</strong></strong>
</dt>
<dd>Open the node read-only. Guest write
attempts will fail.

Note that some block drivers support only read-only
access, either generally or in certain configurations. In
this case, the default value <strong>read-only=off</strong> does not work
and the option must be specified explicitly.</dd>
<dt>
<strong><strong>auto-read-only</strong></strong>
</dt>
<dd>If <strong>auto-read-only=on</strong> is set, QEMU
may fall back to read-only usage even when <strong>read-only=off</strong>
is requested, or even switch between modes as needed, e.g.
depending on whether the image file is writable or whether
a writing user is attached to the node.</dd>
<dt>
<strong><strong>force-share</strong></strong>
</dt>
<dd>Override the image locking system of
QEMU by forcing the node to utilize weaker shared access
for permissions where it would normally request exclusive
access. When there is the potential for multiple instances
to have the same file open (whether this invocation of
QEMU is the first or the second instance), both instances
must permit shared access for the second instance to
succeed at opening the file.

Enabling <strong>force-share=on</strong> requires <strong>read-only=on</strong>.</dd>
<dt>
<strong><strong>cache.direct</strong></strong>
</dt>
<dd>The host page cache can be avoided
with <strong>cache.direct=on</strong>. This will attempt to do disk IO
directly to the guest&#39;s memory. QEMU may still perform an
internal copy of the data.</dd>
<dt>
<strong><strong>cache.no-flush</strong></strong>
</dt>
<dd>In case you don&#39;t care about data
integrity over host failures, you can use
<strong>cache.no-flush=on</strong>. This option tells QEMU that it never
needs to write any data to the disk but can instead keep
things in cache. If anything goes wrong, like your host
losing power, the disk storage getting disconnected
accidentally, etc. your image will most probably be
rendered unusable.</dd>
<dt>
<strong><strong>discard=discard</strong></strong>
</dt>
<dd>discard is one of &#34;ignore&#34; (or
&#34;off&#34;) or &#34;unmap&#34; (or &#34;on&#34;) and controls whether <strong>discard</strong>
(also known as <strong>trim</strong> or <strong>unmap</strong>) requests are ignored or
passed to the filesystem. Some machine types may not
support discard requests.</dd>
<dt>
<strong><strong>detect-zeroes=detect-zeroes</strong></strong>
</dt>
<dd>detect-zeroes is &#34;off&#34;,
&#34;on&#34; or &#34;unmap&#34; and enables the automatic conversion of
plain zero writes by the OS to driver specific optimized
zero write commands. You may even choose &#34;unmap&#34; if
discard is set to &#34;unmap&#34; to allow a zero write to be
converted to an <strong>unmap</strong> operation.</dd>
</dl>
</blockquote>
</dd>
<dt>
<strong>*Driver-specific</strong> options for file*
</dt>
<dd>
<p>This is the
protocol-level block driver for accessing regular files.</p>
<dl>
<dt>
<strong><strong>filename</strong></strong>
</dt>
<dd>The path to the image file in the local
filesystem</dd>
<dt>
<strong><strong>aio</strong></strong>
</dt>
<dd>Specifies the AIO backend
(threads/native/io_uring, default: threads)</dd>
<dt>
<strong><strong>locking</strong></strong>
</dt>
<dd>Specifies whether the image file is
protected with Linux OFD / POSIX locks. The default is to
use the Linux Open File Descriptor API if available,
otherwise no lock is applied. (auto/on/off, default: auto)</dd>
</dl>
</dd>
</dl>
<p>Example:</p>
<blockquote>
<blockquote>
<pre class="example">
-blockdev driver=file,node-name=disk,filename=disk.img
</pre>
</blockquote>
</blockquote>
<dl>
<dt>
<strong>*Driver-specific</strong> options for raw*
</dt>
<dd>
<p>This is the image
format block driver for raw images. It is usually stacked on
top of a protocol level block driver such as <strong>file</strong>.</p>
<dl>
<dt>
<strong><strong>file</strong></strong>
</dt>
<dd>Reference to or definition of the data source
block driver node (e.g. a <strong>file</strong> driver node)</dd>
</dl>
</dd>
</dl>
<p>Example 1:</p>
<blockquote>
<blockquote>
<pre class="example">
-blockdev driver=file,node-name=disk_file,filename=disk.img
-blockdev driver=raw,node-name=disk,file=disk_file
</pre>
</blockquote>
</blockquote>
<p>
Example 2:</p>
<blockquote>
<blockquote>
<pre class="example">
-blockdev driver=raw,node-name=disk,file.driver=file,file.filename=disk.img
</pre>
</blockquote>
</blockquote>
<dl>
<dt>
<strong>*Driver-specific</strong> options for qcow2*
</dt>
<dd>
<p>This is the image
format block driver for qcow2 images. It is usually stacked
on top of a protocol level block driver such as <strong>file</strong>.</p>
<dl>
<dt>
<strong><strong>file</strong></strong>
</dt>
<dd>Reference to or definition of the data source
block driver node (e.g. a <strong>file</strong> driver node)</dd>
<dt>
<strong><strong>backing</strong></strong>
</dt>
<dd>Reference to or definition of the backing
file block device (default is taken from the image file).
It is allowed to pass <strong>null</strong> here in order to disable the
default backing file.</dd>
<dt>
<strong><strong>lazy-refcounts</strong></strong>
</dt>
<dd>Whether to enable the lazy refcounts
feature (on/off; default is taken from the image file)</dd>
<dt>
<strong><strong>cache-size</strong></strong>
</dt>
<dd>The maximum total size of the L2 table
and refcount block caches in bytes (default: the sum of
l2-cache-size and refcount-cache-size)</dd>
<dt>
<strong><strong>l2-cache-size</strong></strong>
</dt>
<dd>The maximum size of the L2 table
cache in bytes (default: if cache-size is not specified -
32M on Linux platforms, and 8M on non-Linux platforms;
otherwise, as large as possible within the cache-size,
while permitting the requested or the minimal refcount
cache size)</dd>
<dt>
<strong><strong>refcount-cache-size</strong></strong>
</dt>
<dd>The maximum size of the
refcount block cache in bytes (default: 4 times the
cluster size; or if cache-size is specified, the part of
it which is not used for the L2 cache)</dd>
<dt>
<strong><strong>cache-clean-interval</strong></strong>
</dt>
<dd>Clean unused entries in the L2
and refcount caches. The interval is in seconds. The
default value is 600 on supporting platforms, and 0 on
other platforms. Setting it to 0 disables this feature.</dd>
<dt>
<strong><strong>pass-discard-request</strong></strong>
</dt>
<dd>Whether discard requests to
the qcow2 device should be forwarded to the data source
(on/off; default: on if discard=unmap is specified, off
otherwise)</dd>
<dt>
<strong><strong>pass-discard-snapshot</strong></strong>
</dt>
<dd>Whether discard requests for
the data source should be issued when a snapshot operation
(e.g. deleting a snapshot) frees clusters in the qcow2
file (on/off; default: on)</dd>
<dt>
<strong><strong>pass-discard-other</strong></strong>
</dt>
<dd>Whether discard requests for the
data source should be issued on other occasions where a
cluster gets freed (on/off; default: off)</dd>
<dt>
<strong><strong>discard-no-unref</strong></strong>
</dt>
<dd>When enabled, data clusters will
remain preallocated when they are no longer used, e.g.
because they are discarded or converted to zero clusters.
As usual, whether the old data is discarded or kept on the
protocol level (i.e. in the image file) depends on the
setting of the pass-discard-request option. Keeping the
clusters preallocated prevents qcow2 fragmentation that
would otherwise be caused by freeing and re-allocating
them later. Besides potential performance degradation,
such fragmentation can lead to increased allocation of
clusters past the end of the image file, resulting in
image files whose file length can grow much larger than
their guest disk size would suggest. If image file length
is of concern (e.g. when storing qcow2 images directly on
block devices), you should consider enabling this option.</dd>
<dt>
<strong><strong>overlap-check</strong></strong>
</dt>
<dd>Which overlap checks to perform for
writes to the image (none/constant/cached/all; default:
cached). For details or finer granularity control refer to
the QAPI documentation of <strong>blockdev-add</strong>.</dd>
</dl>
</dd>
</dl>
<p>Example 1:</p>
<blockquote>
<blockquote>
<pre class="example">
-blockdev driver=file,node-name=my_file,filename=/tmp/disk.qcow2
-blockdev driver=qcow2,node-name=hda,file=my_file,overlap-check=none,cache-size=16777216
</pre>
</blockquote>
</blockquote>
<p>
Example 2:</p>
<blockquote>
<blockquote>
<pre class="example">
-blockdev driver=qcow2,node-name=disk,file.driver=http,file.filename=http://example.com/image.qcow2
</pre>
</blockquote>
</blockquote>
<dl>
<dt>
<strong>*Driver-specific</strong> options for other drivers*
</dt>
<dd>Please
refer to the QAPI documentation of the <strong>blockdev-add</strong> QMP
command.</dd>
</dl>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>
<strong>*-drive</strong> option[,option[,option[,…]]]*
</dt>
<dd>
<p>Define a new drive. This
includes creating a block driver node (the backend) as well as a guest
device, and is mostly a shortcut for defining the corresponding
<strong>-blockdev</strong> and <strong>-device</strong> options.</p>
<p>
<strong>-drive</strong> accepts all options that are accepted by <strong>-blockdev</strong>. In
addition, it knows the following options:</p>
<dl>
<dt>
<strong><strong>file=file</strong></strong>
</dt>
<dd>This option defines which disk image (see the <em>Disk
Images</em> chapter in the System Emulation Users Guide) to use with
this drive. If the filename contains comma, you must double it (for
instance, &#34;file=my,,file&#34; to use file &#34;my,file&#34;).

Special files such as iSCSI devices can be specified using protocol
specific URLs. See the section for &#34;Device URL Syntax&#34; for more
information.</dd>
<dt>
<strong><strong>if=interface</strong></strong>
</dt>
<dd>This option defines on which type on interface
the drive is connected. Available types are: ide, scsi, sd, mtd,
floppy, pflash, virtio, none.</dd>
<dt>
<strong><strong>bus=bus,unit=unit</strong></strong>
</dt>
<dd>These options define where is connected the
drive by defining the bus number and the unit id.</dd>
<dt>
<strong><strong>index=index</strong></strong>
</dt>
<dd>This option defines where the drive is connected
by using an index in the list of available connectors of a given
interface type.</dd>
<dt>
<strong><strong>media=media</strong></strong>
</dt>
<dd>This option defines the type of the media: disk
or cdrom.</dd>
<dt>
<strong><strong>snapshot=snapshot</strong></strong>
</dt>
<dd>snapshot is &#34;on&#34; or &#34;off&#34; and controls
snapshot mode for the given drive (see <strong>-snapshot</strong>).</dd>
<dt>
<strong><strong>cache=cache</strong></strong>
</dt>
<dd>cache is &#34;none&#34;, &#34;writeback&#34;, &#34;unsafe&#34;,
&#34;directsync&#34; or &#34;writethrough&#34; and controls how the host cache is
used to access block data. This is a shortcut that sets the
<strong>cache.direct</strong> and <strong>cache.no-flush</strong> options (as in <strong>-blockdev</strong>), and
additionally <strong>cache.writeback</strong>, which provides a default for the
<strong>write-cache</strong> option of block guest devices (as in <strong>-device</strong>). The
modes correspond to the following settings:</dd>
</dl>
<table>
<thead>
<tr>
<th></th>
<th>cache.writeback</th>
<th>cache.direct</th>
<th>cache.no-flush</th>
</tr>
</thead>
<tbody>
<tr>
<td>writeback</td>
<td>on</td>
<td>off</td>
<td>off</td>
</tr>
<tr>
<td>_</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>none</td>
<td>on</td>
<td>on</td>
<td>off</td>
</tr>
<tr>
<td>_</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>writethrough</td>
<td>off</td>
<td>off</td>
<td>off</td>
</tr>
<tr>
<td>_</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>directsync</td>
<td>off</td>
<td>on</td>
<td>off</td>
</tr>
<tr>
<td>_</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsafe</td>
<td>on</td>
<td>off</td>
<td>on</td>
</tr>
</tbody>
</table>
<p>
The default mode is <strong>cache=writeback</strong>.</p>
<dl>
<dt>
<strong><strong>aio=aio</strong></strong>
</dt>
<dd>aio is &#34;threads&#34;, &#34;native&#34;, or &#34;io_uring&#34; and selects
between pthread based disk I/O, native Linux AIO, or Linux io_uring
API.</dd>
<dt>
<strong><strong>format=format</strong></strong>
</dt>
<dd>Specify which disk format will be used rather
than detecting the format. Can be used to specify format=raw to
avoid interpreting an untrusted format header.</dd>
<dt>
<strong><strong>werror=action,rerror=action</strong></strong>
</dt>
<dd>Specify which action to take on
write and read errors. Valid actions are: &#34;ignore&#34; (ignore the error
and try to continue), &#34;stop&#34; (pause QEMU), &#34;report&#34; (report the
error to the guest), &#34;enospc&#34; (pause QEMU only if the host disk is
full; report the error to the guest otherwise). The default setting
is <strong>werror=enospc</strong> and <strong>rerror=report</strong>.</dd>
<dt>
<strong><strong>copy-on-read=copy-on-read</strong></strong>
</dt>
<dd>copy-on-read is &#34;on&#34; or &#34;off&#34; and
enables whether to copy read backing file sectors into the image
file.</dd>
<dt>
<strong><strong>bps=b,bps_rd=r,bps_wr=w</strong></strong>
</dt>
<dd>Specify bandwidth throttling limits
in bytes per second, either for all request types or for reads or
writes only. Small values can lead to timeouts or hangs inside the
guest. A safe minimum for disks is 2 MB/s.</dd>
<dt>
<strong><strong>bps_max=bm,bps_rd_max=rm,bps_wr_max=wm</strong></strong>
</dt>
<dd>Specify bursts in
bytes per second, either for all request types or for reads or
writes only. Bursts allow the guest I/O to spike above the limit
temporarily.</dd>
<dt>
<strong><strong>iops=i,iops_rd=r,iops_wr=w</strong></strong>
</dt>
<dd>Specify request rate limits in
requests per second, either for all request types or for reads or
writes only.</dd>
<dt>
<strong><strong>iops_max=bm,iops_rd_max=rm,iops_wr_max=wm</strong></strong>
</dt>
<dd>Specify bursts in
requests per second, either for all request types or for reads or
writes only. Bursts allow the guest I/O to spike above the limit
temporarily.</dd>
<dt>
<strong><strong>iops_size=is</strong></strong>
</dt>
<dd>Let every is bytes of a request count as a new
request for iops throttling purposes. Use this option to prevent
guests from circumventing iops limits by sending fewer but larger
requests.</dd>
<dt>
<strong><strong>group=g</strong></strong>
</dt>
<dd>Join a throttling quota group with given name g. All
drives that are members of the same group are accounted for
together. Use this option to prevent guests from circumventing
throttling limits by using many small disks instead of a single
larger disk.</dd>
</dl>
</dd>
</dl>
<p>By default, the <strong>cache.writeback=on</strong> mode is used. It will report data
writes as completed as soon as the data is present in the host page
cache. This is safe as long as your guest OS makes sure to correctly
flush disk caches where needed. If your guest OS does not handle
volatile disk write caches correctly and your host crashes or loses
power, then the guest may experience data corruption.</p>
<p>
For such guests, you should consider using <strong>cache.writeback=off</strong>. This
means that the host page cache will be used to read and write data, but
write notification will be sent to the guest only after QEMU has made
sure to flush each write to the disk. Be aware that this has a major
impact on performance.</p>
<p>
When using the <strong>-snapshot</strong> option, unsafe caching is always used.</p>
<p>
Copy-on-read avoids accessing the same backing file sectors repeatedly
and is useful when the backing file is over a slow network. By default
copy-on-read is off.</p>
<p>
Instead of <strong>-cdrom</strong> you can use:</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 -drive file=file,index=2,media=cdrom
</pre>
</blockquote>
</blockquote>
<p>
Instead of <strong>-hda</strong>, <strong>-hdb</strong>, <strong>-hdc</strong>, <strong>-hdd</strong>, you can use:</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 -drive file=file,index=0,media=disk
qemu-system-x86_64 -drive file=file,index=1,media=disk
qemu-system-x86_64 -drive file=file,index=2,media=disk
qemu-system-x86_64 -drive file=file,index=3,media=disk
</pre>
</blockquote>
</blockquote>
<p>
You can open an image using pre-opened file descriptors from an fd set:</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 \
 -add-fd fd=3,set=2,opaque=&#34;rdwr:/path/to/file&#34; \
 -add-fd fd=4,set=2,opaque=&#34;rdonly:/path/to/file&#34; \
 -drive file=/dev/fdset/2,index=0,media=disk
</pre>
</blockquote>
</blockquote>
<p>
You can connect a CDROM to the slave of ide0:</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 -drive file=file,if=ide,index=1,media=cdrom
</pre>
</blockquote>
</blockquote>
<p>
If you don&#39;t specify the &#34;file=&#34; argument, you define an empty drive:</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 -drive if=ide,index=1,media=cdrom
</pre>
</blockquote>
</blockquote>
<p>
Instead of <strong>-fda</strong>, <strong>-fdb</strong>, you can use:</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 -drive file=file,index=0,if=floppy
qemu-system-x86_64 -drive file=file,index=1,if=floppy
</pre>
</blockquote>
</blockquote>
<p>
By default, interface is &#34;ide&#34; and index is automatically incremented:</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 -drive file=a -drive file=b
</pre>
</blockquote>
</blockquote>
<p>
is interpreted like:</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 -hda a -hdb b
</pre>
</blockquote>
</blockquote>
<dl>
<dt>
<strong>*-mtdblock</strong> file*
</dt>
<dd>Use file as on-board Flash memory image.</dd>
<dt>
<strong>*-sd</strong> file*
</dt>
<dd>Use file as SecureDigital card image.</dd>
<dt>
<strong><strong>-snapshot</strong></strong>
</dt>
<dd>
<p>Write to temporary files instead of disk image files.
In this case, the raw disk image you use is not written back. You can
however force the write back by pressing C-a s (see the <em>Disk Images</em>
chapter in the System Emulation Users Guide).</p>
<p>
<strong>WARNING:</strong></p>
<blockquote>
<p>snapshot is incompatible with <strong>-blockdev</strong> (instead use qemu-img to
manually create snapshot images to attach to your blockdev). If you
have mixed <strong>-blockdev</strong> and <strong>-drive</strong> declarations you can use the
&#39;snapshot&#39; property on your drive declarations instead of this global
option.</p>
</blockquote>
</dd>
<dt>
?
</dt>
<dd>
<p><strong>*-fsdev</strong> local,id=id,path=path,security_model=security_model
[,writeout=writeout][,readonly=on][,fmode=fmode][,dmode=dmode]
[,throttling.option=value[,throttling.option=value[,…]]]* :: - <strong>*-fsdev</strong>
  proxy,id=id,socket=socket[,writeout=writeout][,readonly=on]* :: - <strong>*-fsdev</strong>
    proxy,id=id,sock_fd=sock_fd[,writeout=writeout][,readonly=on]* :: - <strong>*-fsdev</strong>
      synth,id=id[,readonly=on]* :: Define a new file system device.
      Valid options are:</p>
<dl>
<dt>
<strong><strong>local</strong></strong>
</dt>
<dd>Accesses to the filesystem are done by QEMU.</dd>
<dt>
<strong><strong>proxy</strong></strong>
</dt>
<dd>Accesses to the filesystem are done by
virtfs-proxy-helper(1). This option is deprecated (since QEMU
8.1) and will be removed in a future version of QEMU. Use
<strong>local</strong> instead.</dd>
<dt>
<strong><strong>synth</strong></strong>
</dt>
<dd>Synthetic filesystem, only used by QTests.</dd>
<dt>
<strong><strong>id=id</strong></strong>
</dt>
<dd>Specifies identifier for this device.</dd>
<dt>
<strong><strong>path=path</strong></strong>
</dt>
<dd>Specifies the export path for the file system
device. Files under this path will be available to the 9p
client on the guest.</dd>
<dt>
<strong><strong>security_model=security_model</strong></strong>
</dt>
<dd>Specifies the security
model to be used for this export path. Supported security
models are &#34;passthrough&#34;, &#34;mapped-xattr&#34;, &#34;mapped-file&#34; and
&#34;none&#34;. In &#34;passthrough&#34; security model, files are stored
using the same credentials as they are created on the guest.
This requires QEMU to run as root. In &#34;mapped-xattr&#34; security
model, some of the file attributes like uid, gid, mode bits
and link target are stored as file attributes. For
&#34;mapped-file&#34; these attributes are stored in the hidden
.virtfs_metadata directory. Directories exported by this
security model cannot interact with other unix tools. &#34;none&#34;
security model is same as passthrough except the sever won&#39;t
report failures if it fails to set file attributes like
ownership. Security model is mandatory only for local
fsdriver. Other fsdrivers (like proxy) don&#39;t take security
model as a parameter.</dd>
<dt>
<strong><strong>writeout=writeout</strong></strong>
</dt>
<dd>This is an optional argument. The
only supported value is &#34;immediate&#34;. This means that host page
cache will be used to read and write data but write
notification will be sent to the guest only when the data has
been reported as written by the storage subsystem.</dd>
<dt>
<strong><strong>readonly=on</strong></strong>
</dt>
<dd>Enables exporting 9p share as a readonly
mount for guests. By default read-write access is given.</dd>
<dt>
<strong><strong>socket=socket</strong></strong>
</dt>
<dd>Enables proxy filesystem driver to use
passed socket file for communicating with
virtfs-proxy-helper(1).</dd>
<dt>
<strong><strong>sock_fd=sock_fd</strong></strong>
</dt>
<dd>Enables proxy filesystem driver to use
passed socket descriptor for communicating with
virtfs-proxy-helper(1). Usually a helper like libvirt will
create socketpair and pass one of the fds as sock_fd.</dd>
<dt>
<strong><strong>fmode=fmode</strong></strong>
</dt>
<dd>Specifies the default mode for newly
created files on the host. Works only with security models
&#34;mapped-xattr&#34; and &#34;mapped-file&#34;.</dd>
<dt>
<strong><strong>dmode=dmode</strong></strong>
</dt>
<dd>Specifies the default mode for newly
created directories on the host. Works only with security
models &#34;mapped-xattr&#34; and &#34;mapped-file&#34;.</dd>
<dt>
<strong><strong>throttling.bps-total=b,throttling.bps-read=r,throttling.bps-write=w</strong></strong>
</dt>
<dd>Specify
bandwidth throttling limits in bytes per second, either for
all request types or for reads or writes only.</dd>
<dt>
<strong><strong>throttling.bps-total-max=bm,bps-read-max=rm,bps-write-max=wm</strong></strong>
</dt>
<dd>Specify
bursts in bytes per second, either for all request types or
for reads or writes only. Bursts allow the guest I/O to spike
above the limit temporarily.</dd>
<dt>
?
</dt>
<dd><strong>*throttling.iops-total=i,throttling.iops-read=r,</strong>
throttling.iops-write=w* :: Specify request rate limits in
requests per second, either for all request types or for reads
or writes only.</dd>
<dt>
?
</dt>
<dd><strong>*throttling.iops-total-max=im,throttling.iops-read-max=irm,</strong>
throttling.iops-write-max=iwm* :: Specify bursts in requests
per second, either for all request types or for reads or
writes only. Bursts allow the guest I/O to spike above the
limit temporarily.</dd>
<dt>
<strong><strong>throttling.iops-size=is</strong></strong>
</dt>
<dd>Let every is bytes of a request
count as a new request for iops throttling purposes.</dd>
</dl>
</dd>
</dl>
<p>-fsdev option is used along with -device driver &#34;virtio-9p-…&#34;.</p>
<dl>
<dt>
<strong>*-device</strong> virtio-9p-type,fsdev=id,mount_tag=mount_tag*
</dt>
<dd>
<p>Options for
virtio-9p-… driver are:</p>
<dl>
<dt>
<strong><strong>type</strong></strong>
</dt>
<dd>Specifies the variant to be used. Supported values are
&#34;pci&#34;, &#34;ccw&#34; or &#34;device&#34;, depending on the machine type.</dd>
<dt>
<strong><strong>fsdev=id</strong></strong>
</dt>
<dd>Specifies the id value specified along with -fsdev
option.</dd>
<dt>
<strong><strong>mount_tag=mount_tag</strong></strong>
</dt>
<dd>Specifies the tag name to be used by the
guest to mount this export point.</dd>
</dl>
</dd>
<dt>
?
</dt>
<dd>
<p><strong>*-virtfs</strong> local,path=path,mount_tag=mount_tag
,security_model=security_model[,writeout=writeout][,readonly=on]
[,fmode=fmode][,dmode=dmode][,multidevs=multidevs]* :: - <strong>*-virtfs</strong>
  proxy,socket=socket,mount_tag=mount_tag
  [,writeout=writeout][,readonly=on]* :: - <strong>*-virtfs</strong>
    proxy,sock_fd=sock_fd,mount_tag=mount_tag
    [,writeout=writeout][,readonly=on]* :: - <strong>*-virtfs</strong>
      synth,mount_tag=mount_tag* :: Define a new virtual filesystem
      device and expose it to the guest using a virtio-9p-device
      (a.k.a. 9pfs), which essentially means that a certain directory
      on host is made directly accessible by guest as a pass-through
      file system by using the 9P network protocol for communication
      between host and guests, if desired even accessible, shared by
      several guests simultaneously.</p>
<p>
      Note that <strong>-virtfs</strong> is actually just a convenience shortcut for
      its generalized form <strong>-fsdev -device virtio-9p-pci</strong>.</p>
<p>
      The general form of pass-through file system options are:</p>
<dl>
<dt>
<strong><strong>local</strong></strong>
</dt>
<dd>Accesses to the filesystem are done by QEMU.</dd>
<dt>
<strong><strong>proxy</strong></strong>
</dt>
<dd>Accesses to the filesystem are done by
virtfs-proxy-helper(1). This option is deprecated (since QEMU
8.1) and will be removed in a future version of QEMU. Use
<strong>local</strong> instead.</dd>
<dt>
<strong><strong>synth</strong></strong>
</dt>
<dd>Synthetic filesystem, only used by QTests.</dd>
<dt>
<strong><strong>id=id</strong></strong>
</dt>
<dd>Specifies identifier for the filesystem device</dd>
<dt>
<strong><strong>path=path</strong></strong>
</dt>
<dd>Specifies the export path for the file system
device. Files under this path will be available to the 9p
client on the guest.</dd>
<dt>
<strong><strong>security_model=security_model</strong></strong>
</dt>
<dd>Specifies the security
model to be used for this export path. Supported security
models are &#34;passthrough&#34;, &#34;mapped-xattr&#34;, &#34;mapped-file&#34; and
&#34;none&#34;. In &#34;passthrough&#34; security model, files are stored
using the same credentials as they are created on the guest.
This requires QEMU to run as root. In &#34;mapped-xattr&#34; security
model, some of the file attributes like uid, gid, mode bits
and link target are stored as file attributes. For
&#34;mapped-file&#34; these attributes are stored in the hidden
.virtfs_metadata directory. Directories exported by this
security model cannot interact with other unix tools. &#34;none&#34;
security model is same as passthrough except the sever won&#39;t
report failures if it fails to set file attributes like
ownership. Security model is mandatory only for local
fsdriver. Other fsdrivers (like proxy) don&#39;t take security
model as a parameter.</dd>
<dt>
<strong><strong>writeout=writeout</strong></strong>
</dt>
<dd>This is an optional argument. The
only supported value is &#34;immediate&#34;. This means that host page
cache will be used to read and write data but write
notification will be sent to the guest only when the data has
been reported as written by the storage subsystem.</dd>
<dt>
<strong><strong>readonly=on</strong></strong>
</dt>
<dd>Enables exporting 9p share as a readonly
mount for guests. By default read-write access is given.</dd>
<dt>
<strong><strong>socket=socket</strong></strong>
</dt>
<dd>Enables proxy filesystem driver to use
passed socket file for communicating with
virtfs-proxy-helper(1). Usually a helper like libvirt will
create socketpair and pass one of the fds as sock_fd.</dd>
<dt>
<strong><strong>sock_fd</strong></strong>
</dt>
<dd>Enables proxy filesystem driver to use passed
&#39;sock_fd&#39; as the socket descriptor for interfacing with
virtfs-proxy-helper(1).</dd>
<dt>
<strong><strong>fmode=fmode</strong></strong>
</dt>
<dd>Specifies the default mode for newly
created files on the host. Works only with security models
&#34;mapped-xattr&#34; and &#34;mapped-file&#34;.</dd>
<dt>
<strong><strong>dmode=dmode</strong></strong>
</dt>
<dd>Specifies the default mode for newly
created directories on the host. Works only with security
models &#34;mapped-xattr&#34; and &#34;mapped-file&#34;.</dd>
<dt>
<strong><strong>mount_tag=mount_tag</strong></strong>
</dt>
<dd>Specifies the tag name to be used
by the guest to mount this export point.</dd>
<dt>
<strong><strong>multidevs=multidevs</strong></strong>
</dt>
<dd>Specifies how to deal with multiple
devices being shared with a 9p export. Supported behaviours
are either &#34;remap&#34;, &#34;forbid&#34; or &#34;warn&#34;. The latter is the
default behaviour on which virtfs 9p expects only one device
to be shared with the same export, and if more than one device
is shared and accessed via the same 9p export then only a
warning message is logged (once) by qemu on host side. In
order to avoid file ID collisions on guest you should either
create a separate virtfs export for each device to be shared
with guests (recommended way) or you might use &#34;remap&#34; instead
which allows you to share multiple devices with only one
export instead, which is achieved by remapping the original
inode numbers from host to guest in a way that would prevent
such collisions. Remapping inodes in such use cases is
required because the original device IDs from host are never
passed and exposed on guest. Instead all files of an export
shared with virtfs always share the same device id on guest.
So two files with identical inode numbers but from actually
different devices on host would otherwise cause a file ID
collision and hence potential misbehaviours on guest. &#34;forbid&#34;
on the other hand assumes like &#34;warn&#34; that only one device is
shared by the same export, however it will not only log a
warning message but also deny access to additional devices on
guest. Note though that &#34;forbid&#34; does currently not block all
possible file access operations (e.g. readdir() would still
return entries from other devices).</dd>
</dl>
</dd>
<dt>
<strong><strong>-iscsi</strong></strong>
</dt>
<dd>Configure iSCSI session parameters.</dd>
</dl>
</blockquote>
</div>
</div>
<div id="outline-container-headline-8" class="outline-3">
<h3 id="headline-8">
USB convenience options
</h3>
<div id="outline-text-headline-8" class="outline-text-3">
<blockquote>
<dl>
<dt>
<strong><strong>-usb</strong></strong>
</dt>
<dd>Enable USB emulation on machine types with an on-board USB
host controller (if not enabled by default). Note that on-board USB
host controllers may not support USB 3.0. In this case <strong>-device
qemu-xhci</strong> can be used instead on machines with PCI.</dd>
<dt>
<strong>*-usbdevice</strong> devname*
</dt>
<dd>
<p>Add the USB device devname, and enable an
on-board USB controller if possible and necessary (just like it can be
done via <strong>-machine usb=on</strong>). Note that this option is mainly intended
for the user&#39;s convenience only. More fine-grained control can be
achieved by selecting a USB host controller (if necessary) and the
desired USB device via the <strong>-device</strong> option instead. For example,
instead of using <strong>-usbdevice mouse</strong> it is possible to use <strong>-device
qemu-xhci -device usb-mouse</strong> to connect the USB mouse to a USB 3.0
controller instead (at least on machines that support PCI and do not
have an USB controller enabled by default yet). For more details, see
the chapter about <em>Connecting USB devices</em> in the System Emulation
Users Guide. Possible devices for devname are:</p>
<dl>
<dt>
<strong><strong>braille</strong></strong>
</dt>
<dd>Braille device. This will use BrlAPI to display the
braille output on a real or fake device (i.e. it also creates a
corresponding <strong>braille</strong> chardev automatically beside the
<strong>usb-braille</strong> USB device).</dd>
<dt>
<strong><strong>keyboard</strong></strong>
</dt>
<dd>Standard USB keyboard. Will override the PS/2
keyboard (if present).</dd>
<dt>
<strong><strong>mouse</strong></strong>
</dt>
<dd>Virtual Mouse. This will override the PS/2 mouse
emulation when activated.</dd>
<dt>
<strong><strong>tablet</strong></strong>
</dt>
<dd>Pointer device that uses absolute coordinates (like a
touchscreen). This means QEMU is able to report the mouse position
without having to grab the mouse. Also overrides the PS/2 mouse
emulation when activated.</dd>
<dt>
<strong><strong>wacom-tablet</strong></strong>
</dt>
<dd>Wacom PenPartner USB tablet.</dd>
</dl>
</dd>
</dl>
</blockquote>
</div>
</div>
<div id="outline-container-headline-9" class="outline-3">
<h3 id="headline-9">
Display options
</h3>
<div id="outline-text-headline-9" class="outline-text-3">
<blockquote>
<dl>
<dt>
<strong>*-display</strong> type*
</dt>
<dd>
<p>Select type of display to use. Use <strong>-display
help</strong> to list the available display types. Valid values for type are</p>
<dl>
<dt>
<strong><strong>spice-app[,gl=on|off]</strong></strong>
</dt>
<dd>Start QEMU as a Spice server and launch
the default Spice client application. The Spice server will redirect
the serial consoles and QEMU monitors. (Since 4.0)</dd>
<dt>
<strong><strong>dbus</strong></strong>
</dt>
<dd>Export the display over D-Bus interfaces. (Since 7.0)

The connection is registered with the &#34;org.qemu&#34; name (and queued
when already owned).

<strong>addr=&lt;dbusaddr&gt;</strong> : D-Bus bus address to connect to.

<strong>p2p=yes|no</strong> : Use peer-to-peer connection, accepted via QMP
<strong>add_client</strong>.

<strong>gl=on|off|core|es</strong> : Use OpenGL for rendering (the D-Bus interface
will share framebuffers with DMABUF file descriptors).</dd>
<dt>
<strong><strong>sdl</strong></strong>
</dt>
<dd>Display video output via SDL (usually in a separate
graphics window; see the SDL documentation for other possibilities).
Valid parameters are:

<strong>grab-mod=&lt;mods&gt;</strong> : Used to select the modifier keys for toggling
the mouse grabbing in conjunction with the &#34;g&#34; key. <strong>&lt;mods&gt;</strong> can be
either <strong>lshift-lctrl-lalt</strong> or <strong>rctrl</strong>.

<strong>gl=on|off|core|es</strong> : Use OpenGL for displaying

<strong>show-cursor=on|off</strong> : Force showing the mouse cursor

<strong>window-close=on|off</strong> : Allow to quit qemu with window close button</dd>
<dt>
<strong><strong>gtk</strong></strong>
</dt>
<dd>
<p>Display video output in a GTK window. This interface
provides drop-down menus and other UI elements to configure and
control the VM during runtime. Valid parameters are:</p>
<p>
<strong>full-screen=on|off</strong> : Start in fullscreen mode</p>
<p>
<strong>gl=on|off</strong> : Use OpenGL for displaying</p>
<p>
<strong>grab-on-hover=on|off</strong> : Grab keyboard input on mouse hover</p>
<ul>
<li><strong>*show-tabs=on|off</strong> (Display the tab bar for switching between
the)* :: various graphical interfaces (e.g. VGA and virtual
console character devices) by default.</li>
</ul>
</dd>
</dl>
<p><strong>show-cursor=on|off</strong> : Force showing the mouse cursor</p>
<p>
<strong>window-close=on|off</strong> : Allow to quit qemu with window close button</p>
<p>
<strong>show-menubar=on|off</strong> : Display the main window menubar, defaults to
&#34;on&#34;</p>
<blockquote>
<ul>
<li><strong>*zoom-to-fit=on|off</strong> (Expand video output to the window
size,)* :: defaults to &#34;off&#34;</li>
</ul>
</blockquote>
<dl>
<dt>
<strong><strong>curses[,charset=&lt;encoding&gt;]</strong></strong>
</dt>
<dd>Display video output via curses.
For graphics device models which support a text mode, QEMU can
display this output using a curses/ncurses interface. Nothing is
displayed when the graphics device is in graphical mode or if the
graphics device does not support a text mode. Generally only the VGA
device models support text mode. The font charset used by the guest
can be specified with the <strong>charset</strong> option, for example
<strong>charset=CP850</strong> for IBM CP850 encoding. The default is <strong>CP437</strong>.</dd>
<dt>
<strong><strong>cocoa</strong></strong>
</dt>
<dd>
<p>Display video output in a Cocoa window. Mac only. This
interface provides drop-down menus and other UI elements to
configure and control the VM during runtime. Valid parameters are:</p>
<ul>
<li><strong>*full-grab=on|off</strong> (Capture all key presses, including system
combos.)* :: This requires accessibility permissions, since it
performs a global grab on key events. (default: off) See
<em><a href="https://support.apple.com/en-in/guide/mac-help/mh32356/mac">https://support.apple.com/en-in/guide/mac-help/mh32356/mac</a></em></li>
<li><strong>*swap-opt-cmd=on|off</strong> (Swap the Option and Command keys so that
their)* :: key codes match their position on non-Mac keyboards and
you can use Meta/Super and Alt where you expect them. (default:
off)</li>
</ul>
</dd>
</dl>
<p><strong>show-cursor=on|off</strong> : Force showing the mouse cursor</p>
<p>
<strong>left-command-key=on|off</strong> : Disable forwarding left command key to
host</p>
<p>
<strong>full-screen=on|off</strong> : Start in fullscreen mode</p>
<blockquote>
<ul>
<li><strong>*zoom-to-fit=on|off</strong> (Expand video output to the window
size,)* :: defaults to &#34;off&#34;</li>
</ul>
</blockquote>
<dl>
<dt>
<strong><strong>egl-headless[,rendernode=&lt;file&gt;]</strong></strong>
</dt>
<dd>Offload all OpenGL
operations to a local DRI device. For any graphical display, this
display needs to be paired with either VNC or SPICE displays.</dd>
<dt>
<strong><strong>vnc=&lt;display&gt;</strong></strong>
</dt>
<dd>Start a VNC server on display &lt;display&gt;</dd>
<dt>
<strong><strong>none</strong></strong>
</dt>
<dd>Do not display video output. The guest will still see an
emulated graphics card, but its output will not be displayed to the
QEMU user. This option differs from the -nographic option in that it
only affects what is done with video output; -nographic also changes
the destination of the serial and parallel port data.</dd>
</dl>
</dd>
<dt>
<strong><strong>-nographic</strong></strong>
</dt>
<dd>Normally, if QEMU is compiled with graphical window
support, it displays output such as guest graphics, guest console, and
the QEMU monitor in a window. With this option, you can totally
disable graphical output so that QEMU is a simple command line
application. The emulated serial port is redirected on the console and
muxed with the monitor (unless redirected elsewhere explicitly).
Therefore, you can still use QEMU to debug a Linux kernel with a
serial console. Use C-a h for help on switching between the console
and monitor.</dd>
<dt>
<strong>*-spice</strong> option[,option[,…]]*
</dt>
<dd>
<p>Enable the spice remote desktop
protocol. Valid options are</p>
<dl>
<dt>
<strong><strong>port=&lt;nr&gt;</strong></strong>
</dt>
<dd>Set the TCP port spice is listening on for
plaintext channels.</dd>
<dt>
<strong><strong>addr=&lt;addr&gt;</strong></strong>
</dt>
<dd>Set the IP address spice is listening on. Default
is any address.</dd>
<dt>
<strong>*ipv4=on|off</strong>; <strong>ipv6=on|off</strong>; <strong>unix=on|off*</strong>
</dt>
<dd>Force using the
specified IP version.</dd>
<dt>
<strong><strong>password-secret=&lt;secret-id&gt;</strong></strong>
</dt>
<dd>Set the ID of the <strong>secret</strong> object
containing the password you need to authenticate.</dd>
<dt>
<strong><strong>sasl=on|off</strong></strong>
</dt>
<dd>Require that the client use SASL to authenticate
with the spice. The exact choice of authentication method used is
controlled from the system / user&#39;s SASL configuration file for the
&#39;qemu&#39; service. This is typically found in /etc/sasl2/qemu.conf. If
running QEMU as an unprivileged user, an environment variable
SASL_CONF_PATH can be used to make it search alternate locations for
the service config. While some SASL auth methods can also provide
data encryption (eg GSSAPI), it is recommended that SASL always be
combined with the &#39;tls&#39; and &#39;x509&#39; settings to enable use of SSL and
server certificates. This ensures a data encryption preventing
compromise of authentication credentials.</dd>
<dt>
<strong><strong>disable-ticketing=on|off</strong></strong>
</dt>
<dd>Allow client connects without
authentication.</dd>
<dt>
<strong><strong>disable-copy-paste=on|off</strong></strong>
</dt>
<dd>Disable copy paste between the
client and the guest.</dd>
<dt>
<strong><strong>disable-agent-file-xfer=on|off</strong></strong>
</dt>
<dd>Disable spice-vdagent based
file-xfer between the client and the guest.</dd>
<dt>
<strong><strong>tls-port=&lt;nr&gt;</strong></strong>
</dt>
<dd>Set the TCP port spice is listening on for
encrypted channels.</dd>
<dt>
<strong><strong>x509-dir=&lt;dir&gt;</strong></strong>
</dt>
<dd>Set the x509 file directory. Expects same
filenames as -vnc $display,x509=$dir</dd>
<dt>
?
</dt>
<dd><strong>*x509-key-file=&lt;file&gt;</strong>; <strong>x509-key-password=&lt;file&gt;</strong>;
<strong>x509-cert-file=&lt;file&gt;</strong>; <strong>x509-cacert-file=&lt;file&gt;</strong>;
<strong>x509-dh-key-file=&lt;file&gt;*</strong> :: The x509 file names can also be
configured individually.</dd>
<dt>
<strong><strong>tls-ciphers=&lt;list&gt;</strong></strong>
</dt>
<dd>Specify which ciphers to use.</dd>
<dt>
?
</dt>
<dd><strong>*tls-channel=[main|display|cursor|inputs|record|playback]</strong>;
<strong>plaintext-channel=[main|display|cursor|inputs|record|playback]*</strong> :: Force
specific channel to be used with or without TLS encryption. The
options can be specified multiple times to configure multiple
channels. The special name &#34;default&#34; can be used to set the default
mode. For channels which are not explicitly forced into one mode the
spice client is allowed to pick tls/plaintext as he pleases.</dd>
<dt>
<strong><strong>image-compression=[auto_glz|auto_lz|quic|glz|lz|off]</strong></strong>
</dt>
<dd>Configure
image compression (lossless). Default is auto_glz.</dd>
<dt>
?
</dt>
<dd><strong>*jpeg-wan-compression=[auto|never|always]</strong>;
<strong>zlib-glz-wan-compression=[auto|never|always]*</strong> :: Configure wan
image compression (lossy for slow links). Default is auto.</dd>
<dt>
<strong><strong>streaming-video=[off|all|filter]</strong></strong>
</dt>
<dd>Configure video stream
detection. Default is off.</dd>
<dt>
<strong><strong>agent-mouse=[on|off]</strong></strong>
</dt>
<dd>Enable/disable passing mouse events via
vdagent. Default is on.</dd>
<dt>
<strong><strong>playback-compression=[on|off]</strong></strong>
</dt>
<dd>Enable/disable audio stream
compression (using celt 0.5.1). Default is on.</dd>
<dt>
<strong><strong>seamless-migration=[on|off]</strong></strong>
</dt>
<dd>Enable/disable spice seamless
migration. Default is off.</dd>
<dt>
<strong><strong>gl=[on|off]</strong></strong>
</dt>
<dd>Enable/disable OpenGL context. Default is off.</dd>
<dt>
<strong><strong>rendernode=&lt;file&gt;</strong></strong>
</dt>
<dd>DRM render node for OpenGL rendering. If
not specified, it will pick the first available. (Since 2.9)</dd>
</dl>
</dd>
<dt>
<strong><strong>-portrait</strong></strong>
</dt>
<dd>Rotate graphical output 90 deg left (only PXA LCD).</dd>
<dt>
<strong>*-rotate</strong> deg*
</dt>
<dd>Rotate graphical output some deg left (only PXA
LCD).</dd>
<dt>
<strong>*-vga</strong> type*
</dt>
<dd>
<p>Select type of VGA card to emulate. Valid values for
type are</p>
<dl>
<dt>
<strong><strong>cirrus</strong></strong>
</dt>
<dd>Cirrus Logic GD5446 Video card. All Windows versions
starting from Windows 95 should recognize and use this graphic card.
For optimal performances, use 16 bit color depth in the guest and
the host OS. (This card was the default before QEMU 2.2)</dd>
<dt>
<strong><strong>std</strong></strong>
</dt>
<dd>Standard VGA card with Bochs VBE extensions. If your
guest OS supports the VESA 2.0 VBE extensions (e.g. Windows XP) and
if you want to use high resolution modes (&gt;= 1280x1024x16) then you
should use this option. (This card is the default since QEMU 2.2)</dd>
<dt>
<strong><strong>vmware</strong></strong>
</dt>
<dd>VMWare SVGA-II compatible adapter. Use it if you have
sufficiently recent XFree86/XOrg server or Windows guest with a
driver for this card.</dd>
<dt>
<strong><strong>qxl</strong></strong>
</dt>
<dd>QXL paravirtual graphic card. It is VGA compatible
(including VESA 2.0 VBE support). Works best with qxl guest drivers
installed though. Recommended choice when using the spice protocol.</dd>
<dt>
<strong><strong>tcx</strong></strong>
</dt>
<dd>(sun4m only) Sun TCX framebuffer. This is the default
framebuffer for sun4m machines and offers both 8-bit and 24-bit
colour depths at a fixed resolution of 1024x768.</dd>
<dt>
<strong><strong>cg3</strong></strong>
</dt>
<dd>(sun4m only) Sun cgthree framebuffer. This is a simple
8-bit framebuffer for sun4m machines available in both 1024x768
(OpenBIOS) and 1152x900 (OBP) resolutions aimed at people wishing to
run older Solaris versions.</dd>
<dt>
<strong><strong>virtio</strong></strong>
</dt>
<dd>Virtio VGA card.</dd>
<dt>
<strong><strong>none</strong></strong>
</dt>
<dd>Disable VGA card.</dd>
</dl>
</dd>
<dt>
<strong><strong>-full-screen</strong></strong>
</dt>
<dd>Start in full screen.</dd>
<dt>
<strong>*-g</strong> /width/*x*/height/*[x*/depth/*]**
</dt>
<dd>Set the initial graphical
resolution and depth (PPC, SPARC only).

For PPC the default is 800x600x32.

For SPARC with the TCX graphics device, the default is 1024x768x8 with
the option of 1024x768x24. For cgthree, the default is 1024x768x8 with
the option of 1152x900x8 for people who wish to use OBP.</dd>
<dt>
<strong>*-vnc</strong> display[,option[,option[,…]]]*
</dt>
<dd>
<p>Normally, if QEMU is
compiled with graphical window support, it displays output such as
guest graphics, guest console, and the QEMU monitor in a window. With
this option, you can have QEMU listen on VNC display display and
redirect the VGA display over the VNC session. It is very useful to
enable the usb tablet device when using this option (option <strong>-device
usb-tablet</strong>). When using the VNC display, you must use the <strong>-k</strong>
parameter to set the keyboard layout if you are not using en-us. Valid
syntax for the display is</p>
<dl>
<dt>
<strong><strong>to=L</strong></strong>
</dt>
<dd>With this option, QEMU will try next available VNC
displays, until the number L, if the originally defined &#34;-vnc
display&#34; is not available, e.g. port 5900+display is already used by
another application. By default, to=0.</dd>
<dt>
<strong><strong>host:d</strong></strong>
</dt>
<dd>TCP connections will only be allowed from host on
display d. By convention the TCP port is 5900+d. Optionally, host
can be omitted in which case the server will accept connections from
any host.</dd>
<dt>
<strong><strong>unix:path</strong></strong>
</dt>
<dd>Connections will be allowed over UNIX domain
sockets where path is the location of a unix socket to listen for
connections on.</dd>
<dt>
<strong><strong>none</strong></strong>
</dt>
<dd>VNC is initialized but not started. The monitor <strong>change</strong>
command can be used to later start the VNC server.</dd>
</dl>
</dd>
</dl>
<p>Following the display value there may be one or more option flags
separated by commas. Valid options are</p>
<blockquote>
<dl>
<dt>
<strong><strong>reverse=on|off</strong></strong>
</dt>
<dd>Connect to a listening VNC client via a
&#34;reverse&#34; connection. The client is specified by the display. For
reverse network connections (host:d,``reverse``), the d argument is a
TCP port number, not a display number.</dd>
<dt>
<strong><strong>websocket=on|off</strong></strong>
</dt>
<dd>Opens an additional TCP listening port
dedicated to VNC Websocket connections. If a bare websocket option is
given, the Websocket port is 5700+display. An alternative port can be
specified with the syntax *websocket*=port.

If host is specified connections will only be allowed from this host.
It is possible to control the websocket listen address independently,
using the syntax *websocket*=host:port.

Websocket could be allowed over UNIX domain socket, using the syntax
*websocket*=unix:path, where path is the location of a unix socket to
listen for connections on.

If no TLS credentials are provided, the websocket connection runs in
unencrypted mode. If TLS credentials are provided, the websocket
connection requires encrypted client connections.</dd>
<dt>
<strong><strong>password=on|off</strong></strong>
</dt>
<dd>Require that password based authentication is
used for client connections.

The password must be set separately using the <strong>set_password</strong> command
in the <em>QEMU Monitor</em>. The syntax to change your password is:
<strong>set_password &lt;protocol&gt; &lt;password&gt;</strong> where &lt;protocol&gt; could be either
&#34;vnc&#34; or &#34;spice&#34;.

If you would like to change &lt;protocol&gt; password expiration, you should
use <strong>expire_password &lt;protocol&gt; &lt;expiration-time&gt;</strong> where expiration
time could be one of the following options: now, never, +seconds or
UNIX time of expiration, e.g. +60 to make password expire in 60
seconds, or 1335196800 to make password expire on &#34;Mon Apr 23 12:00:00
EDT 2012&#34; (UNIX time for this date and time).

You can also use keywords &#34;now&#34; or &#34;never&#34; for the expiration time to
allow &lt;protocol&gt; password to expire immediately or never expire.</dd>
<dt>
<strong><strong>password-secret=&lt;secret-id&gt;</strong></strong>
</dt>
<dd>Require that password based
authentication is used for client connections, using the password
provided by the <strong>secret</strong> object identified by <strong>secret-id</strong>.</dd>
<dt>
<strong><strong>tls-creds=ID</strong></strong>
</dt>
<dd>Provides the ID of a set of TLS credentials to use
to secure the VNC server. They will apply to both the normal VNC
server socket and the websocket socket (if enabled). Setting TLS
credentials will cause the VNC server socket to enable the VeNCrypt
auth mechanism. The credentials should have been previously created
using the <strong>-object tls-creds</strong> argument.</dd>
<dt>
<strong><strong>tls-authz=ID</strong></strong>
</dt>
<dd>Provides the ID of the QAuthZ authorization object
against which the client&#39;s x509 distinguished name will validated.
This object is only resolved at time of use, so can be deleted and
recreated on the fly while the VNC server is active. If missing, it
will default to denying access.</dd>
<dt>
<strong><strong>sasl=on|off</strong></strong>
</dt>
<dd>Require that the client use SASL to authenticate
with the VNC server. The exact choice of authentication method used is
controlled from the system / user&#39;s SASL configuration file for the
&#39;qemu&#39; service. This is typically found in /etc/sasl2/qemu.conf. If
running QEMU as an unprivileged user, an environment variable
SASL_CONF_PATH can be used to make it search alternate locations for
the service config. While some SASL auth methods can also provide data
encryption (eg GSSAPI), it is recommended that SASL always be combined
with the &#39;tls&#39; and &#39;x509&#39; settings to enable use of SSL and server
certificates. This ensures a data encryption preventing compromise of
authentication credentials. See the <em>VNC security</em> section in the
System Emulation Users Guide for details on using SASL authentication.</dd>
<dt>
<strong><strong>sasl-authz=ID</strong></strong>
</dt>
<dd>Provides the ID of the QAuthZ authorization
object against which the client&#39;s SASL username will validated. This
object is only resolved at time of use, so can be deleted and
recreated on the fly while the VNC server is active. If missing, it
will default to denying access.</dd>
<dt>
<strong><strong>acl=on|off</strong></strong>
</dt>
<dd>Legacy method for enabling authorization of clients
against the x509 distinguished name and SASL username. It results in
the creation of two <strong>authz-list</strong> objects with IDs of <strong>vnc.username</strong>
and <strong>vnc.x509dname</strong>. The rules for these objects must be configured
with the HMP ACL commands.

This option is deprecated and should no longer be used. The new
<strong>sasl-authz</strong> and <strong>tls-authz</strong> options are a replacement.</dd>
<dt>
<strong><strong>lossy=on|off</strong></strong>
</dt>
<dd>Enable lossy compression methods (gradient, JPEG,
…). If this option is set, VNC client may receive lossy framebuffer
updates depending on its encoding settings. Enabling this option can
save a lot of bandwidth at the expense of quality.</dd>
<dt>
<strong><strong>non-adaptive=on|off</strong></strong>
</dt>
<dd>Disable adaptive encodings. Adaptive
encodings are enabled by default. An adaptive encoding will try to
detect frequently updated screen regions, and send updates in these
regions using a lossy encoding (like JPEG). This can be really helpful
to save bandwidth when playing videos. Disabling adaptive encodings
restores the original static behavior of encodings like Tight.</dd>
<dt>
<strong><strong>share=[allow-exclusive|force-shared|ignore]</strong></strong>
</dt>
<dd>Set display sharing
policy. &#39;allow-exclusive&#39; allows clients to ask for exclusive access.
As suggested by the rfb spec this is implemented by dropping other
connections. Connecting multiple clients in parallel requires all
clients asking for a shared session (vncviewer: -shared switch). This
is the default. &#39;force-shared&#39; disables exclusive client access.
Useful for shared desktop sessions, where you don&#39;t want someone
forgetting specify -shared disconnect everybody else. &#39;ignore&#39;
completely ignores the shared flag and allows everybody connect
unconditionally. Doesn&#39;t conform to the rfb spec but is traditional
QEMU behavior.</dd>
<dt>
<strong><strong>key-delay-ms</strong></strong>
</dt>
<dd>Set keyboard delay, for key down and key up
events, in milliseconds. Default is 10. Keyboards are low-bandwidth
devices, so this slowdown can help the device and guest to keep up and
not lose events in case events are arriving in bulk. Possible causes
for the latter are flaky network connections, or scripts for automated
testing.</dd>
<dt>
<strong><strong>audiodev=audiodev</strong></strong>
</dt>
<dd>Use the specified audiodev when the VNC
client requests audio transmission. When not using an -audiodev
argument, this option must be omitted, otherwise is must be present
and specify a valid audiodev.</dd>
<dt>
<strong><strong>power-control=on|off</strong></strong>
</dt>
<dd>Permit the remote client to issue
shutdown, reboot or reset power control requests.</dd>
</dl>
</blockquote>
</blockquote>
</div>
</div>
<div id="outline-container-headline-10" class="outline-3">
<h3 id="headline-10">
i386 target only
</h3>
<div id="outline-text-headline-10" class="outline-text-3">
<blockquote>
<dl>
<dt>
<strong><strong>-win2k-hack</strong></strong>
</dt>
<dd>Use it when installing Windows 2000 to avoid a disk
full bug. After Windows 2000 is installed, you no longer need this
option (this option slows down the IDE transfers). Synonym of
<strong>-global</strong> ide-device.win2k-install-hack=on.</dd>
<dt>
<strong><strong>-no-fd-bootchk</strong></strong>
</dt>
<dd>Disable boot signature checking for floppy disks
in BIOS. May be needed to boot from old floppy disks. Synonym of <strong>-m
fd-bootchk=off</strong>.</dd>
<dt>
?
</dt>
<dd><strong>*-acpitable</strong>
[sig=str][,rev=n][,oem_id=str][,oem_table_id=str][,oem_rev=n]
[,asl_compiler_id=str][,asl_compiler_rev=n][,data=file1[:file2]…]* :: Add
ACPI table with specified header fields and context from specified
files. For file=, take whole ACPI table from the specified files,
including all ACPI headers (possible overridden by other options). For
data=, only data portion of the table is used, all header information
is specified in the command line. If a SLIC table is supplied to QEMU,
then the SLIC&#39;s oem_id and oem_table_id fields will override the same
in the RSDT and the FADT (a.k.a. FACP), in order to ensure the field
matches required by the Microsoft SLIC spec and the ACPI spec.</dd>
<dt>
<strong>*-smbios</strong> file=binary*
</dt>
<dd>Load SMBIOS entry from binary file.</dd>
<dt>
?
</dt>
<dd><strong>*-smbios</strong>
type=0[,vendor=str][,version=str][,date=str][,release=%d.%d][,uefi=on|off]* :: Specify
SMBIOS type 0 fields</dd>
<dt>
?
</dt>
<dd><strong>*-smbios</strong>
type=1[,manufacturer=str][,product=str][,version=str][,serial=str][,uuid=uuid][,sku=str][,family=str]* :: Specify
SMBIOS type 1 fields</dd>
<dt>
?
</dt>
<dd><strong>*-smbios</strong>
type=2[,manufacturer=str][,product=str][,version=str][,serial=str][,asset=str][,location=str]* :: Specify
SMBIOS type 2 fields</dd>
<dt>
?
</dt>
<dd><strong>*-smbios</strong>
type=3[,manufacturer=str][,version=str][,serial=str][,asset=str][,sku=str]* :: Specify
SMBIOS type 3 fields</dd>
<dt>
?
</dt>
<dd><strong>*-smbios</strong>
type=4[,sock_pfx=str][,manufacturer=str][,version=str][,serial=str][,asset=str][,part=str][,processor-family=%d][,processor-id=%d]* :: Specify
SMBIOS type 4 fields</dd>
<dt>
?
</dt>
<dd><strong>*-smbios</strong>
type=9[,slot_designation=str][,slot_type=%d][,slot_data_bus_width=%d][,current_usage=%d][,slot_length=%d][,slot_id=%d][,slot_characteristics1=%d][,slot_characteristics12=%d][,pci_device=str]* :: Specify
SMBIOS type 9 fields</dd>
<dt>
<strong>*-smbios</strong> type=11[,value=str][,path=filename]*
</dt>
<dd>
<p>Specify SMBIOS type
11 fields</p>
<p>
This argument can be repeated multiple times, and values are added in
the order they are parsed. Applications intending to use OEM strings
data are encouraged to use their application name as a prefix for the
value string. This facilitates passing information for multiple
applications concurrently.</p>
<p>
The <strong>value=str</strong> syntax provides the string data inline, while the
<strong>path=filename</strong> syntax loads data from a file on disk. Note that the
file is not permitted to contain any NUL bytes.</p>
<p>
Both the <strong>value</strong> and <strong>path</strong> options can be repeated multiple times and
will be added to the SMBIOS table in the order in which they appear.</p>
<p>
Note that on the x86 architecture, the total size of all SMBIOS tables
is limited to 65535 bytes. Thus the OEM strings data is not suitable
for passing large amounts of data into the guest. Instead it should be
used as a indicator to inform the guest where to locate the real data
set, for example, by specifying the serial ID of a block device.</p>
<p>
An example passing three strings is</p>
<blockquote>
<pre class="example">
-smbios type=11,value=cloud-init:ds=nocloud-net;s=http://10.10.0.1:8000/,\
                value=anaconda:method=http://dl.fedoraproject.org/pub/fedora/linux/releases/25/x86_64/os,\
                path=/some/file/with/oemstringsdata.txt
</pre>
</blockquote>
</dd>
</dl>
<p>In the guest OS this is visible with the <strong>dmidecode</strong> command</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<pre class="example">
$ dmidecode -t 11
Handle 0x0E00, DMI type 11, 5 bytes
OEM Strings
     String 1: cloud-init:ds=nocloud-net;s=http://10.10.0.1:8000/
     String 2: anaconda:method=http://dl.fedoraproject.org/pub/fedora/linux/releases/25/x86_64/os
     String 3: myapp:some extra data
</pre>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li><strong>*-smbios</strong>
type=17[,loc_pfx=str][,bank=str][,manufacturer=str][,serial=str][,asset=str][,part=str][,speed=%d]* :: Specify
SMBIOS type 17 fields</li>
<li>
<p><strong>*-smbios</strong>
type=41[,designation=str][,kind=str][,instance=%d][,pcidev=str]* :: Specify
SMBIOS type 41 fields</p>
<p>
This argument can be repeated multiple times. Its main use is to allow
network interfaces be created as <strong>enoX</strong> on Linux, with X being the
instance number, instead of the name depending on the interface
position on the PCI bus.</p>
<p>
Here is an example of use:</p>
<blockquote>
<pre class="example">
-netdev user,id=internet \
-device virtio-net-pci,mac=50:54:00:00:00:42,netdev=internet,id=internet-dev \
-smbios type=41,designation=&#39;Onboard LAN&#39;,instance=1,kind=ethernet,pcidev=internet-dev
</pre>
</blockquote>
</li>
</ul>
<p>In the guest OS, the device should then appear as <strong>eno1</strong>:</p>
<p>
..parsed-literal:</p>
<blockquote>
<blockquote>
<pre class="example">
$ ip -brief l
lo               UNKNOWN        00:00:00:00:00:00 &lt;LOOPBACK,UP,LOWER_UP&gt;
eno1             UP             50:54:00:00:00:42 &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;
</pre>
</blockquote>
</blockquote>
<p>
Currently, the PCI device has to be attached to the root bus.</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-11" class="outline-3">
<h3 id="headline-11">
Network options
</h3>
<div id="outline-text-headline-11" class="outline-text-3">
<blockquote>
<ul>
<li>
<p><strong>*-nic</strong>
[tap|bridge|user|l2tpv3|vde|netmap|af-xdp|vhost-user|socket][,…][,mac=macaddr][,model=mn]* :: This
option is a shortcut for configuring both the on-board (default) guest
NIC hardware and the host network backend in one go. The host backend
options are the same as with the corresponding <strong>-netdev</strong> options
below. The guest NIC model can be set with <strong>model=modelname</strong>. Use
<strong>model=help</strong> to list the available device types. The hardware MAC
address can be set with <strong>mac=macaddr</strong>.</p>
<p>
The following two example do exactly the same, to show how <strong>-nic</strong> can
be used to shorten the command line length:</p>
<blockquote>
<pre class="example">
qemu-system-x86_64 -netdev user,id=n1,ipv6=off -device e1000,netdev=n1,mac=52:54:98:76:54:32
qemu-system-x86_64 -nic user,ipv6=off,model=e1000,mac=52:54:98:76:54:32
</pre>
</blockquote>
</li>
<li><strong>*-nic</strong> none* :: Indicate that no network devices should be
configured. It is used to override the default configuration (default
NIC with &#34;user&#34; host network backend) which is activated if no other
networking options are provided.</li>
<li>
<p><strong>*-netdev</strong> user,id=id[,option][,option][,…]* :: Configure user mode
host network backend which requires no administrator privilege to run.
Valid options are:</p>
<dl>
<dt>
<strong><strong>id=id</strong></strong>
</dt>
<dd>Assign symbolic name for use in monitor commands.</dd>
<dt>
<strong>*ipv4=on|off</strong> and ipv6=on|off*
</dt>
<dd>Specify that either IPv4 or IPv6
must be enabled. If neither is specified both protocols are enabled.</dd>
<dt>
<strong><strong>net=addr[/mask]</strong></strong>
</dt>
<dd>Set IP network address the guest will see.
Optionally specify the netmask, either in the form a.b.c.d or as
number of valid top-most bits. Default is 10.0.2.0/24.</dd>
<dt>
<strong><strong>host=addr</strong></strong>
</dt>
<dd>Specify the guest-visible address of the host.
Default is the 2nd IP in the guest network, i.e. x.x.x.2.</dd>
<dt>
<strong><strong>ipv6-net=addr[/int]</strong></strong>
</dt>
<dd>Set IPv6 network address the guest will
see (default is fec0::/64). The network prefix is given in the usual
hexadecimal IPv6 address notation. The prefix size is optional, and
is given as the number of valid top-most bits (default is 64).</dd>
<dt>
<strong><strong>ipv6-host=addr</strong></strong>
</dt>
<dd>Specify the guest-visible IPv6 address of the
host. Default is the 2nd IPv6 in the guest network, i.e. xxxx::2.</dd>
<dt>
<strong><strong>restrict=on|off</strong></strong>
</dt>
<dd>If this option is enabled, the guest will be
isolated, i.e. it will not be able to contact the host and no guest
IP packets will be routed over the host to the outside. This option
does not affect any explicitly set forwarding rules.</dd>
<dt>
<strong><strong>hostname=name</strong></strong>
</dt>
<dd>Specifies the client hostname reported by the
built-in DHCP server.</dd>
<dt>
<strong><strong>dhcpstart=addr</strong></strong>
</dt>
<dd>Specify the first of the 16 IPs the built-in
DHCP server can assign. Default is the 15th to 31st IP in the guest
network, i.e. x.x.x.15 to x.x.x.31.</dd>
<dt>
<strong><strong>dns=addr</strong></strong>
</dt>
<dd>Specify the guest-visible address of the virtual
nameserver. The address must be different from the host address.
Default is the 3rd IP in the guest network, i.e. x.x.x.3.</dd>
<dt>
<strong><strong>ipv6-dns=addr</strong></strong>
</dt>
<dd>Specify the guest-visible address of the IPv6
virtual nameserver. The address must be different from the host
address. Default is the 3rd IP in the guest network, i.e. xxxx::3.</dd>
<dt>
<strong><strong>dnssearch=domain</strong></strong>
</dt>
<dd>
<p>Provides an entry for the domain-search list
sent by the built-in DHCP server. More than one domain suffix can be
transmitted by specifying this option multiple times. If supported,
this will cause the guest to automatically try to append the given
domain suffix(es) in case a domain name can not be resolved.</p>
<p>
Example:</p>
<blockquote>
<pre class="example">
qemu-system-x86_64 -nic user,dnssearch=mgmt.example.org,dnssearch=example.org
</pre>
</blockquote>
</dd>
<dt>
<strong><strong>domainname=domain</strong></strong>
</dt>
<dd>Specifies the client domain name reported
by the built-in DHCP server.</dd>
<dt>
<strong><strong>tftp=dir</strong></strong>
</dt>
<dd>When using the user mode network stack, activate a
built-in TFTP server. The files in dir will be exposed as the root
of a TFTP server. The TFTP client on the guest must be configured in
binary mode (use the command <strong>bin</strong> of the Unix TFTP client). The
built-in TFTP server is read-only; it does not implement any command
for writing files. QEMU will not write to this directory.</dd>
<dt>
<strong><strong>tftp-server-name=name</strong></strong>
</dt>
<dd>In BOOTP reply, broadcast name as the
&#34;TFTP server name&#34; (RFC2132 option 66). This can be used to advise
the guest to load boot files or configurations from a different
server than the host address.</dd>
<dt>
<strong><strong>bootfile=file</strong></strong>
</dt>
<dd>
<p>When using the user mode network stack,
broadcast file as the BOOTP filename. In conjunction with <strong>tftp</strong>,
this can be used to network boot a guest from a local directory.</p>
<p>
Example (using pxelinux):</p>
<blockquote>
<pre class="example">
qemu-system-x86_64 -hda linux.img -boot n -device e1000,netdev=n1 \
    -netdev user,id=n1,tftp=/path/to/tftp/files,bootfile=/pxelinux.0
</pre>
</blockquote>
</dd>
<dt>
<strong><strong>smb=dir[,smbserver=addr]</strong></strong>
</dt>
<dd>
<p>When using the user mode network
stack, activate a built-in SMB server so that Windows OSes can
access to the host files in <strong>dir</strong> transparently. The IP address of
the SMB server can be set to addr. By default the 4th IP in the
guest network is used, i.e. x.x.x.4.</p>
<p>
In the guest Windows OS, the line:</p>
<blockquote>
<pre class="example">
10.0.2.4 smbserver
</pre>
</blockquote>
</dd>
</dl>
<p>must be added in the file <strong>C:\WINDOWS\LMHOSTS</strong> (for windows 9x/Me) or
<strong>C:\WINNT§YSTEM32\DRIVERS\ETC\LMHOSTS</strong> (Windows NT/2000).</p>
<p>
Then <strong>dir</strong> can be accessed in <strong>\\smbserver\qemu</strong>.</p>
<p>
Note that a SAMBA server must be installed on the host OS.</p>
<dl>
<dt>
<strong><strong>hostfwd=[tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport</strong></strong>
</dt>
<dd>
<p>Redirect
incoming TCP or UDP connections to the host port hostport to the
guest IP address guestaddr on guest port guestport. If guestaddr is
not specified, its value is x.x.x.15 (default first address given by
the built-in DHCP server). By specifying hostaddr, the rule can be
bound to a specific host interface. If no connection type is set,
TCP is used. This option can be given multiple times.</p>
<p>
For example, to redirect host X11 connection from screen 1 to guest
screen 0, use the following:</p>
<blockquote>
<pre class="example">
# on the host
qemu-system-x86_64 -nic user,hostfwd=tcp:127.0.0.1:6001-:6000
# this host xterm should open in the guest X11 server
xterm -display :1
</pre>
</blockquote>
</dd>
</dl>
<p>To redirect telnet connections from host port 5555 to telnet port on
the guest, use the following:</p>
<blockquote>
<blockquote>
<pre class="example">
# on the host
qemu-system-x86_64 -nic user,hostfwd=tcp::5555-:23
telnet localhost 5555
</pre>
</blockquote>
</blockquote>
<p>
Then when you use on the host <strong>telnet localhost 5555</strong>, you connect to
the guest telnet server.</p>
<ul>
<li>
<p><strong>*guestfwd=[tcp]:server:port-dev</strong>;
<strong>guestfwd=[tcp]:server:port-cmd:command*</strong> :: Forward guest TCP
connections to the IP address server on port port to the character
device dev or to a program executed by cmd:command which gets
spawned for each connection. This option can be given multiple
times.</p>
<p>
You can either use a chardev directly and have that one used
throughout QEMU&#39;s lifetime, like in the following example:</p>
<blockquote>
<pre class="example">
# open 10.10.1.1:4321 on bootup, connect 10.0.2.100:1234 to it whenever
# the guest accesses it
qemu-system-x86_64 -nic user,guestfwd=tcp:10.0.2.100:1234-tcp:10.10.1.1:4321
</pre>
</blockquote>
</li>
</ul>
<p>Or you can execute a command on every TCP connection established by
the guest, so that QEMU behaves similar to an inetd process for that
virtual server:</p>
<blockquote>
<blockquote>
<pre class="example">
# call &#34;netcat 10.10.1.1 4321&#34; on every TCP connection to 10.0.2.100:1234
# and connect the TCP stream to its stdin/stdout
qemu-system-x86_64 -nic  &#39;user,id=n1,guestfwd=tcp:10.0.2.100:1234-cmd:netcat 10.10.1.1 4321&#39;
</pre>
</blockquote>
</blockquote>
</li>
<li>
<p><strong>*-netdev</strong>
tap,id=id[,fd=h][,ifname=name][,script=file][,downscript=dfile][,br=bridge][,helper=helper]* :: Configure
a host TAP network backend with ID id.</p>
<p>
Use the network script file to configure it and the network script
dfile to deconfigure it. If name is not provided, the OS automatically
provides one. The default network configure script is <strong>/etc/qemu-ifup</strong>
and the default network deconfigure script is <strong>/etc/qemu-ifdown</strong>. Use
<strong>script=no</strong> or <strong>downscript=no</strong> to disable script execution.</p>
<p>
If running QEMU as an unprivileged user, use the network helper to
configure the TAP interface and attach it to the bridge. The default
network helper executable is <strong>/path/to/qemu-bridge-helper</strong> and the
default bridge device is <strong>br0</strong>.</p>
<p>
*fd*=h can be used to specify the handle of an already opened host TAP
interface.</p>
<p>
Examples:</p>
<blockquote>
<pre class="example">
#launch a QEMU instance with the default network script
qemu-system-x86_64 linux.img -nic tap
</pre>
</blockquote>
</li>
</ul>
<blockquote>
<blockquote>
<pre class="example">
#launch a QEMU instance with two NICs, each one connected
#to a TAP device
qemu-system-x86_64 linux.img \
        -netdev tap,id=nd0,ifname=tap0 -device e1000,netdev=nd0 \
        -netdev tap,id=nd1,ifname=tap1 -device rtl8139,netdev=nd1
</pre>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<pre class="example">
#launch a QEMU instance with the default network helper to
#connect a TAP device to bridge br0
qemu-system-x86_64 linux.img -device virtio-net-pci,netdev=n1 \
        -netdev tap,id=n1,&#34;helper=/path/to/qemu-bridge-helper&#34;
</pre>
</blockquote>
</blockquote>
<dl>
<dt>
<strong>*-netdev</strong> bridge,id=id[,br=bridge][,helper=helper]*
</dt>
<dd>
<p>Connect a host
TAP network interface to a host bridge device.</p>
<p>
Use the network helper helper to configure the TAP interface and
attach it to the bridge. The default network helper executable is
<strong>/path/to/qemu-bridge-helper</strong> and the default bridge device is <strong>br0</strong>.</p>
<p>
Examples:</p>
<blockquote>
<pre class="example">
#launch a QEMU instance with the default network helper to
#connect a TAP device to bridge br0
qemu-system-x86_64 linux.img -netdev bridge,id=n1 -device virtio-net,netdev=n1
</pre>
</blockquote>
</dd>
</dl>
<blockquote>
<blockquote>
<pre class="example">
#launch a QEMU instance with the default network helper to
#connect a TAP device to bridge qemubr0
qemu-system-x86_64 linux.img -netdev bridge,br=qemubr0,id=n1 -device virtio-net,netdev=n1
</pre>
</blockquote>
</blockquote>
<ul>
<li>
<p><strong>*-netdev</strong>
socket,id=id[,fd=h][,listen=[host]:port][,connect=host:port]* :: This
host network backend can be used to connect the guest&#39;s network to
another QEMU virtual machine using a TCP socket connection. If
<strong>listen</strong> is specified, QEMU waits for incoming connections on port
(host is optional). <strong>connect</strong> is used to connect to another QEMU
instance using the <strong>listen</strong> option. *fd*=h specifies an already opened
TCP socket.</p>
<p>
Example:</p>
<blockquote>
<pre class="example">
# launch a first QEMU instance
qemu-system-x86_64 linux.img \
                 -device e1000,netdev=n1,mac=52:54:00:12:34:56 \
                 -netdev socket,id=n1,listen=:1234
# connect the network of this instance to the network of the first instance
qemu-system-x86_64 linux.img \
                 -device e1000,netdev=n2,mac=52:54:00:12:34:57 \
                 -netdev socket,id=n2,connect=127.0.0.1:1234
</pre>
</blockquote>
</li>
<li>
<p><strong>*-netdev</strong>
socket,id=id[,fd=h][,mcast=maddr:port[,localaddr=addr]]* :: Configure
a socket host network backend to share the guest&#39;s network traffic
with another QEMU virtual machines using a UDP multicast socket,
effectively making a bus for every QEMU with same multicast address
maddr and port. NOTES:</p>
<ol>
<li>Several QEMU can be running on different hosts and share same bus
(assuming correct multicast setup for these hosts).</li>
<li>mcast support is compatible with User Mode Linux (argument
<strong>ethN=mcast</strong>), see <em><a href="http://user-mode-linux.sf.net">http://user-mode-linux.sf.net</a></em>.</li>
<li>Use <strong>fd=h</strong> to specify an already opened UDP multicast socket.</li>
</ol>
</li>
</ul>
<p>Example:</p>
<blockquote>
<blockquote>
<pre class="example">
# launch one QEMU instance
qemu-system-x86_64 linux.img \
                 -device e1000,netdev=n1,mac=52:54:00:12:34:56 \
                 -netdev socket,id=n1,mcast=230.0.0.1:1234
# launch another QEMU instance on same &#34;bus&#34;
qemu-system-x86_64 linux.img \
                 -device e1000,netdev=n2,mac=52:54:00:12:34:57 \
                 -netdev socket,id=n2,mcast=230.0.0.1:1234
# launch yet another QEMU instance on same &#34;bus&#34;
qemu-system-x86_64 linux.img \
                 -device e1000,netdev=n3,mac=52:54:00:12:34:58 \
                 -netdev socket,id=n3,mcast=230.0.0.1:1234
</pre>
</blockquote>
</blockquote>
<p>
Example (User Mode Linux compat.):</p>
<blockquote>
<blockquote>
<pre class="example">
# launch QEMU instance (note mcast address selected is UML&#39;s default)
qemu-system-x86_64 linux.img \
                 -device e1000,netdev=n1,mac=52:54:00:12:34:56 \
                 -netdev socket,id=n1,mcast=239.192.168.1:1102
# launch UML
/path/to/linux ubd0=/path/to/root_fs eth0=mcast
</pre>
</blockquote>
</blockquote>
<p>
Example (send packets from host&#39;s 1.2.3.4):</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 linux.img \
                 -device e1000,netdev=n1,mac=52:54:00:12:34:56 \
                 -netdev socket,id=n1,mcast=239.192.168.1:1102,localaddr=1.2.3.4
</pre>
</blockquote>
</blockquote>
<ul>
<li>
<p><strong>*-netdev</strong>
stream,id=str[,server=on|off],addr.type=inet,addr.host=host,addr.port=port[,to=maxport][,numeric=on|off][,keep-alive=on|off][,mptcp=on|off][,addr.ipv4=on|off][,addr.ipv6=on|off][,reconnect=seconds]* :: Configure
a network backend to connect to another QEMU virtual machine or a
proxy using a TCP/IP socket.</p>
<dl>
<dt>
<strong><strong>server=on|off</strong></strong>
</dt>
<dd>if <strong>on</strong> create a server socket</dd>
<dt>
<strong><strong>addr.host=host,addr.port=port</strong></strong>
</dt>
<dd>socket address to listen on
(server=on) or connect to (server=off)</dd>
<dt>
<strong><strong>to=maxport</strong></strong>
</dt>
<dd>if present, this is range of possible addresses,
with port between <strong>port</strong> and <strong>maxport</strong>.</dd>
<dt>
<strong><strong>numeric=on|off</strong></strong>
</dt>
<dd>if <strong>on</strong> <strong>host</strong> and <strong>port</strong> are guaranteed to be
numeric, otherwise a name resolution should be attempted (default:
<strong>off</strong>)</dd>
<dt>
<strong><strong>keep-alive=on|off</strong></strong>
</dt>
<dd>enable keep-alive when connecting to this
socket. Not supported for passive sockets.</dd>
<dt>
<strong><strong>mptcp=on|off</strong></strong>
</dt>
<dd>enable multipath TCP</dd>
<dt>
<strong><strong>ipv4=on|off</strong></strong>
</dt>
<dd>whether to accept IPv4 addresses, default to try
both IPv4 and IPv6</dd>
<dt>
<strong><strong>ipv6=on|off</strong></strong>
</dt>
<dd>whether to accept IPv6 addresses, default to try
both IPv4 and IPv6</dd>
<dt>
<strong><strong>reconnect=seconds</strong></strong>
</dt>
<dd>for a client socket, if a socket is
disconnected, then attempt a reconnect after the given number of
seconds. Setting this to zero disables this function. (default: 0)</dd>
</dl>
</li>
</ul>
<p>Example (two guests connected using a TCP/IP socket):</p>
<blockquote>
<blockquote>
<pre class="example">
# first VM
qemu-system-x86_64 linux.img \
              -device virtio-net,netdev=net0,mac=52:54:00:12:34:56 \
              -netdev stream,id=net0,server=on,addr.type=inet,addr.host=localhost,addr.port=1234
# second VM
qemu-system-x86_64 linux.img \
              -device virtio-net,netdev=net0,mac=52:54:00:12:34:57 \
              -netdev stream,id=net0,server=off,addr.type=inet,addr.host=localhost,addr.port=1234,reconnect=5
</pre>
</blockquote>
</blockquote>
<ul>
<li>
<p><strong>*-netdev</strong>
stream,id=str[,server=on|off],addr.type=unix,addr.path=path[,abstract=on|off][,tight=on|off][,reconnect=seconds]* :: Configure
a network backend to connect to another QEMU virtual machine or a
proxy using a stream oriented unix domain socket.</p>
<dl>
<dt>
<strong><strong>server=on|off</strong></strong>
</dt>
<dd>if <strong>on</strong> create a server socket</dd>
<dt>
<strong><strong>addr.path=path</strong></strong>
</dt>
<dd>filesystem path to use</dd>
<dt>
<strong><strong>abstract=on|off</strong></strong>
</dt>
<dd>if <strong>on</strong>, this is a Linux abstract socket
address.</dd>
<dt>
<strong><strong>tight=on|off</strong></strong>
</dt>
<dd>if false, pad an abstract socket address with
enough null bytes to make it fill struct sockaddr_un member
sun_path.</dd>
<dt>
<strong><strong>reconnect=seconds</strong></strong>
</dt>
<dd>for a client socket, if a socket is
disconnected, then attempt a reconnect after the given number of
seconds. Setting this to zero disables this function. (default: 0)</dd>
</dl>
</li>
</ul>
<p>Example (using passt as a replacement of -netdev user):</p>
<blockquote>
<blockquote>
<pre class="example">
# start passt server as a non privileged user
passt
UNIX domain socket bound at /tmp/passt_1.socket
# start QEMU to connect to passt
qemu-system-x86_64 linux.img \
              -device virtio-net,netdev=net0 \
              -netdev stream,id=net0,server=off,addr.type=unix,addr.path=/tmp/passt_1.socket
</pre>
</blockquote>
</blockquote>
<p>
Example (two guests connected using a stream oriented unix domain
socket):</p>
<blockquote>
<blockquote>
<pre class="example">
# first VM
qemu-system-x86_64 linux.img \
              -device virtio-net,netdev=net0,mac=52:54:00:12:34:56 \
              netdev stream,id=net0,server=on,addr.type=unix,addr.path=/tmp/qemu0
# second VM
qemu-system-x86_64 linux.img \
              -device virtio-net,netdev=net0,mac=52:54:00:12:34:57 \
              -netdev stream,id=net0,server=off,addr.type=unix,addr.path=/tmp/qemu0,reconnect=5
</pre>
</blockquote>
</blockquote>
<ul>
<li>
<p><strong>*-netdev</strong>
stream,id=str[,server=on|off],addr.type=fd,addr.str=file-descriptor[,reconnect=seconds]* :: Configure
a network backend to connect to another QEMU virtual machine or a
proxy using a stream oriented socket file descriptor.</p>
<dl>
<dt>
<strong><strong>server=on|off</strong></strong>
</dt>
<dd>if <strong>on</strong> create a server socket</dd>
<dt>
<strong><strong>addr.str=file-descriptor</strong></strong>
</dt>
<dd>file descriptor number to use as a
socket</dd>
<dt>
<strong><strong>reconnect=seconds</strong></strong>
</dt>
<dd>for a client socket, if a socket is
disconnected, then attempt a reconnect after the given number of
seconds. Setting this to zero disables this function. (default: 0)</dd>
</dl>
</li>
<li>
<p><strong>*-netdev</strong>
dgram,id=str,remote.type=inet,remote.host=maddr,remote.port=port[,local.type=inet,local.host=addr]* :: Configure
a network backend to connect to a multicast address.</p>
<dl>
<dt>
<strong><strong>remote.host=maddr,remote.port=port</strong></strong>
</dt>
<dd>multicast address</dd>
<dt>
<strong><strong>local.host=addr</strong></strong>
</dt>
<dd>specify the host address to send packets from</dd>
</dl>
</li>
</ul>
<p>Example:</p>
<blockquote>
<blockquote>
<pre class="example">
# launch one QEMU instance
qemu-system-x86_64 linux.img \
              -device virtio-net,netdev=net0,mac=52:54:00:12:34:56 \
              -netdev dgram,id=net0,remote.type=inet,remote.host=224.0.0.1,remote.port=1234
# launch another QEMU instance on same &#34;bus&#34;
qemu-system-x86_64 linux.img \
              -device virtio-net,netdev=net0,mac=52:54:00:12:34:57 \
              -netdev dgram,id=net0,remote.type=inet,remote.host=224.0.0.1,remote.port=1234
# launch yet another QEMU instance on same &#34;bus&#34;
qemu-system-x86_64 linux.img \
              -device virtio-net,netdev=net0,mac=52:54:00:12:34:58 \
              -netdev dgram,id=net0,remote.type=inet,remote.host=224.0.0.1,remote.port=1234
</pre>
</blockquote>
</blockquote>
<ul>
<li>
<p><strong>*-netdev</strong>
dgram,id=str,remote.type=inet,remote.host=maddr,remote.port=port[,local.type=fd,local.str=file-descriptor]* :: Configure
a network backend to connect to a multicast address using a UDP socket
file descriptor.</p>
<dl>
<dt>
<strong><strong>remote.host=maddr,remote.port=port</strong></strong>
</dt>
<dd>multicast address</dd>
<dt>
<strong><strong>local.str=file-descriptor</strong></strong>
</dt>
<dd>File descriptor to use to send
packets</dd>
</dl>
</li>
<li>
<p><strong>*-netdev</strong>
dgram,id=str,local.type=inet,local.host=addr,local.port=port[,remote.type=inet,remote.host=addr,remote.port=port]* :: Configure
a network backend to connect to another QEMU virtual machine or a
proxy using a datagram oriented unix domain socket.</p>
<dl>
<dt>
<strong><strong>local.host=addr,local.port=port</strong></strong>
</dt>
<dd>IP address to use to send the
packets from</dd>
<dt>
<strong><strong>remote.host=addr,remote.port=port</strong></strong>
</dt>
<dd>Destination IP address</dd>
</dl>
</li>
</ul>
<p>Example (two guests connected using an UDP/IP socket):</p>
<blockquote>
<blockquote>
<pre class="example">
# first VM
qemu-system-x86_64 linux.img \
              -device virtio-net,netdev=net0,mac=52:54:00:12:34:56 \
              -netdev dgram,id=net0,local.type=inet,local.host=localhost,local.port=1234,remote.type=inet,remote.host=localhost,remote.port=1235
# second VM
qemu-system-x86_64 linux.img \
              -device virtio-net,netdev=net0,mac=52:54:00:12:34:56 \
              -netdev dgram,id=net0,local.type=inet,local.host=localhost,local.port=1235,remote.type=inet,remote.host=localhost,remote.port=1234
</pre>
</blockquote>
</blockquote>
<ul>
<li>
<p><strong>*-netdev</strong>
dgram,id=str,local.type=unix,local.path=path[,remote.type=unix,remote.path=path]* :: Configure
a network backend to connect to another QEMU virtual machine or a
proxy using a datagram oriented unix socket.</p>
<dl>
<dt>
<strong><strong>local.path=path</strong></strong>
</dt>
<dd>filesystem path to use to bind the socket</dd>
<dt>
<strong><strong>remote.path=path</strong></strong>
</dt>
<dd>filesystem path to use as a destination (see
sendto(2))</dd>
</dl>
</li>
</ul>
<p>Example (two guests connected using an UDP/UNIX socket):</p>
<blockquote>
<blockquote>
<pre class="example">
# first VM
qemu-system-x86_64 linux.img \
              -device virtio-net,netdev=net0,mac=52:54:00:12:34:56 \
              -netdev dgram,id=net0,local.type=unix,local.path=/tmp/qemu0,remote.type=unix,remote.path=/tmp/qemu1
# second VM
qemu-system-x86_64 linux.img \
              -device virtio-net,netdev=net0,mac=52:54:00:12:34:57 \
              -netdev dgram,id=net0,local.type=unix,local.path=/tmp/qemu1,remote.type=unix,remote.path=/tmp/qemu0
</pre>
</blockquote>
</blockquote>
<ul>
<li>
<p><strong>*-netdev</strong>
dgram,id=str,local.type=fd,local.str=file-descriptor* :: Configure a
network backend to connect to another QEMU virtual machine or a proxy
using a datagram oriented socket file descriptor.</p>
<dl>
<dt>
<strong><strong>local.str=file-descriptor</strong></strong>
</dt>
<dd>File descriptor to use to send
packets</dd>
</dl>
</li>
<li>
<p><strong>*-netdev</strong>
l2tpv3,id=id,src=srcaddr,dst=dstaddr[,srcport=srcport][,dstport=dstport],txsession=txsession[,rxsession=rxsession][,ipv6=on|off][,udp=on|off][,cookie64=on|off][,counter=on|off][,pincounter=on|off][,txcookie=txcookie][,rxcookie=rxcookie][,offset=offset]* :: Configure
a L2TPv3 pseudowire host network backend. L2TPv3 (RFC3931) is a
popular protocol to transport Ethernet (and other Layer 2) data frames
between two systems. It is present in routers, firewalls and the Linux
kernel (from version 3.3 onwards).</p>
<p>
This transport allows a VM to communicate to another VM, router or
firewall directly.</p>
<dl>
<dt>
<strong><strong>src=srcaddr</strong></strong>
</dt>
<dd>source address (mandatory)</dd>
<dt>
<strong><strong>dst=dstaddr</strong></strong>
</dt>
<dd>destination address (mandatory)</dd>
<dt>
<strong><strong>udp=on</strong></strong>
</dt>
<dd>select udp encapsulation (default is ip).</dd>
<dt>
<strong><strong>srcport=srcport</strong></strong>
</dt>
<dd>source udp port.</dd>
<dt>
<strong><strong>dstport=dstport</strong></strong>
</dt>
<dd>destination udp port.</dd>
<dt>
<strong><strong>ipv6=on</strong></strong>
</dt>
<dd>force v6, otherwise defaults to v4.</dd>
<dt>
<strong>*rxcookie=rxcookie</strong>; <strong>txcookie=txcookie*</strong>
</dt>
<dd>Cookies are a weak
form of security in the l2tpv3 specification. Their function is
mostly to prevent misconfiguration. By default they are 32 bit.</dd>
<dt>
<strong><strong>cookie64=on</strong></strong>
</dt>
<dd>Set cookie size to 64 bit instead of the default
32</dd>
<dt>
<strong><strong>counter=off</strong></strong>
</dt>
<dd>Force a &#39;cut-down&#39; L2TPv3 with no counter as in
draft-mkonstan-l2tpext-keyed-ipv6-tunnel-00</dd>
<dt>
<strong><strong>pincounter=on</strong></strong>
</dt>
<dd>Work around broken counter handling in peer.
This may also help on networks which have packet reorder.</dd>
<dt>
<strong><strong>offset=offset</strong></strong>
</dt>
<dd>Add an extra offset between header and data</dd>
</dl>
</li>
</ul>
<p>For example, to attach a VM running on host 4.3.2.1 via L2TPv3 to the
bridge br-lan on the remote Linux host 1.2.3.4:</p>
<blockquote>
<blockquote>
<pre class="example">
# Setup tunnel on linux host using raw ip as encapsulation
# on 1.2.3.4
ip l2tp add tunnel remote 4.3.2.1 local 1.2.3.4 tunnel_id 1 peer_tunnel_id 1 \
    encap udp udp_sport 16384 udp_dport 16384
ip l2tp add session tunnel_id 1 name vmtunnel0 session_id \
    0xFFFFFFFF peer_session_id 0xFFFFFFFF
ifconfig vmtunnel0 mtu 1500
ifconfig vmtunnel0 up
brctl addif br-lan vmtunnel0


# on 4.3.2.1
# launch QEMU instance - if your network has reorder or is very lossy add ,pincounter

qemu-system-x86_64 linux.img -device e1000,netdev=n1 \
    -netdev l2tpv3,id=n1,src=4.2.3.1,dst=1.2.3.4,udp=on,srcport=16384,dstport=16384,rxsession=0xffffffff,txsession=0xffffffff,counter=on
</pre>
</blockquote>
</blockquote>
<ul>
<li>
<p><strong>*-netdev</strong>
vde,id=id[,sock=socketpath][,port=n][,group=groupname][,mode=octalmode]* :: Configure
VDE backend to connect to PORT n of a vde switch running on host and
listening for incoming connections on socketpath. Use GROUP groupname
and MODE octalmode to change default ownership and permissions for
communication port. This option is only available if QEMU has been
compiled with vde support enabled.</p>
<p>
Example:</p>
<blockquote>
<pre class="example">
# launch vde switch
vde_switch -F -sock /tmp/myswitch
# launch QEMU instance
qemu-system-x86_64 linux.img -nic vde,sock=/tmp/myswitch
</pre>
</blockquote>
</li>
<li>
<p><strong>*-netdev</strong>
af-xdp,id=str,ifname=name[,mode=native|skb][,force-copy=on|off][,queues=n][,start-queue=m][,inhibit=on|off][,sock-fds=x:y:…:z]* :: Configure
AF_XDP backend to connect to a network interface &#39;name&#39; using AF_XDP
socket. A specific program attach mode for a default XDP program can
be forced with &#39;mode&#39;, defaults to best-effort, where the likely most
performant mode will be in use. Number of queues &#39;n&#39; should generally
match the number or queues in the interface, defaults to 1. Traffic
arriving on non-configured device queues will not be delivered to the
network backend.</p>
<blockquote>
<pre class="example">
# set number of queues to 4
ethtool -L eth0 combined 4
# launch QEMU instance
qemu-system-x86_64 linux.img -device virtio-net-pci,netdev=n1 \
    -netdev af-xdp,id=n1,ifname=eth0,queues=4
</pre>
</blockquote>
</li>
</ul>
<p>&#39;start-queue&#39; option can be specified if a particular range of queues
[m, m + n] should be in use. For example, this is may be necessary in
order to use certain NICs in native mode. Kernel allows the driver to
create a separate set of XDP queues on top of regular ones, and only
these queues can be used for AF_XDP sockets. NICs that work this way may
also require an additional traffic redirection with ethtool to these
special queues.</p>
<blockquote>
<blockquote>
<pre class="example">
# set number of queues to 1
ethtool -L eth0 combined 1
# redirect all the traffic to the second queue (id: 1)
# note: drivers may require non-empty key/mask pair.
ethtool -N eth0 flow-type ether \
    dst 00:00:00:00:00:00 m FF:FF:FF:FF:FF:FE action 1
ethtool -N eth0 flow-type ether \
    dst 00:00:00:00:00:01 m FF:FF:FF:FF:FF:FE action 1
# launch QEMU instance
qemu-system-x86_64 linux.img -device virtio-net-pci,netdev=n1 \
    -netdev af-xdp,id=n1,ifname=eth0,queues=1,start-queue=1
</pre>
</blockquote>
</blockquote>
<p>
XDP program can also be loaded externally. In this case &#39;inhibit&#39; option
should be set to &#39;on&#39; and &#39;sock-fds&#39; provided with file descriptors for
already open but not bound XDP sockets already added to a socket map for
corresponding queues. One socket per queue.</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 linux.img -device virtio-net-pci,netdev=n1 \
    -netdev af-xdp,id=n1,ifname=eth0,queues=3,inhibit=on,sock-fds=15:16:17
</pre>
</blockquote>
</blockquote>
<ul>
<li>
<p><strong>*-netdev</strong>
vhost-user,chardev=id[,vhostforce=on|off][,queues=n]* :: Establish a
vhost-user netdev, backed by a chardev id. The chardev should be a
unix domain socket backed one. The vhost-user uses a specifically
defined protocol to pass vhost ioctl replacement messages to an
application on the other end of the socket. On non-MSIX guests, the
feature can be forced with vhostforce. Use &#39;queues=n&#39; to specify the
number of queues to be created for multiqueue vhost-user.</p>
<p>
Example:</p>
<blockquote>
<pre class="example">
qemu -m 512 -object memory-backend-file,id=mem,size=512M,mem-path=/hugetlbfs,share=on \
     -numa node,memdev=mem \
     -chardev socket,id=chr0,path=/path/to/socket \
     -netdev type=vhost-user,id=net0,chardev=chr0 \
     -device virtio-net-pci,netdev=net0
</pre>
</blockquote>
</li>
<li><strong>*-netdev</strong>
vhost-vdpa[,vhostdev=/path/to/dev][,vhostfd=h]* :: Establish a
vhost-vdpa netdev.

vDPA device is a device that uses a datapath which complies with the
virtio specifications with a vendor specific control path. vDPA
devices can be both physically located on the hardware or emulated by
software.</li>
<li><strong>*-netdev</strong> hubport,id=id,hubid=hubid[,netdev=nd]* :: Create a hub port
on the emulated hub with ID hubid.

The hubport netdev lets you connect a NIC to a QEMU emulated hub
instead of a single netdev. Alternatively, you can also connect the
hubport to another netdev with ID nd by using the <strong>netdev=nd</strong> option.</li>
<li><strong>*-net</strong> nic[,netdev=nd][,macaddr=mac][,model=type]
[,name=name][,addr=addr][,vectors=v]* :: Legacy option to configure or
create an on-board (or machine default) Network Interface Card(NIC)
and connect it either to the emulated hub with ID 0 (i.e. the default
hub), or to the netdev nd. If model is omitted, then the default NIC
model associated with the machine type is used. Note that the default
NIC model may change in future QEMU releases, so it is highly
recommended to always specify a model. Optionally, the MAC address can
be changed to mac, the device address set to addr (PCI cards only),
and a name can be assigned for use in monitor commands. Optionally,
for PCI cards, you can specify the number v of MSI-X vectors that the
card should have; this option currently only affects virtio cards; set
v = 0 to disable MSI-X. If no <strong>-net</strong> option is specified, a single NIC
is created. QEMU can emulate several different models of network card.
Use <strong>-net nic,model=help</strong> for a list of available devices for your
target.</li>
<li><strong>*-net</strong>
user|tap|bridge|socket|l2tpv3|vde[,…][,name=name]* :: Configure a
host network backend (with the options corresponding to the same
<strong>-netdev</strong> option) and connect it to the emulated hub 0 (the default
hub). Use name to specify the name of the hub port.</li>
</ul>
</blockquote>
</div>
</div>
<div id="outline-container-headline-12" class="outline-3">
<h3 id="headline-12">
Character device options
</h3>
<div id="outline-text-headline-12" class="outline-text-3">
<p>The general form of a character device option is:</p>
<blockquote>
<dl>
<dt>
<strong>*-chardev</strong> backend,id=id[,mux=on|off][,options]*
</dt>
<dd>
<p>Backend is one
of: <strong>null</strong>, <strong>socket</strong>, <strong>udp</strong>, <strong>msmouse</strong>, <strong>vc</strong>, <strong>ringbuf</strong>, <strong>file</strong>,
<strong>pipe</strong>, <strong>console</strong>, <strong>serial</strong>, <strong>pty</strong>, <strong>stdio</strong>, <strong>braille</strong>, <strong>parallel</strong>,
<strong>spicevmc</strong>, <strong>spiceport</strong>. The specific backend will determine the
applicable options.</p>
<p>
Use <strong>-chardev help</strong> to print all available chardev backend types.</p>
<p>
All devices must have an id, which can be any string up to 127
characters long. It is used to uniquely identify this device in other
command line directives.</p>
<p>
A character device may be used in multiplexing mode by multiple
front-ends. Specify <strong>mux=on</strong> to enable this mode. A multiplexer is a
&#34;1:N&#34; device, and here the &#34;1&#34; end is your specified chardev backend,
and the &#34;N&#34; end is the various parts of QEMU that can talk to a
chardev. If you create a chardev with <strong>id=myid</strong> and <strong>mux=on</strong>, QEMU
will create a multiplexer with your specified ID, and you can then
configure multiple front ends to use that chardev ID for their
input/output. Up to four different front ends can be connected to a
single multiplexed chardev. (Without multiplexing enabled, a chardev
can only be used by a single front end.) For instance you could use
this to allow a single stdio chardev to be used by two serial ports
and the QEMU monitor:</p>
<blockquote>
<pre class="example">
-chardev stdio,mux=on,id=char0 \
-mon chardev=char0,mode=readline \
-serial chardev:char0 \
-serial chardev:char0
</pre>
</blockquote>
</dd>
</dl>
<p>You can have more than one multiplexer in a system configuration; for
instance you could have a TCP port multiplexed between UART 0 and UART
1, and stdio multiplexed between the QEMU monitor and a parallel port:</p>
<blockquote>
<blockquote>
<pre class="example">
-chardev stdio,mux=on,id=char0 \
-mon chardev=char0,mode=readline \
-parallel chardev:char0 \
-chardev tcp,...,mux=on,id=char1 \
-serial chardev:char1 \
-serial chardev:char1
</pre>
</blockquote>
</blockquote>
<p>
When you&#39;re using a multiplexed character device, some escape sequences
are interpreted in the input. See the chapter about <em>Keys in the
character backend multiplexer</em> in the System Emulation Users Guide for
more details.</p>
<p>
Note that some other command line options may implicitly create
multiplexed character backends; for instance <strong>-serial mon:stdio</strong> creates
a multiplexed stdio backend connected to the serial port and the QEMU
monitor, and <strong>-nographic</strong> also multiplexes the console and the monitor
to stdio.</p>
<p>
There is currently no support for multiplexing in the other direction
(where a single QEMU front end takes input and output from multiple
chardevs).</p>
<p>
Every backend supports the <strong>logfile</strong> option, which supplies the path to
a file to record all data transmitted via the backend. The <strong>logappend</strong>
option controls whether the log file will be truncated or appended to
when opened.</p>
</blockquote>
<p>
The available backends are:</p>
<blockquote>
<dl>
<dt>
<strong>*-chardev</strong> null,id=id*
</dt>
<dd>A void device. This device will not emit
any data, and will drop any data it receives. The null backend does
not take any options.</dd>
<dt>
?
</dt>
<dd>
<p><strong>*-chardev</strong> socket,id=id[,TCP options or unix
options][,server=on|off][,wait=on|off][,telnet=on|off][,websocket=on|off][,reconnect=seconds][,tls-creds=id][,tls-authz=id]* :: Create
a two-way stream socket, which can be either a TCP or a unix socket. A
unix socket will be created if <strong>path</strong> is specified. Behaviour is
undefined if TCP options are specified for a unix socket.</p>
<p>
<strong>server=on|off</strong> specifies that the socket shall be a listening socket.</p>
<p>
<strong>wait=on|off</strong> specifies that QEMU should not block waiting for a
client to connect to a listening socket.</p>
<p>
<strong>telnet=on|off</strong> specifies that traffic on the socket should interpret
telnet escape sequences.</p>
<p>
<strong>websocket=on|off</strong> specifies that the socket uses WebSocket protocol
for communication.</p>
<p>
<strong>reconnect</strong> sets the timeout for reconnecting on non-server sockets
when the remote end goes away. qemu will delay this many seconds and
then attempt to reconnect. Zero disables reconnecting, and is the
default.</p>
<p>
<strong>tls-creds</strong> requests enablement of the TLS protocol for encryption,
and specifies the id of the TLS credentials to use for the handshake.
The credentials must be previously created with the <strong>-object
tls-creds</strong> argument.</p>
<p>
<strong>tls-auth</strong> provides the ID of the QAuthZ authorization object against
which the client&#39;s x509 distinguished name will be validated. This
object is only resolved at time of use, so can be deleted and
recreated on the fly while the chardev server is active. If missing,
it will default to denying access.</p>
<p>
TCP and unix socket options are given below:</p>
<ul>
<li><strong>*TCP</strong> options:
port=port[,host=host][,to=to][,ipv4=on|off][,ipv6=on|off][,nodelay=on|off]* :: <strong>host</strong>
for a listening socket specifies the local address to be bound. For
a connecting socket species the remote host to connect to. <strong>host</strong> is
optional for listening sockets. If not specified it defaults to
<strong>0.0.0.0</strong>.

<strong>port</strong> for a listening socket specifies the local port to be bound.
For a connecting socket specifies the port on the remote host to
connect to. <strong>port</strong> can be given as either a port number or a service
name. <strong>port</strong> is required.

<strong>to</strong> is only relevant to listening sockets. If it is specified, and
<strong>port</strong> cannot be bound, QEMU will attempt to bind to subsequent
ports up to and including <strong>to</strong> until it succeeds. <strong>to</strong> must be
specified as a port number.

<strong>ipv4=on|off</strong> and <strong>ipv6=on|off</strong> specify that either IPv4 or IPv6
must be used. If neither is specified the socket may use either
protocol.

<strong>nodelay=on|off</strong> disables the Nagle algorithm.</li>
<li><strong>*unix</strong> options:
path=path[,abstract=on|off][,tight=on|off]* :: <strong>path</strong> specifies the
local path of the unix socket. <strong>path</strong> is required. <strong>abstract=on|off</strong>
specifies the use of the abstract socket namespace, rather than the
filesystem. Optional, defaults to false. <strong>tight=on|off</strong> sets the
socket length of abstract sockets to their minimum, rather than the
full sun_path length. Optional, defaults to true.</li>
</ul>
</dd>
<dt>
?
</dt>
<dd><strong>*-chardev</strong>
udp,id=id[,host=host],port=port[,localaddr=localaddr][,localport=localport][,ipv4=on|off][,ipv6=on|off]* :: Sends
all traffic from the guest to a remote host over UDP.

<strong>host</strong> specifies the remote host to connect to. If not specified it
defaults to <strong>localhost</strong>.

<strong>port</strong> specifies the port on the remote host to connect to. <strong>port</strong> is
required.

<strong>localaddr</strong> specifies the local address to bind to. If not specified
it defaults to <strong>0.0.0.0</strong>.

<strong>localport</strong> specifies the local port to bind to. If not specified any
available local port will be used.

<strong>ipv4=on|off</strong> and <strong>ipv6=on|off</strong> specify that either IPv4 or IPv6 must
be used. If neither is specified the device may use either protocol.</dd>
<dt>
<strong>*-chardev</strong> msmouse,id=id*
</dt>
<dd>Forward QEMU&#39;s emulated msmouse events
to the guest. <strong>msmouse</strong> does not take any options.</dd>
<dt>
?
</dt>
<dd><strong>*-chardev</strong>
vc,id=id<a href=",width=width">,height=height</a><a href=",cols=cols">,rows=rows</a>* :: Connect
to a QEMU text console. <strong>vc</strong> may optionally be given a specific size.

<strong>width</strong> and <strong>height</strong> specify the width and height respectively of the
console, in pixels.

<strong>cols</strong> and <strong>rows</strong> specify that the console be sized to fit a text
console with the given dimensions.</dd>
<dt>
<strong>*-chardev</strong> ringbuf,id=id[,size=size]*
</dt>
<dd>Create a ring buffer with
fixed size <strong>size</strong>. size must be a power of two and defaults to <strong>64K</strong>.</dd>
<dt>
<strong>*-chardev</strong> file,id=id,path=path[,input-path=input-path]*
</dt>
<dd>Log all
traffic received from the guest to a file.

<strong>path</strong> specifies the path of the file to be opened. This file will be
created if it does not already exist, and overwritten if it does.
<strong>path</strong> is required.

If <strong>input-path</strong> is specified, this is the path of a second file which
will be used for input. If <strong>input-path</strong> is not specified, no input
will be available from the chardev.

Note that <strong>input-path</strong> is not supported on Windows hosts.</dd>
<dt>
<strong>*-chardev</strong> pipe,id=id,path=path*
</dt>
<dd>Create a two-way connection to
the guest. The behaviour differs slightly between Windows hosts and
other hosts:

On Windows, a single duplex pipe will be created at <strong>\\.pipe\path</strong>.

On other hosts, 2 pipes will be created called <strong>path.in</strong> and
<strong>path.out</strong>. Data written to <strong>path.in</strong> will be received by the guest.
Data written by the guest can be read from <strong>path.out</strong>. QEMU will not
create these fifos, and requires them to be present.

<strong>path</strong> forms part of the pipe path as described above. <strong>path</strong> is
required.</dd>
<dt>
<strong>*-chardev</strong> console,id=id*
</dt>
<dd>Send traffic from the guest to QEMU&#39;s
standard output. <strong>console</strong> does not take any options.

<strong>console</strong> is only available on Windows hosts.</dd>
<dt>
<strong>*-chardev</strong> serial,id=id,path=path*
</dt>
<dd>Send traffic from the guest to
a serial device on the host.

On Unix hosts serial will actually accept any tty device, not only
serial lines.

<strong>path</strong> specifies the name of the serial device to open.</dd>
<dt>
<strong>*-chardev</strong> pty,id=id*
</dt>
<dd>Create a new pseudo-terminal on the host and
connect to it. <strong>pty</strong> does not take any options.

<strong>pty</strong> is not available on Windows hosts.</dd>
<dt>
<strong>*-chardev</strong> stdio,id=id[,signal=on|off]*
</dt>
<dd>Connect to standard input
and standard output of the QEMU process.

<strong>signal</strong> controls if signals are enabled on the terminal, that
includes exiting QEMU with the key sequence Control-c. This option is
enabled by default, use <strong>signal=off</strong> to disable it.</dd>
<dt>
<strong>*-chardev</strong> braille,id=id*
</dt>
<dd>Connect to a local BrlAPI server.
<strong>braille</strong> does not take any options.</dd>
<dt>
<strong>*-chardev</strong> parallel,id=id,path=path*
</dt>
<dd>
<blockquote>
<ul>
<li><strong>*parallel</strong> is only available on Linux, FreeBSD and
DragonFlyBSD* :: hosts.

Connect to a local parallel port.

<strong>path</strong> specifies the path to the parallel port device. <strong>path</strong> is
required.</li>
</ul>
</blockquote>
</dd>
<dt>
<strong>*-chardev</strong> spicevmc,id=id,debug=debug,name=name*
</dt>
<dd><strong>spicevmc</strong> is
only available when spice support is built in.

<strong>debug</strong> debug level for spicevmc

<strong>name</strong> name of spice channel to connect to

Connect to a spice virtual machine channel, such as vdiport.</dd>
<dt>
<strong>*-chardev</strong> spiceport,id=id,debug=debug,name=name*
</dt>
<dd><strong>spiceport</strong> is
only available when spice support is built in.

<strong>debug</strong> debug level for spicevmc

<strong>name</strong> name of spice port to connect to

Connect to a spice port, allowing a Spice client to handle the traffic
identified by a name (preferably a fqdn).</dd>
</dl>
</blockquote>
</div>
</div>
<div id="outline-container-headline-13" class="outline-3">
<h3 id="headline-13">
TPM device options
</h3>
<div id="outline-text-headline-13" class="outline-text-3">
<p>The general form of a TPM device option is:</p>
<blockquote>
<dl>
<dt>
<strong>*-tpmdev</strong> backend,id=id[,options]*
</dt>
<dd>The specific backend type will
determine the applicable options. The <strong>-tpmdev</strong> option creates the TPM
backend and requires a <strong>-device</strong> option that specifies the TPM
frontend interface model.

Use <strong>-tpmdev help</strong> to print all available TPM backend types.</dd>
</dl>
</blockquote>
<p>
The available backends are:</p>
<blockquote>
<ul>
<li>
<p><strong>*-tpmdev</strong>
passthrough,id=id,path=path,cancel-path=cancel-path* :: (Linux-host
only) Enable access to the host&#39;s TPM using the passthrough driver.</p>
<p>
<strong>path</strong> specifies the path to the host&#39;s TPM device, i.e., on a Linux
host this would be <strong>/dev/tpm0</strong>. <strong>path</strong> is optional and by default
<strong>/dev/tpm0</strong> is used.</p>
<p>
<strong>cancel-path</strong> specifies the path to the host TPM device&#39;s sysfs entry
allowing for cancellation of an ongoing TPM command. <strong>cancel-path</strong> is
optional and by default QEMU will search for the sysfs entry to use.</p>
<p>
Some notes about using the host&#39;s TPM with the passthrough driver:</p>
<p>
The TPM device accessed by the passthrough driver must not be used by
any other application on the host.</p>
<p>
Since the host&#39;s firmware (BIOS/UEFI) has already initialized the TPM,
the VM&#39;s firmware (BIOS/UEFI) will not be able to initialize the TPM
again and may therefore not show a TPM-specific menu that would
otherwise allow the user to configure the TPM, e.g., allow the user to
enable/disable or activate/deactivate the TPM. Further, if TPM
ownership is released from within a VM then the host&#39;s TPM will get
disabled and deactivated. To enable and activate the TPM again
afterwards, the host has to be rebooted and the user is required to
enter the firmware&#39;s menu to enable and activate the TPM. If the TPM
is left disabled and/or deactivated most TPM commands will fail.</p>
<p>
To create a passthrough TPM use the following two options:</p>
<blockquote>
<pre class="example">
-tpmdev passthrough,id=tpm0 -device tpm-tis,tpmdev=tpm0
</pre>
</blockquote>
</li>
</ul>
<p>Note that the <strong>-tpmdev</strong> id is <strong>tpm0</strong> and is referenced by <strong>tpmdev=tpm0</strong>
in the device option.</p>
<dl>
<dt>
<strong>*-tpmdev</strong> emulator,id=id,chardev=dev*
</dt>
<dd>
<p>(Linux-host only) Enable
access to a TPM emulator using Unix domain socket based chardev
backend.</p>
<p>
<strong>chardev</strong> specifies the unique ID of a character device backend that
provides connection to the software TPM server.</p>
<p>
To create a TPM emulator backend device with chardev socket backend:</p>
<blockquote>
<pre class="example">
-chardev socket,id=chrtpm,path=/tmp/swtpm-sock -tpmdev emulator,id=tpm0,chardev=chrtpm -device tpm-tis,tpmdev=tpm0
</pre>
</blockquote>
</dd>
</dl>
</blockquote>
</div>
</div>
<div id="outline-container-headline-14" class="outline-3">
<h3 id="headline-14">
Boot Image or Kernel specific
</h3>
<div id="outline-text-headline-14" class="outline-text-3">
<p>There are broadly 4 ways you can boot a system with QEMU.</p>
<blockquote>
<blockquote>
<blockquote>
<ul>
<li>specify a firmware and let it control finding a kernel</li>
<li>specify a firmware and pass a hint to the kernel to boot</li>
<li>direct kernel image boot</li>
<li>manually load files into the guest&#39;s address space</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<p>
The third method is useful for quickly testing kernels but as there is
no firmware to pass configuration information to the kernel the hardware
must either be probeable, the kernel built for the exact configuration
or passed some configuration data (e.g. a DTB blob) which tells the
kernel what drivers it needs. This exact details are often hardware
specific.</p>
<p>
The final method is the most generic way of loading images into the
guest address space and used mostly for <strong>bare metal</strong> type development
where the reset vectors of the processor are taken into account.</p>
<p>
For x86 machines and some other architectures <strong>-bios</strong> will generally do
the right thing with whatever it is given. For other machines the more
strict <strong>-pflash</strong> option needs an image that is sized for the flash
device for the given machine type.</p>
<p>
Please see the <em>QEMU System Emulator Targets</em> section of the manual for
more detailed documentation.</p>
<blockquote>
<dl>
<dt>
<strong>*-bios</strong> file*
</dt>
<dd>Set the filename for the BIOS.</dd>
<dt>
<strong>*-pflash</strong> file*
</dt>
<dd>Use file as a parallel flash image.</dd>
</dl>
</blockquote>
<p>
The kernel options were designed to work with Linux kernels although
other things (like hypervisors) can be packaged up as a kernel
executable image. The exact format of a executable image is usually
architecture specific.</p>
<p>
The way in which the kernel is started (what address it is loaded at,
what if any information is passed to it via CPU registers, the state of
the hardware when it is started, and so on) is also architecture
specific. Typically it follows the specification laid down by the Linux
kernel for how kernels for that architecture must be started.</p>
<blockquote>
<dl>
<dt>
<strong>*-kernel</strong> bzImage*
</dt>
<dd>Use bzImage as kernel image. The kernel can be
either a Linux kernel or in multiboot format.</dd>
<dt>
<strong>*-append</strong> cmdline*
</dt>
<dd>Use cmdline as kernel command line</dd>
</dl>
</blockquote>
<blockquote>
<dl>
<dt>
<strong>*-initrd</strong> file*
</dt>
<dd>Use file as initial ram disk.</dd>
<dt>
<strong>*-initrd</strong> &#34;file1 arg=foo,file2&#34;*
</dt>
<dd>This syntax is only available
with multiboot.

Use file1 and file2 as modules and pass <strong>arg=foo</strong> as parameter to the
first module. Commas can be provided in module parameters by doubling
them on the command line to escape them:</dd>
<dt>
?
</dt>
<dd><strong>*-initrd</strong> &#34;bzImage earlyprintk=xen,,keep
root=/dev/xvda1,initrd.img&#34;* :: Multiboot only. Use bzImage as the
first module with &#34;<strong>earlyprintk=xen,keep root=/dev/xvda1</strong>&#34; as its
command line, and initrd.img as the second module.</dd>
<dt>
<strong>*-dtb</strong> file*
</dt>
<dd>Use file as a device tree binary (dtb) image and pass
it to the kernel on boot.</dd>
</dl>
</blockquote>
<p>
Finally you can also manually load images directly into the address
space of the guest. This is most useful for developers who already know
the layout of their guest and take care to ensure something sane will
happen when the reset vector executes.</p>
<p>
The generic loader can be invoked by using the loader device:</p>
<p>
<strong>-device
loader,addr=&lt;addr&gt;,data=&lt;data&gt;,data-len=&lt;data-len&gt;[,data-be=&lt;data-be&gt;][,cpu-num=&lt;cpu-num&gt;]</strong></p>
<p>
there is also the guest loader which operates in a similar way but
tweaks the DTB so a hypervisor loaded via <strong>-kernel</strong> can find where the
guest image is:</p>
<p>
<strong>-device
guest-loader,addr=&lt;addr&gt;[,kernel=&lt;path&gt;,[bootargs=&lt;arguments&gt;]][,initrd=&lt;path&gt;]</strong></p>
</div>
</div>
<div id="outline-container-headline-15" class="outline-3">
<h3 id="headline-15">
Debug/Expert options
</h3>
<div id="outline-text-headline-15" class="outline-text-3">
<blockquote>
<ul>
<li>
<p><strong>*-compat</strong>
[deprecated-input=@var{input-policy}][,deprecated-output=@var{output-policy}]* :: Set
policy for handling deprecated management interfaces (experimental):</p>
<dl>
<dt>
<strong>*deprecated-input=accept</strong> (default)*
</dt>
<dd>Accept deprecated commands
and arguments</dd>
<dt>
<strong><strong>deprecated-input=reject</strong></strong>
</dt>
<dd>Reject deprecated commands and
arguments</dd>
<dt>
<strong><strong>deprecated-input=crash</strong></strong>
</dt>
<dd>Crash on deprecated commands and
arguments</dd>
<dt>
<strong>*deprecated-output=accept</strong> (default)*
</dt>
<dd>Emit deprecated command
results and events</dd>
<dt>
<strong><strong>deprecated-output=hide</strong></strong>
</dt>
<dd>Suppress deprecated command results
and events</dd>
</dl>
</li>
</ul>
<p>Limitation: covers only syntactic aspects of QMP.</p>
<ul>
<li>
<p><strong>*-compat</strong>
[unstable-input=@var{input-policy}][,unstable-output=@var{output-policy}]* :: Set
policy for handling unstable management interfaces (experimental):</p>
<dl>
<dt>
<strong>*unstable-input=accept</strong> (default)*
</dt>
<dd>Accept unstable commands and
arguments</dd>
<dt>
<strong><strong>unstable-input=reject</strong></strong>
</dt>
<dd>Reject unstable commands and arguments</dd>
<dt>
<strong><strong>unstable-input=crash</strong></strong>
</dt>
<dd>Crash on unstable commands and arguments</dd>
<dt>
<strong>*unstable-output=accept</strong> (default)*
</dt>
<dd>Emit unstable command
results and events</dd>
<dt>
<strong><strong>unstable-output=hide</strong></strong>
</dt>
<dd>Suppress unstable command results and
events</dd>
</dl>
</li>
</ul>
<p>Limitation: covers only syntactic aspects of QMP.</p>
<dl>
<dt>
<strong>*-fw_cfg</strong> [name=]name,file=file*
</dt>
<dd>Add named fw_cfg entry with
contents from file file. If the filename contains comma, you must
double it (for instance, &#34;file=my,,file&#34; to use file &#34;my,file&#34;).</dd>
<dt>
<strong>*-fw_cfg</strong> [name=]name,string=str*
</dt>
<dd>
<p>Add named fw_cfg entry with
contents from string str. If the string contains comma, you must
double it (for instance, &#34;string=my,,string&#34; to use file &#34;my,string&#34;).</p>
<p>
The terminating NUL character of the contents of str will not be
included as part of the fw_cfg item data. To insert contents with
embedded NUL characters, you have to use the file parameter.</p>
<p>
The fw_cfg entries are passed by QEMU through to the guest.</p>
<p>
Example:</p>
<blockquote>
<pre class="example">
-fw_cfg name=opt/com.mycompany/blob,file=./my_blob.bin
</pre>
</blockquote>
</dd>
</dl>
<p>creates an fw_cfg entry named opt/com.mycompany/blob with contents from
./my_blob.bin.</p>
<dl>
<dt>
<strong>*-serial</strong> dev*
</dt>
<dd>
<p>Redirect the virtual serial port to host character
device dev. The default device is <strong>vc</strong> in graphical mode and <strong>stdio</strong>
in non graphical mode.</p>
<p>
This option can be used several times to simulate multiple serial
ports.</p>
<p>
You can use <strong>-serial none</strong> to suppress the creation of default serial
devices.</p>
<p>
Available character devices are:</p>
<dl>
<dt>
<strong><strong>vc[:WxH]</strong></strong>
</dt>
<dd>
<p>Virtual console. Optionally, a width and height can
be given in pixel with</p>
<blockquote>
<pre class="example">
vc:800x600
</pre>
</blockquote>
</dd>
</dl>
<p>It is also possible to specify width or height in characters:</p>
<blockquote>
<blockquote>
<pre class="example">
vc:80Cx24C
</pre>
</blockquote>
</blockquote>
<dl>
<dt>
<strong><strong>pty</strong></strong>
</dt>
<dd>[Linux only] Pseudo TTY (a new PTY is automatically
allocated)</dd>
<dt>
<strong><strong>none</strong></strong>
</dt>
<dd>No device is allocated. Note that for machine types
which emulate systems where a serial device is always present in
real hardware, this may be equivalent to the <strong>null</strong> option, in that
the serial device is still present but all output is discarded. For
boards where the number of serial ports is truly variable, this
suppresses the creation of the device.</dd>
<dt>
<strong><strong>null</strong></strong>
</dt>
<dd>A guest will see the UART or serial device as present in
the machine, but all output is discarded, and there is no input.
Conceptually equivalent to redirecting the output to <strong>/dev/null</strong>.</dd>
<dt>
<strong><strong>chardev:id</strong></strong>
</dt>
<dd>Use a named character device defined with the
<strong>-chardev</strong> option.</dd>
<dt>
<strong><strong>/dev/XXX</strong></strong>
</dt>
<dd>[Linux only] Use host tty, e.g. <strong>/dev/ttyS0</strong>. The
host serial port parameters are set according to the emulated ones.</dd>
<dt>
<strong><strong>/dev/parportN</strong></strong>
</dt>
<dd>[Linux only, parallel port only] Use host
parallel port N. Currently SPP and EPP parallel port features can be
used.</dd>
<dt>
<strong><strong>file:filename</strong></strong>
</dt>
<dd>Write output to filename. No character can be
read.</dd>
<dt>
<strong><strong>stdio</strong></strong>
</dt>
<dd>[Unix only] standard input/output</dd>
<dt>
<strong><strong>pipe:filename</strong></strong>
</dt>
<dd>name pipe filename</dd>
<dt>
<strong><strong>COMn</strong></strong>
</dt>
<dd>[Windows only] Use host serial port n</dd>
<dt>
<strong><strong>udp:[remote_host]:remote_port[@[src_ip]:src_port]</strong></strong>
</dt>
<dd>
<p>This
implements UDP Net Console. When remote_host or src_ip are not
specified they default to <strong>0.0.0.0</strong>. When not using a specified
src_port a random port is automatically chosen.</p>
<p>
If you just want a simple readonly console you can use <strong>netcat</strong> or
<strong>nc</strong>, by starting QEMU with: <strong>-serial udp::4555</strong> and nc as: <strong>nc -u
-l -p 4555</strong>. Any time QEMU writes something to that port it will
appear in the netconsole session.</p>
<p>
If you plan to send characters back via netconsole or you want to
stop and start QEMU a lot of times, you should have QEMU use the
same source port each time by using something like <strong>-serial</strong>
udp::4555@:4556 to QEMU. Another approach is to use a patched
version of netcat which can listen to a TCP port and send and
receive characters via udp. If you have a patched version of netcat
which activates telnet remote echo and single char transfer, then
you can use the following options to set up a netcat redirector to
allow telnet on port 5555 to access the QEMU port.</p>
<dl>
<dt>
<strong>*QEMU</strong> Options:*
</dt>
<dd>-serial udp::4555@:4556</dd>
<dt>
<strong>*netcat</strong> options:*
</dt>
<dd>-u -P 4555 -L 0.0.0.0:4556 -t -p 5555 -I -T</dd>
<dt>
<strong>*telnet</strong> options:*
</dt>
<dd>localhost 5555</dd>
</dl>
</dd>
<dt>
<strong><strong>tcp:[host]:port[,server=on|off][,wait=on|off][,nodelay=on|off][,reconnect=seconds]</strong></strong>
</dt>
<dd>
<p>The
TCP Net Console has two modes of operation. It can send the serial
I/O to a location or wait for a connection from a location. By
default the TCP Net Console is sent to host at the port. If you use
the <strong>server=on</strong> option QEMU will wait for a client socket
application to connect to the port before continuing, unless the
<strong>wait=on|off</strong> option was specified. The <strong>nodelay=on|off</strong> option
disables the Nagle buffering algorithm. The <strong>reconnect=on</strong> option
only applies if <strong>server=no</strong> is set, if the connection goes down it
will attempt to reconnect at the given interval. If host is omitted,
0.0.0.0 is assumed. Only one TCP connection at a time is accepted.
You can use <strong>telnet=on</strong> to connect to the corresponding character
device.</p>
<ul>
<li><strong>*Example</strong> to send tcp console to 192.168.0.2 port
4444* :: -serial <em>tcp:192.168.0.2:4444</em></li>
<li><strong>*Example</strong> to listen and wait on port 4444 for
connection* :: -serial <em>tcp::4444,server=on</em></li>
<li><strong>*Example</strong> to not wait and listen on ip 192.168.0.100 port
4444* :: -serial <em>tcp:192.168.0.100:4444,server=on,wait=off</em></li>
</ul>
</dd>
<dt>
<strong><strong>telnet:host:port[,server=on|off][,wait=on|off][,nodelay=on|off]</strong></strong>
</dt>
<dd>The
telnet protocol is used instead of raw tcp sockets. The options work
the same as if you had specified <strong>-serial tcp</strong>. The difference is
that the port acts like a telnet server or client using telnet
option negotiation. This will also allow you to send the MAGIC_SYSRQ
sequence if you use a telnet that supports sending the break
sequence. Typically in unix telnet you do it with Control-] and then
type &#34;send break&#34; followed by pressing the enter key.</dd>
<dt>
<strong><strong>websocket:host:port,server=on[,wait=on|off][,nodelay=on|off]</strong></strong>
</dt>
<dd>The
WebSocket protocol is used instead of raw tcp socket. The port acts
as a WebSocket server. Client mode is not supported.</dd>
<dt>
<strong><strong>unix:path[,server=on|off][,wait=on|off][,reconnect=seconds]</strong></strong>
</dt>
<dd>A
unix domain socket is used instead of a tcp socket. The option works
the same as if you had specified <strong>-serial tcp</strong> except the unix
domain socket path is used for connections.</dd>
<dt>
<strong><strong>mon:dev_string</strong></strong>
</dt>
<dd>This is a special option to allow the monitor
to be multiplexed onto another serial port. The monitor is accessed
with key sequence of Control-a and then pressing c. dev_string
should be any one of the serial devices specified above. An example
to multiplex the monitor onto a telnet server listening on port 4444
would be:

<strong>-serial mon:telnet::4444,server=on,wait=off</strong>

When the monitor is multiplexed to stdio in this way, Ctrl+C will
not terminate QEMU any more but will be passed to the guest instead.</dd>
<dt>
<strong><strong>braille</strong></strong>
</dt>
<dd>Braille device. This will use BrlAPI to display the
braille output on a real or fake device.</dd>
<dt>
<strong><strong>msmouse</strong></strong>
</dt>
<dd>Three button serial mouse. Configure the guest to use
Microsoft protocol.</dd>
</dl>
</dd>
<dt>
<strong>*-parallel</strong> dev*
</dt>
<dd>Redirect the virtual parallel port to host device
dev (same devices as the serial port). On Linux hosts, <strong>/dev/parportN</strong>
can be used to use hardware devices connected on the corresponding
host parallel port.

This option can be used several times to simulate up to 3 parallel
ports.

Use <strong>-parallel none</strong> to disable all parallel ports.</dd>
<dt>
<strong>*-monitor</strong> dev*
</dt>
<dd>Redirect the monitor to host device dev (same
devices as the serial port). The default device is <strong>vc</strong> in graphical
mode and <strong>stdio</strong> in non graphical mode. Use <strong>-monitor none</strong> to disable
the default monitor.</dd>
<dt>
<strong>*-qmp</strong> dev*
</dt>
<dd>
<p>Like <strong>-monitor</strong> but opens in &#39;control&#39; mode. For
example, to make QMP available on localhost port 4444:</p>
<blockquote>
<pre class="example">
-qmp tcp:localhost:4444,server=on,wait=off
</pre>
</blockquote>
</dd>
</dl>
<p>Not all options are configurable via this syntax; for maximum
flexibility use the <strong>-mon</strong> option and an accompanying <strong>-chardev</strong>.</p>
<dl>
<dt>
<strong>*-qmp-pretty</strong> dev*
</dt>
<dd>Like <strong>-qmp</strong> but uses pretty JSON formatting.</dd>
<dt>
?
</dt>
<dd>
<p><strong>*-mon</strong>
[chardev=]name[,mode=readline|control][,pretty[=on|off]]* :: Set up a
monitor connected to the chardev <strong>name</strong>. QEMU supports two monitors:
the Human Monitor Protocol (HMP; for human interaction), and the QEMU
Monitor Protocol (QMP; a JSON RPC-style protocol). The default is HMP;
<strong>mode=control</strong> selects QMP instead. <strong>pretty</strong> is only valid when
<strong>mode=control</strong>, turning on JSON pretty printing to ease human reading
and debugging.</p>
<p>
For example:</p>
<blockquote>
<pre class="example">
-chardev socket,id=mon1,host=localhost,port=4444,server=on,wait=off \
-mon chardev=mon1,mode=control,pretty=on
</pre>
</blockquote>
</dd>
</dl>
<p>enables the QMP monitor on localhost port 4444 with pretty-printing.</p>
<dl>
<dt>
<strong>*-debugcon</strong> dev*
</dt>
<dd>Redirect the debug console to host device dev
(same devices as the serial port). The debug console is an I/O port
which is typically port 0xe9; writing to that I/O port sends output to
this device. The default device is <strong>vc</strong> in graphical mode and <strong>stdio</strong>
in non graphical mode.</dd>
<dt>
<strong>*-pidfile</strong> file*
</dt>
<dd>Store the QEMU process PID in file. It is useful
if you launch QEMU from a script.</dd>
<dt>
<strong><strong>–preconfig</strong></strong>
</dt>
<dd>Pause QEMU for interactive configuration before the
machine is created, which allows querying and configuring properties
that will affect machine initialization. Use QMP command
&#39;x-exit-preconfig&#39; to exit the preconfig state and move to the next
state (i.e. run guest if -S isn&#39;t used or pause the second time if -S
is used). This option is experimental.</dd>
<dt>
<strong><strong>-S</strong></strong>
</dt>
<dd>Do not start CPU at startup (you must type &#39;c&#39; in the
monitor).</dd>
<dt>
<strong>*-overcommit</strong> mem-lock=on|off*
</dt>
<dd>
<ul>
<li>
<p><strong>*-overcommit</strong>
 cpu-pm=on|off* :: Run qemu with hints about host resource
 overcommit. The default is to assume that host overcommits all
 resources.</p>
<p>
 Locking qemu and guest memory can be enabled via <strong>mem-lock=on</strong>
 (disabled by default). This works when host memory is not
 overcommitted and reduces the worst-case latency for guest.</p>
<p>
 Guest ability to manage power state of host cpus (increasing latency
 for other processes on the same host cpu, but decreasing latency for
 guest) can be enabled via <strong>cpu-pm=on</strong> (disabled by default). This
 works best when host CPU is not overcommitted. When used, host
 estimates of CPU cycle and power utilization will be incorrect, not
 taking into account guest idle time.</p>
<dl>
<dt>
<strong>*-gdb</strong> dev*
</dt>
<dd>
<p>Accept a gdb connection on device dev (see the <em>GDB
usage</em> chapter in the System Emulation Users Guide). Note that this
option does not pause QEMU execution – if you want QEMU to not
start the guest until you connect with gdb and issue a <strong>continue</strong>
command, you will need to also pass the <strong>-S</strong> option to QEMU.</p>
<p>
The most usual configuration is to listen on a local TCP socket:</p>
<blockquote>
<pre class="example">
-gdb tcp::3117
</pre>
</blockquote>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>but you can specify other backends; UDP, pseudo TTY, or even stdio are
all reasonable use cases. For example, a stdio connection allows you to
start QEMU from within gdb and establish the connection via a pipe:</p>
<blockquote>
<blockquote>
<pre class="example">
(gdb) target remote | exec qemu-system-x86_64 -gdb stdio ...
</pre>
</blockquote>
</blockquote>
<dl>
<dt>
<strong><strong>-s</strong></strong>
</dt>
<dd>Shorthand for -gdb <em>tcp::1234</em>, i.e. open a gdbserver on TCP
port 1234 (see the <em>GDB usage</em> chapter in the System Emulation Users
Guide).</dd>
<dt>
<strong>*-d</strong> item1[,…]*
</dt>
<dd>Enable logging of specified items. Use &#39;-d help&#39;
for a list of log items.</dd>
<dt>
<strong>*-D</strong> logfile*
</dt>
<dd>Output log in logfile instead of to stderr</dd>
<dt>
<strong>*-dfilter</strong> range1[,…]*
</dt>
<dd>
<p>Filter debug output to that relevant to a
range of target addresses. The filter spec can be either start+size,
start-size or start..end where start end and size are the addresses
and sizes required. For example:</p>
<blockquote>
<pre class="example">
-dfilter 0x8000..0x8fff,0xffffffc000080000+0x200,0xffffffc000060000-0x1000
</pre>
</blockquote>
</dd>
</dl>
<p>Will dump output for any code in the 0x1000 sized block starting at
0x8000 and the 0x200 sized block starting at 0xffffffc000080000 and
another 0x1000 sized block starting at 0xffffffc00005f000.</p>
<dl>
<dt>
<strong>*-seed</strong> number*
</dt>
<dd>Force the guest to use a deterministic
pseudo-random number generator, seeded with number. This does not
affect crypto routines within the host.</dd>
<dt>
<strong>*-L</strong> path*
</dt>
<dd>Set the directory for the BIOS, VGA BIOS and keymaps.

To list all the data directories, use <strong>-L help</strong>.</dd>
<dt>
<strong><strong>-enable-kvm</strong></strong>
</dt>
<dd>Enable KVM full virtualization support. This option
is only available if KVM support is enabled when compiling.</dd>
<dt>
<strong>*-xen-domid</strong> id*
</dt>
<dd>Specify xen guest domain id (XEN only).</dd>
<dt>
<strong><strong>-xen-attach</strong></strong>
</dt>
<dd>Attach to existing xen domain. libxl will use this
when starting QEMU (XEN only). Restrict set of available xen
operations to specified domain id (XEN only).</dd>
<dt>
<strong><strong>-no-reboot</strong></strong>
</dt>
<dd>Exit instead of rebooting.</dd>
<dt>
<strong><strong>-no-shutdown</strong></strong>
</dt>
<dd>Don&#39;t exit QEMU on guest shutdown, but instead
only stop the emulation. This allows for instance switching to monitor
to commit changes to the disk image.</dd>
<dt>
<strong>*-action</strong> event=action*
</dt>
<dd>The action parameter serves to modify
QEMU&#39;s default behavior when certain guest events occur. It provides a
generic method for specifying the same behaviors that are modified by
the <strong>-no-reboot</strong> and <strong>-no-shutdown</strong> parameters.

Examples:

<strong>-action panic=none</strong> <strong>-action reboot=shutdown,shutdown=pause</strong> <strong>-device
i6300esb -action watchdog=pause</strong></dd>
<dt>
<strong>*-loadvm</strong> file*
</dt>
<dd>Start right away with a saved state (<strong>loadvm</strong> in
monitor)</dd>
<dt>
<strong><strong>-daemonize</strong></strong>
</dt>
<dd>Daemonize the QEMU process after initialization.
QEMU will not detach from standard IO until it is ready to receive
connections on any of its devices. This option is a useful way for
external programs to launch QEMU without having to cope with
initialization race conditions.</dd>
<dt>
<strong>*-option-rom</strong> file*
</dt>
<dd>Load the contents of file as an option ROM.
This option is useful to load things like EtherBoot.</dd>
<dt>
?
</dt>
<dd><strong>*-rtc</strong>
[base=utc|localtime|datetime][,clock=host|rt|vm][,driftfix=none|slew]* :: Specify
<strong>base</strong> as <strong>utc</strong> or <strong>localtime</strong> to let the RTC start at the current UTC
or local time, respectively. <strong>localtime</strong> is required for correct date
in MS-DOS or Windows. To start at a specific point in time, provide
datetime in the format <strong>2006-06-17T16:01:21</strong> or <strong>2006-06-17</strong>. The
default base is UTC.

By default the RTC is driven by the host system time. This allows
using of the RTC as accurate reference clock inside the guest,
specifically if the host time is smoothly following an accurate
external reference clock, e.g. via NTP. If you want to isolate the
guest time from the host, you can set <strong>clock</strong> to <strong>rt</strong> instead, which
provides a host monotonic clock if host support it. To even prevent
the RTC from progressing during suspension, you can set <strong>clock</strong> to
<strong>vm</strong> (virtual clock). &#39;<strong>clock=vm</strong>&#39; is recommended especially in icount
mode in order to preserve determinism; however, note that in icount
mode the speed of the virtual clock is variable and can in general
differ from the host clock.

Enable <strong>driftfix</strong> (i386 targets only) if you experience time drift
problems, specifically with Windows&#39; ACPI HAL. This option will try to
figure out how many timer interrupts were not processed by the Windows
guest and will re-inject them.</dd>
<dt>
?
</dt>
<dd><strong>*-icount</strong>
[shift=N|auto][,align=on|off][,sleep=on|off][,rr=record|replay,rrfile=filename[,rrsnapshot=snapshot]]* :: Enable
virtual instruction counter. The virtual cpu will execute one
instruction every 2^N ns of virtual time. If <strong>auto</strong> is specified then
the virtual cpu speed will be automatically adjusted to keep virtual
time within a few seconds of real time.

Note that while this option can give deterministic behavior, it does
not provide cycle accurate emulation. Modern CPUs contain superscalar
out of order cores with complex cache hierarchies. The number of
instructions executed often has little or no correlation with actual
performance.

When the virtual cpu is sleeping, the virtual time will advance at
default speed unless <strong>sleep=on</strong> is specified. With <strong>sleep=on</strong>, the
virtual time will jump to the next timer deadline instantly whenever
the virtual cpu goes to sleep mode and will not advance if no timer is
enabled. This behavior gives deterministic execution times from the
guest point of view. The default if icount is enabled is <strong>sleep=off</strong>.
<strong>sleep=on</strong> cannot be used together with either <strong>shift=auto</strong> or
<strong>align=on</strong>.

<strong>align=on</strong> will activate the delay algorithm which will try to
synchronise the host clock and the virtual clock. The goal is to have
a guest running at the real frequency imposed by the shift option.
Whenever the guest clock is behind the host clock and if <strong>align=on</strong> is
specified then we print a message to the user to inform about the
delay. Currently this option does not work when <strong>shift</strong> is <strong>auto</strong>.
Note: The sync algorithm will work for those shift values for which
the guest clock runs ahead of the host clock. Typically this happens
when the shift value is high (how high depends on the host machine).
The default if icount is enabled is <strong>align=off</strong>.

When the <strong>rr</strong> option is specified deterministic record/replay is
enabled. The <strong>rrfile=</strong> option must also be provided to specify the
path to the replay log. In record mode data is written to this file,
and in replay mode it is read back. If the <strong>rrsnapshot</strong> option is
given then it specifies a VM snapshot name. In record mode, a new VM
snapshot with the given name is created at the start of execution
recording. In replay mode this option specifies the snapshot name used
to load the initial VM state.</dd>
<dt>
<strong>*-watchdog-action</strong> action*
</dt>
<dd>The action controls what QEMU will do
when the watchdog timer expires. The default is <strong>reset</strong> (forcefully
reset the guest). Other possible actions are: <strong>shutdown</strong> (attempt to
gracefully shutdown the guest), <strong>poweroff</strong> (forcefully poweroff the
guest), <strong>inject-nmi</strong> (inject a NMI into the guest), <strong>pause</strong> (pause the
guest), <strong>debug</strong> (print a debug message and continue), or <strong>none</strong> (do
nothing).

Note that the <strong>shutdown</strong> action requires that the guest responds to
ACPI signals, which it may not be able to do in the sort of situations
where the watchdog would have expired, and thus <strong>-watchdog-action
shutdown</strong> is not recommended for production use.

Examples:

<strong>-device i6300esb -watchdog-action pause</strong></dd>
<dt>
<strong>*-echr</strong> numeric_ascii_value*
</dt>
<dd>Change the escape character used for
switching to the monitor when using monitor and serial sharing. The
default is <strong>0x01</strong> when using the <strong>-nographic</strong> option. <strong>0x01</strong> is equal
to pressing <strong>Control-a</strong>. You can select a different character from the
ascii control keys where 1 through 26 map to Control-a through
Control-z. For instance you could use the either of the following to
change the escape character to Control-t.

<strong>-echr 0x14</strong>; <strong>-echr 20</strong></dd>
<dt>
?
</dt>
<dd>
<p><strong>*-incoming</strong>
tcp:[host]:port[,to=maxport][,ipv4=on|off][,ipv6=on|off]* :: - <strong>*-incoming</strong>
  rdma:host:port[,ipv4=on|off][,ipv6=on|off]* :: Prepare for incoming
  migration, listen on a given tcp port.</p>
<dl>
<dt>
<strong>*-incoming</strong> unix:socketpath*
</dt>
<dd>Prepare for incoming migration,
listen on a given unix socket.</dd>
<dt>
<strong>*-incoming</strong> fd:fd*
</dt>
<dd>Accept incoming migration from a given file
descriptor.</dd>
<dt>
<strong>*-incoming</strong> file:filename[,offset=offset]*
</dt>
<dd>Accept incoming
migration from a given file starting at offset. offset allows the
common size suffixes, or a 0x prefix, but not both.</dd>
<dt>
<strong>*-incoming</strong> exec:cmdline*
</dt>
<dd>Accept incoming migration as an output
from specified external command.</dd>
<dt>
<strong>*-incoming</strong> defer*
</dt>
<dd>Wait for the URI to be specified via
migrate_incoming. The monitor can be used to change settings (such
as migration parameters) prior to issuing the migrate_incoming to
allow the migration to begin.</dd>
<dt>
<strong><strong>-only-migratable</strong></strong>
</dt>
<dd>Only allow migratable devices. Devices will
not be allowed to enter an unmigratable state.</dd>
<dt>
<strong><strong>-nodefaults</strong></strong>
</dt>
<dd>Don&#39;t create default devices. Normally, QEMU sets
the default devices like serial port, parallel port, virtual
console, monitor device, VGA adapter, floppy and CD-ROM drive and
others. The <strong>-nodefaults</strong> option will disable all those default
devices.</dd>
<dt>
<strong>*-runas</strong> user*
</dt>
<dd>Immediately before starting guest execution, drop
root privileges, switching to the specified user. This option is
deprecated, use <strong>-run-with user=…</strong> instead.</dd>
<dt>
<strong>*-prom-env</strong> variable=value*
</dt>
<dd>
<p>Set OpenBIOS nvram variable to given
value (PPC, SPARC only).</p>
<blockquote>
<pre class="example">
qemu-system-sparc -prom-env &#39;auto-boot?=false&#39; \
 -prom-env &#39;boot-device=sd(0,2,0):d&#39; -prom-env &#39;boot-args=linux single&#39;
</pre>
</blockquote>
</dd>
</dl>
</dd>
</dl>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-ppc -prom-env &#39;auto-boot?=false&#39; \
 -prom-env &#39;boot-device=hd:2,\yaboot&#39; \
 -prom-env &#39;boot-args=conf=hd:2,\yaboot.conf&#39;
</pre>
</blockquote>
</blockquote>
<dl>
<dt>
<strong><strong>-semihosting</strong></strong>
</dt>
<dd>
<p>Enable <em>Semihosting</em> mode (ARM, M68K, Xtensa,
MIPS, RISC-V only).</p>
<p>
<strong>WARNING:</strong></p>
<blockquote>
<p>Note that this allows guest direct access to the host filesystem, so
should only be used with a trusted guest OS.</p>
</blockquote>
</dd>
</dl>
<p>See the -semihosting-config option documentation for further information
about the facilities this enables.</p>
<ul>
<li>
<p><strong>*-semihosting-config</strong>
[enable=on|off][,target=native|gdb|auto][,chardev=id][,userspace=on|off][,arg=str[,…]]* :: Enable
and configure <em>Semihosting</em> (ARM, M68K, Xtensa, MIPS, RISC-V only).</p>
<p>
<strong>WARNING:</strong></p>
<blockquote>
<p>Note that this allows guest direct access to the host filesystem, so
should only be used with a trusted guest OS.</p>
</blockquote>
</li>
</ul>
<blockquote>
<dl>
<dt>
<strong><strong>target=native|gdb|auto</strong></strong>
</dt>
<dd>Defines where the semihosting calls will
be addressed, to QEMU (<strong>native</strong>) or to GDB (<strong>gdb</strong>). The default is
<strong>auto</strong>, which means <strong>gdb</strong> during debug sessions and <strong>native</strong>
otherwise.</dd>
<dt>
<strong><strong>chardev=str1</strong></strong>
</dt>
<dd>Send the output to a chardev backend output for
native or auto output when not in gdb</dd>
<dt>
<strong><strong>userspace=on|off</strong></strong>
</dt>
<dd>Allows code running in guest userspace to
access the semihosting interface. The default is that only privileged
guest code can make semihosting calls. Note that setting
<strong>userspace=on</strong> should only be used if all guest code is trusted (for
example, in bare-metal test case code).</dd>
<dt>
<strong><strong>arg=str1,arg=str2,…</strong></strong>
</dt>
<dd>Allows the user to pass input arguments,
and can be used multiple times to build up a list. The old-style
<strong>-kernel*/</strong>-append* method of passing a command line is still
supported for backward compatibility. If both the
<strong>–semihosting-config arg</strong> and the <strong>-kernel*/</strong>-append* are specified,
the former is passed to semihosting as it always takes precedence.</dd>
</dl>
</blockquote>
<dl>
<dt>
<strong><strong>-old-param</strong></strong>
</dt>
<dd>Old param mode (ARM only).</dd>
<dt>
?
</dt>
<dd>
<p><strong>*-sandbox</strong>
arg[,obsolete=string][,elevateprivileges=string][,spawn=string][,resourcecontrol=string]* :: Enable
Seccomp mode 2 system call filter. &#39;on&#39; will enable syscall filtering
and &#39;off&#39; will disable it. The default is &#39;off&#39;.</p>
<dl>
<dt>
<strong><strong>obsolete=string</strong></strong>
</dt>
<dd>Enable Obsolete system calls</dd>
<dt>
<strong><strong>elevateprivileges=string</strong></strong>
</dt>
<dd>Disable set*uid|gid system calls</dd>
<dt>
<strong><strong>spawn=string</strong></strong>
</dt>
<dd>Disable *fork and execve</dd>
<dt>
<strong><strong>resourcecontrol=string</strong></strong>
</dt>
<dd>Disable process affinity and schedular
priority</dd>
</dl>
</dd>
<dt>
<strong>*-readconfig</strong> file*
</dt>
<dd>Read device configuration from file. This
approach is useful when you want to spawn QEMU process with many
command line options but you don&#39;t want to exceed the command line
character limit.</dd>
<dt>
<strong><strong>-no-user-config</strong></strong>
</dt>
<dd>The <strong>-no-user-config</strong> option makes QEMU not
load any of the user-provided config files on sysconfdir.</dd>
<dt>
<strong>*-trace</strong> [[enable=]pattern][,events=file][,file=file]*
</dt>
<dd>
<p>Specify
tracing options.</p>
<p>
<strong>[enable=]PATTERN</strong></p>
<blockquote>
<p>Immediately enable events matching <em>PATTERN</em> (either event name or a
globbing pattern). This option is only available if QEMU has been
compiled with the <strong>simple</strong>, <strong>log</strong> or <strong>ftrace</strong> tracing backend. To
specify multiple events or patterns, specify the <strong>-trace</strong> option
multiple times.</p>
<p>
Use <strong>-trace help</strong> to print a list of names of trace points.</p>
</blockquote>
</dd>
</dl>
<p><strong>events=FILE</strong></p>
<blockquote>
<blockquote>
<p>Immediately enable events listed in <em>FILE</em>. The file must contain one
event name (as listed in the <strong>trace-events-all</strong> file) per line; globbing
patterns are accepted too. This option is only available if QEMU has
been compiled with the <strong>simple</strong>, <strong>log</strong> or <strong>ftrace</strong> tracing backend.</p>
</blockquote>
</blockquote>
<p>
<strong>file=FILE</strong></p>
<blockquote>
<blockquote>
<p>Log output traces to <em>FILE</em>. This option is only available if QEMU has
been compiled with the <strong>simple</strong> tracing backend.</p>
</blockquote>
</blockquote>
<dl>
<dt>
<strong>*-plugin</strong> file=file[,argname=argvalue]*
</dt>
<dd>
<p>Load a plugin.</p>
<dl>
<dt>
<strong><strong>file=file</strong></strong>
</dt>
<dd>Load the given plugin from a shared library file.</dd>
<dt>
<strong><strong>argname=argvalue</strong></strong>
</dt>
<dd>Argument passed to the plugin. (Can be given
multiple times.)</dd>
</dl>
</dd>
<dt>
?
</dt>
<dd><strong>*-run-with</strong>
[async-teardown=on|off][,chroot=dir][user=username|uid:gid]* :: Set
QEMU process lifecycle options.

<strong>async-teardown=on</strong> enables asynchronous teardown. A new process
called &#34;cleanup/&lt;QEMU_PID&gt;&#34; will be created at startup sharing the
address space with the main QEMU process, using clone. It will wait
for the main QEMU process to terminate completely, and then exit. This
allows QEMU to terminate very quickly even if the guest was huge,
leaving the teardown of the address space to the cleanup process.
Since the cleanup process shares the same cgroups as the main QEMU
process, accounting is performed correctly. This only works if the
cleanup process is not forcefully killed with SIGKILL before the main
QEMU process has terminated completely.

<strong>chroot=dir</strong> can be used for doing a chroot to the specified directory
immediately before starting the guest execution. This is especially
useful in combination with -runas.

<strong>user=username</strong> or <strong>user=uid:gid</strong> can be used to drop root privileges
before starting guest execution. QEMU will use the <strong>setuid</strong> and
<strong>setgid</strong> system calls to switch to the specified identity. Note that
the <strong>user=username</strong> syntax will also apply the full set of
supplementary groups for the user, whereas the <strong>user=uid:gid</strong> will use
only the <strong>gid</strong> group.</dd>
<dt>
<strong>*-msg</strong> [timestamp[=on|off]][,guest-name[=on|off]]*
</dt>
<dd>
<p>Control error
message format.</p>
<dl>
<dt>
<strong><strong>timestamp=on|off</strong></strong>
</dt>
<dd>Prefix messages with a timestamp. Default is
off.</dd>
<dt>
<strong><strong>guest-name=on|off</strong></strong>
</dt>
<dd>Prefix messages with guest name but only if
-name guest option is set otherwise the option is ignored. Default
is off.</dd>
</dl>
</dd>
<dt>
<strong>*-dump-vmstate</strong> file*
</dt>
<dd>Dump json-encoded vmstate information for
current machine type to file in file</dd>
<dt>
<strong><strong>-enable-sync-profile</strong></strong>
</dt>
<dd>Enable synchronization profiling.</dd>
<dt>
<strong><strong>-perfmap</strong></strong>
</dt>
<dd>Generate a map file for Linux perf tools that will
allow basic profiling information to be broken down into basic blocks.</dd>
<dt>
<strong><strong>-jitdump</strong></strong>
</dt>
<dd>Generate a dump file for Linux perf tools that maps
basic blocks to symbol names, line numbers and JITted code.</dd>
</dl>
</blockquote>
</div>
</div>
<div id="outline-container-headline-16" class="outline-3">
<h3 id="headline-16">
Generic object creation
</h3>
<div id="outline-text-headline-16" class="outline-text-3">
<blockquote>
<dl>
<dt>
<strong>*-object</strong> typename[,prop1=value1,…]*
</dt>
<dd>
<p>Create a new object of type
typename setting properties in the order they are specified. Note that
the &#39;id&#39; property must be set. These objects are placed in the
&#39;/objects&#39; path.</p>
<ul>
<li>
<p><strong>*-object</strong>
memory-backend-file,id=id,size=size,mem-path=dir,share=on|off,discard-data=on|off,merge=on|off,dump=on|off,prealloc=on|off,host-nodes=host-nodes,policy=default|preferred|bind|interleave,align=align,offset=offset,readonly=on|off,rom=on|off|auto* :: Creates
a memory file backend object, which can be used to back the guest
RAM with huge pages.</p>
<p>
The <strong>id</strong> parameter is a unique ID that will be used to reference
this memory region in other parameters, e.g. <strong>-numa</strong>, <strong>-device
nvdimm</strong>, etc.</p>
<p>
The <strong>size</strong> option provides the size of the memory region, and
accepts common suffixes, e.g. <strong>500M</strong>.</p>
<p>
The <strong>mem-path</strong> provides the path to either a shared memory or huge
page filesystem mount.</p>
<p>
The <strong>share</strong> boolean option determines whether the memory region is
marked as private to QEMU, or shared. The latter allows a
co-operating external process to access the QEMU memory region.</p>
<p>
Setting share=on might affect the ability to configure NUMA bindings
for the memory backend under some circumstances, see
Documentation/vm/numa_memory_policy.txt on the Linux kernel source
tree for additional details.</p>
<p>
Setting the <strong>discard-data</strong> boolean option to on indicates that file
contents can be destroyed when QEMU exits, to avoid unnecessarily
flushing data to the backing file. Note that <strong>discard-data</strong> is only
an optimization, and QEMU might not discard file contents if it
aborts unexpectedly or is terminated using SIGKILL.</p>
<p>
The <strong>merge</strong> boolean option enables memory merge, also known as
MADV_MERGEABLE, so that Kernel Samepage Merging will consider the
pages for memory deduplication.</p>
<p>
Setting the <strong>dump</strong> boolean option to off excludes the memory from
core dumps. This feature is also known as MADV_DONTDUMP.</p>
<p>
The <strong>prealloc</strong> boolean option enables memory preallocation.</p>
<p>
The <strong>host-nodes</strong> option binds the memory range to a list of NUMA
host nodes.</p>
<p>
The <strong>policy</strong> option sets the NUMA policy to one of the following
values:</p>
<dl>
<dt>
<strong><strong>default</strong></strong>
</dt>
<dd>default host policy</dd>
<dt>
<strong><strong>preferred</strong></strong>
</dt>
<dd>prefer the given host node list for allocation</dd>
<dt>
<strong><strong>bind</strong></strong>
</dt>
<dd>restrict memory allocation to the given host node list</dd>
<dt>
<strong><strong>interleave</strong></strong>
</dt>
<dd>interleave memory allocations across the given
host node list</dd>
</dl>
</li>
</ul>
<p>The <strong>align</strong> option specifies the base address alignment when QEMU
mmap(2) <strong>mem-path</strong>, and accepts common suffixes, eg <strong>2M</strong>. Some backend
store specified by <strong>mem-path</strong> requires an alignment different than the
default one used by QEMU, eg the device DAX /dev/dax0.0 requires 2M
alignment rather than 4K. In such cases, users can specify the
required alignment via this option.</p>
<p>
The <strong>offset</strong> option specifies the offset into the target file that the
region starts at. You can use this parameter to back multiple regions
with a single file.</p>
<p>
The <strong>pmem</strong> option specifies whether the backing file specified by
<strong>mem-path</strong> is in host persistent memory that can be accessed using the
SNIA NVM programming model (e.g. Intel NVDIMM). If <strong>pmem</strong> is set to
&#39;on&#39;, QEMU will take necessary operations to guarantee the persistence
of its own writes to <strong>mem-path</strong> (e.g. in vNVDIMM label emulation and
live migration). Also, we will map the backend-file with MAP_SYNC
flag, which ensures the file metadata is in sync for <strong>mem-path</strong> in
case of host crash or a power failure. MAP_SYNC requires support from
both the host kernel (since Linux kernel 4.15) and the filesystem of
<strong>mem-path</strong> mounted with DAX option.</p>
<p>
The <strong>readonly</strong> option specifies whether the backing file is opened
read-only or read-write (default).</p>
<p>
The <strong>rom</strong> option specifies whether to create Read Only Memory (ROM)
that cannot be modified by the VM. Any write attempts to such ROM will
be denied. Most use cases want proper RAM instead of ROM. However,
selected use cases, like R/O NVDIMMs, can benefit from ROM. If set to
<strong>on</strong>, create ROM; if set to <strong>off</strong>, create writable RAM; if set to
<strong>auto</strong> (default), the value of the <strong>readonly</strong> option is used. This
option is primarily helpful when we want to have writable RAM in
configurations that would traditionally create ROM before the <strong>rom</strong>
option was introduced: VM templating, where we want to open a file
readonly (<strong>readonly=on</strong>) and mark the memory to be private for QEMU
(<strong>share=off</strong>). For this use case, we need writable RAM instead of ROM,
and want to also set <strong>rom=off</strong>.</p>
<ul>
<li><strong>*-object</strong>
memory-backend-ram,id=id,merge=on|off,dump=on|off,share=on|off,prealloc=on|off,size=size,host-nodes=host-nodes,policy=default|preferred|bind|interleave* :: Creates
a memory backend object, which can be used to back the guest RAM.
Memory backend objects offer more control than the <strong>-m</strong> option that
is traditionally used to define guest RAM. Please refer to
<strong>memory-backend-file</strong> for a description of the options.</li>
<li><strong>*-object</strong>
memory-backend-memfd,id=id,merge=on|off,dump=on|off,share=on|off,prealloc=on|off,size=size,host-nodes=host-nodes,policy=default|preferred|bind|interleave,seal=on|off,hugetlb=on|off,hugetlbsize=size* :: Creates
an anonymous memory file backend object, which allows QEMU to share
the memory with an external process (e.g. when using vhost-user).
The memory is allocated with memfd and optional sealing. (Linux
only)

The <strong>seal</strong> option creates a sealed-file, that will block further
resizing the memory (&#39;on&#39; by default).

The <strong>hugetlb</strong> option specify the file to be created resides in the
hugetlbfs filesystem (since Linux 4.14). Used in conjunction with
the <strong>hugetlb</strong> option, the <strong>hugetlbsize</strong> option specify the hugetlb
page size on systems that support multiple hugetlb page sizes (it
must be a power of 2 value supported by the system).

In some versions of Linux, the <strong>hugetlb</strong> option is incompatible with
the <strong>seal</strong> option (requires at least Linux 4.16).

Please refer to <strong>memory-backend-file</strong> for a description of the other
options.

The <strong>share</strong> boolean option is on by default with memfd.</li>
<li><strong>*-object</strong>
memory-backend-shm,id=id,merge=on|off,dump=on|off,share=on|off,prealloc=on|off,size=size,host-nodes=host-nodes,policy=default|preferred|bind|interleave* :: Creates
a POSIX shared memory backend object, which allows QEMU to share the
memory with an external process (e.g. when using vhost-user).

<strong>memory-backend-shm</strong> is a more portable and less featureful version
of <strong>memory-backend-memfd</strong>. It can then be used in any POSIX system,
especially when memfd is not supported.

Please refer to <strong>memory-backend-file</strong> for a description of the
options.

The <strong>share</strong> boolean option is on by default with shm. Setting it to
off will cause a failure during allocation because it is not
supported by this backend.</li>
<li><strong>*-object</strong> iommufd,id=id[,fd=fd]* :: Creates an iommufd backend
which allows control of DMA mapping through the <strong>/dev/iommu</strong> device.

The <strong>id</strong> parameter is a unique ID which frontends (such as vfio-pci
of vdpa) will use to connect with the iommufd backend.

The <strong>fd</strong> parameter is an optional pre-opened file descriptor
resulting from <strong>/dev/iommu</strong> opening. Usually the iommufd is shared
across all subsystems, bringing the benefit of centralized reference
counting.</li>
<li><strong>*-object</strong> rng-builtin,id=id* :: Creates a random number generator
backend which obtains entropy from QEMU builtin functions. The <strong>id</strong>
parameter is a unique ID that will be used to reference this entropy
backend from the <strong>virtio-rng</strong> device. By default, the <strong>virtio-rng</strong>
device uses this RNG backend.</li>
<li><strong>*-object</strong> rng-random,id=id,filename=/dev/random* :: Creates a
random number generator backend which obtains entropy from a device
on the host. The <strong>id</strong> parameter is a unique ID that will be used to
reference this entropy backend from the <strong>virtio-rng</strong> device. The
<strong>filename</strong> parameter specifies which file to obtain entropy from and
if omitted defaults to <strong>/dev/urandom</strong>.</li>
<li><strong>*-object</strong> rng-egd,id=id,chardev=chardevid* :: Creates a random
number generator backend which obtains entropy from an external
daemon running on the host. The <strong>id</strong> parameter is a unique ID that
will be used to reference this entropy backend from the <strong>virtio-rng</strong>
device. The <strong>chardev</strong> parameter is the unique ID of a character
device backend that provides the connection to the RNG daemon.</li>
<li><strong>*-object</strong>
tls-creds-anon,id=id,endpoint=endpoint,dir=/path/to/cred/dir,verify-peer=on|off* :: Creates
a TLS anonymous credentials object, which can be used to provide TLS
support on network backends. The <strong>id</strong> parameter is a unique ID which
network backends will use to access the credentials. The <strong>endpoint</strong>
is either <strong>server</strong> or <strong>client</strong> depending on whether the QEMU network
backend that uses the credentials will be acting as a client or as a
server. If <strong>verify-peer</strong> is enabled (the default) then once the
handshake is completed, the peer credentials will be verified,
though this is a no-op for anonymous credentials.

The dir parameter tells QEMU where to find the credential files. For
server endpoints, this directory may contain a file dh-params.pem
providing diffie-hellman parameters to use for the TLS server. If
the file is missing, QEMU will generate a set of DH parameters at
startup. This is a computationally expensive operation that consumes
random pool entropy, so it is recommended that a persistent set of
parameters be generated upfront and saved.</li>
<li><strong>*-object</strong>
tls-creds-psk,id=id,endpoint=endpoint,dir=/path/to/keys/dir[,username=username]* :: Creates
a TLS Pre-Shared Keys (PSK) credentials object, which can be used to
provide TLS support on network backends. The <strong>id</strong> parameter is a
unique ID which network backends will use to access the credentials.
The <strong>endpoint</strong> is either <strong>server</strong> or <strong>client</strong> depending on whether
the QEMU network backend that uses the credentials will be acting as
a client or as a server. For clients only, <strong>username</strong> is the
username which will be sent to the server. If omitted it defaults to
&#34;qemu&#34;.

The dir parameter tells QEMU where to find the keys file. It is
called &#34;dir/keys.psk&#34; and contains &#34;username:key&#34; pairs. This file
can most easily be created using the GnuTLS <strong>psktool</strong> program.

For server endpoints, dir may also contain a file dh-params.pem
providing diffie-hellman parameters to use for the TLS server. If
the file is missing, QEMU will generate a set of DH parameters at
startup. This is a computationally expensive operation that consumes
random pool entropy, so it is recommended that a persistent set of
parameters be generated up front and saved.</li>
<li><strong>*-object</strong>
tls-creds-x509,id=id,endpoint=endpoint,dir=/path/to/cred/dir,priority=priority,verify-peer=on|off,passwordid=id* :: Creates
a TLS anonymous credentials object, which can be used to provide TLS
support on network backends. The <strong>id</strong> parameter is a unique ID which
network backends will use to access the credentials. The <strong>endpoint</strong>
is either <strong>server</strong> or <strong>client</strong> depending on whether the QEMU network
backend that uses the credentials will be acting as a client or as a
server. If <strong>verify-peer</strong> is enabled (the default) then once the
handshake is completed, the peer credentials will be verified. With
x509 certificates, this implies that the clients must be provided
with valid client certificates too.

The dir parameter tells QEMU where to find the credential files. For
server endpoints, this directory may contain a file dh-params.pem
providing diffie-hellman parameters to use for the TLS server. If
the file is missing, QEMU will generate a set of DH parameters at
startup. This is a computationally expensive operation that consumes
random pool entropy, so it is recommended that a persistent set of
parameters be generated upfront and saved.

For x509 certificate credentials the directory will contain further
files providing the x509 certificates. The certificates must be
stored in PEM format, in filenames ca-cert.pem, ca-crl.pem
(optional), server-cert.pem (only servers), server-key.pem (only
servers), client-cert.pem (only clients), and client-key.pem (only
clients).

For the server-key.pem and client-key.pem files which contain
sensitive private keys, it is possible to use an encrypted version
by providing the passwordid parameter. This provides the ID of a
previously created <strong>secret</strong> object containing the password for
decryption.

The priority parameter allows to override the global default
priority used by gnutls. This can be useful if the system
administrator needs to use a weaker set of crypto priorities for
QEMU without potentially forcing the weakness onto all applications.
Or conversely if one wants wants a stronger default for QEMU than
for all other applications, they can do this through this parameter.
Its format is a gnutls priority string as described at
<em><a href="https://gnutls.org/manual/html_node/Priority-Strings.html">https://gnutls.org/manual/html_node/Priority-Strings.html</a></em>.</li>
<li>
<p><strong>*-object</strong> tls-cipher-suites,id=id,priority=priority* :: Creates a
TLS cipher suites object, which can be used to control the TLS
cipher/protocol algorithms that applications are permitted to use.</p>
<p>
The <strong>id</strong> parameter is a unique ID which frontends will use to access
the ordered list of permitted TLS cipher suites from the host.</p>
<p>
The <strong>priority</strong> parameter allows to override the global default
priority used by gnutls. This can be useful if the system
administrator needs to use a weaker set of crypto priorities for
QEMU without potentially forcing the weakness onto all applications.
Or conversely if one wants wants a stronger default for QEMU than
for all other applications, they can do this through this parameter.
Its format is a gnutls priority string as described at
<em><a href="https://gnutls.org/manual/html_node/Priority-Strings.html">https://gnutls.org/manual/html_node/Priority-Strings.html</a></em>.</p>
<p>
An example of use of this object is to control UEFI HTTPS Boot. The
tls-cipher-suites object exposes the ordered list of permitted TLS
cipher suites from the host side to the guest firmware, via fw_cfg.
The list is represented as an array of IANA_TLS_CIPHER objects. The
firmware uses the IANA_TLS_CIPHER array for configuring guest-side
TLS.</p>
<p>
In the following example, the priority at which the host-side policy
is retrieved is given by the <strong>priority</strong> property. Given that QEMU
uses GNUTLS, <strong>priority=@SYSTEM</strong> may be used to refer to
/etc/crypto-policies/back-ends/gnutls.config.</p>
<blockquote>
<pre class="example">
# qemu-system-x86_64 \
    -object tls-cipher-suites,id=mysuite0,priority=@SYSTEM \
    -fw_cfg name=etc/edk2/https/ciphers,gen_id=mysuite0
</pre>
</blockquote>
</li>
<li><strong>*-object</strong>
filter-buffer,id=id,netdev=netdevid,interval=t[,queue=all|rx|tx][,status=on|off][,position=head|tail|id=&lt;id&gt;][,insert=behind|before]* :: Interval
t can&#39;t be 0, this filter batches the packet delivery: all packets
arriving in a given interval on netdev netdevid are delayed until
the end of the interval. Interval is in microseconds. <strong>status</strong> is
optional that indicate whether the netfilter is on (enabled) or off
(disabled), the default status for netfilter will be &#39;on&#39;.

queue all|rx|tx is an option that can be applied to any netfilter.

<strong>all</strong>: the filter is attached both to the receive and the transmit
queue of the netdev (default).

<strong>rx</strong>: the filter is attached to the receive queue of the netdev,
where it will receive packets sent to the netdev.

<strong>tx</strong>: the filter is attached to the transmit queue of the netdev,
where it will receive packets sent by the netdev.

position head|tail|id=&lt;id&gt; is an option to specify where the filter
should be inserted in the filter list. It can be applied to any
netfilter.

<strong>head</strong>: the filter is inserted at the head of the filter list,
before any existing filters.

<strong>tail</strong>: the filter is inserted at the tail of the filter list,
behind any existing filters (default).

<strong>id=&lt;id&gt;</strong>: the filter is inserted before or behind the filter
specified by &lt;id&gt;, see the insert option below.

insert behind|before is an option to specify where to insert the new
filter relative to the one specified with position=id=&lt;id&gt;. It can
be applied to any netfilter.

<strong>before</strong>: insert before the specified filter.

<strong>behind</strong>: insert behind the specified filter (default).</li>
<li><strong>*-object</strong>
filter-mirror,id=id,netdev=netdevid,outdev=chardevid,queue=all|rx|tx[,vnet_hdr_support][,position=head|tail|id=&lt;id&gt;][,insert=behind|before]* :: filter-mirror
on netdev netdevid,mirror net packet to chardevchardevid, if it has
the vnet_hdr_support flag, filter-mirror will mirror packet with
vnet_hdr_len.</li>
<li><strong>*-object</strong>
filter-redirector,id=id,netdev=netdevid,indev=chardevid,outdev=chardevid,queue=all|rx|tx[,vnet_hdr_support][,position=head|tail|id=&lt;id&gt;][,insert=behind|before]* :: filter-redirector
on netdev netdevid,redirect filter&#39;s net packet to chardev
chardevid,and redirect indev&#39;s packet to filter.if it has the
vnet_hdr_support flag, filter-redirector will redirect packet with
vnet_hdr_len. Create a filter-redirector we need to differ outdev id
from indev id, id can not be the same. we can just use indev or
outdev, but at least one of indev or outdev need to be specified.</li>
<li><strong>*-object</strong>
filter-rewriter,id=id,netdev=netdevid,queue=all|rx|tx,[vnet_hdr_support][,position=head|tail|id=&lt;id&gt;][,insert=behind|before]* :: Filter-rewriter
is a part of COLO project.It will rewrite tcp packet to secondary
from primary to keep secondary tcp connection,and rewrite tcp packet
to primary from secondary make tcp packet can be handled by
client.if it has the vnet_hdr_support flag, we can parse packet with
vnet header.

usage: colo secondary: -object
filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0 -object
filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1 -object
filter-rewriter,id=rew0,netdev=hn0,queue=all</li>
<li><strong>*-object</strong>
filter-dump,id=id,netdev=dev[,file=filename][,maxlen=len][,position=head|tail|id=&lt;id&gt;][,insert=behind|before]* :: Dump
the network traffic on netdev dev to the file specified by filename.
At most len bytes (64k by default) per packet are stored. The file
format is libpcap, so it can be analyzed with tools such as tcpdump
or Wireshark.</li>
<li>
<p><strong>*-object</strong>
colo-compare,id=id,primary_in=chardevid,secondary_in=chardevid,outdev=chardevid,iothread=id[,vnet_hdr_support][,notify_dev=id][,compare_timeout=@var{ms}][,expired_scan_cycle=@var{ms}][,max_queue_size=@var{size}]* :: Colo-compare
gets packet from primary_in chardevid and secondary_in, then compare
whether the payload of primary packet and secondary packet are the
same. If same, it will output primary packet to out_dev, else it
will notify COLO-framework to do checkpoint and send primary packet
to out_dev. In order to improve efficiency, we need to put the task
of comparison in another iothread. If it has the vnet_hdr_support
flag, colo compare will send/recv packet with vnet_hdr_len. The
<em>compare_timeout=@var{ms</em>} determines the maximum time of the
colo-compare hold the packet. The <em>expired_scan_cycle=@var{ms</em>} is
to set the period of scanning expired primary node network packets.
The <em>max_queue_size=@var{size</em>} is to set the max compare queue size
depend on user environment. If user want to use Xen COLO, need to
add the notify_dev to notify Xen colo-frame to do checkpoint.</p>
<p>
COLO-compare must be used with the help of filter-mirror,
filter-redirector and filter-rewriter.</p>
<blockquote>
<pre class="example">
KVM COLO

primary:
-netdev tap,id=hn0,vhost=off
-device e1000,id=e0,netdev=hn0,mac=52:a4:00:12:78:66
-chardev socket,id=mirror0,host=3.3.3.3,port=9003,server=on,wait=off
-chardev socket,id=compare1,host=3.3.3.3,port=9004,server=on,wait=off
-chardev socket,id=compare0,host=3.3.3.3,port=9001,server=on,wait=off
-chardev socket,id=compare0-0,host=3.3.3.3,port=9001
-chardev socket,id=compare_out,host=3.3.3.3,port=9005,server=on,wait=off
-chardev socket,id=compare_out0,host=3.3.3.3,port=9005
-object iothread,id=iothread1
-object filter-mirror,id=m0,netdev=hn0,queue=tx,outdev=mirror0
-object filter-redirector,netdev=hn0,id=redire0,queue=rx,indev=compare_out
-object filter-redirector,netdev=hn0,id=redire1,queue=rx,outdev=compare0
-object colo-compare,id=comp0,primary_in=compare0-0,secondary_in=compare1,outdev=compare_out0,iothread=iothread1

secondary:
-netdev tap,id=hn0,vhost=off
-device e1000,netdev=hn0,mac=52:a4:00:12:78:66
-chardev socket,id=red0,host=3.3.3.3,port=9003
-chardev socket,id=red1,host=3.3.3.3,port=9004
-object filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0
-object filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1


Xen COLO

primary:
-netdev tap,id=hn0,vhost=off
-device e1000,id=e0,netdev=hn0,mac=52:a4:00:12:78:66
-chardev socket,id=mirror0,host=3.3.3.3,port=9003,server=on,wait=off
-chardev socket,id=compare1,host=3.3.3.3,port=9004,server=on,wait=off
-chardev socket,id=compare0,host=3.3.3.3,port=9001,server=on,wait=off
-chardev socket,id=compare0-0,host=3.3.3.3,port=9001
-chardev socket,id=compare_out,host=3.3.3.3,port=9005,server=on,wait=off
-chardev socket,id=compare_out0,host=3.3.3.3,port=9005
-chardev socket,id=notify_way,host=3.3.3.3,port=9009,server=on,wait=off
-object filter-mirror,id=m0,netdev=hn0,queue=tx,outdev=mirror0
-object filter-redirector,netdev=hn0,id=redire0,queue=rx,indev=compare_out
-object filter-redirector,netdev=hn0,id=redire1,queue=rx,outdev=compare0
-object iothread,id=iothread1
-object colo-compare,id=comp0,primary_in=compare0-0,secondary_in=compare1,outdev=compare_out0,notify_dev=notify_way,iothread=iothread1

secondary:
-netdev tap,id=hn0,vhost=off
-device e1000,netdev=hn0,mac=52:a4:00:12:78:66
-chardev socket,id=red0,host=3.3.3.3,port=9003
-chardev socket,id=red1,host=3.3.3.3,port=9004
-object filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0
-object filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1
</pre>
</blockquote>
</li>
</ul>
<p>If you want to know the detail of above command line, you can read the
colo-compare git log.</p>
<ul>
<li>
<p><strong>*-object</strong>
cryptodev-backend-builtin,id=id[,queues=queues]* :: Creates a
cryptodev backend which executes crypto operations from the QEMU
cipher APIs. The id parameter is a unique ID that will be used to
reference this cryptodev backend from the <strong>virtio-crypto</strong> device.
The queues parameter is optional, which specify the queue number of
cryptodev backend, the default of queues is 1.</p>
<blockquote>
<pre class="example">
# qemu-system-x86_64 \
  [...] \
      -object cryptodev-backend-builtin,id=cryptodev0 \
      -device virtio-crypto-pci,id=crypto0,cryptodev=cryptodev0 \
  [...]
</pre>
</blockquote>
</li>
<li>
<p><strong>*-object</strong>
cryptodev-vhost-user,id=id,chardev=chardevid[,queues=queues]* :: Creates
a vhost-user cryptodev backend, backed by a chardev chardevid. The
id parameter is a unique ID that will be used to reference this
cryptodev backend from the <strong>virtio-crypto</strong> device. The chardev
should be a unix domain socket backed one. The vhost-user uses a
specifically defined protocol to pass vhost ioctl replacement
messages to an application on the other end of the socket. The
queues parameter is optional, which specify the queue number of
cryptodev backend for multiqueue vhost-user, the default of queues
is 1.</p>
<blockquote>
<pre class="example">
# qemu-system-x86_64 \
  [...] \
      -chardev socket,id=chardev0,path=/path/to/socket \
      -object cryptodev-vhost-user,id=cryptodev0,chardev=chardev0 \
      -device virtio-crypto-pci,id=crypto0,cryptodev=cryptodev0 \
  [...]
</pre>
</blockquote>
</li>
<li>
<p><strong>*-object</strong>
secret,id=id,data=string,format=raw|base64[,keyid=secretid,iv=string]* :: - <strong>*-object</strong>
  secret,id=id,file=filename,format=raw|base64[,keyid=secretid,iv=string]* :: Defines
  a secret to store a password, encryption key, or some other
  sensitive data. The sensitive data can either be passed directly
  via the data parameter, or indirectly via the file parameter.
  Using the data parameter is insecure unless the sensitive data is
  encrypted.</p>
<p>
  The sensitive data can be provided in raw format (the default), or
  base64. When encoded as JSON, the raw format only supports valid
  UTF-8 characters, so base64 is recommended for sending binary
  data. QEMU will convert from which ever format is provided to the
  format it needs internally. eg, an RBD password can be provided in
  raw format, even though it will be base64 encoded when passed onto
  the RBD sever.</p>
<p>
  For added protection, it is possible to encrypt the data
  associated with a secret using the AES-256-CBC cipher. Use of
  encryption is indicated by providing the keyid and iv parameters.
  The keyid parameter provides the ID of a previously defined secret
  that contains the AES-256 decryption key. This key should be
  32-bytes long and be base64 encoded. The iv parameter provides the
  random initialization vector used for encryption of this
  particular secret and should be a base64 encrypted string of the
  16-byte IV.</p>
<p>
  The simplest (insecure) usage is to provide the secret inline</p>
<blockquote>
<pre class="example">
# qemu-system-x86_64 -object secret,id=sec0,data=letmein,format=raw
</pre>
</blockquote>
</li>
</ul>
<p>The simplest secure usage is to provide the secret via a file</p>
<p>
​# printf &#34;letmein&#34; &gt; mypasswd.txt # QEMU_SYSTEM_MACRO -object
secret,id=sec0,file=mypasswd.txt,format=raw</p>
<p>
For greater security, AES-256-CBC should be used. To illustrate usage,
consider the openssl command line tool which can encrypt the data.
Note that when encrypting, the plaintext must be padded to the cipher
block size (32 bytes) using the standard PKCS#5/6 compatible padding
algorithm.</p>
<p>
First a master key needs to be created in base64 encoding:</p>
<blockquote>
<blockquote>
<pre class="example">
# openssl rand -base64 32 &gt; key.b64
# KEY=$(base64 -d key.b64 | hexdump  -v -e &#39;/1 &#34;%02X&#34;&#39;)
</pre>
</blockquote>
</blockquote>
<p>
Each secret to be encrypted needs to have a random initialization
vector generated. These do not need to be kept secret</p>
<blockquote>
<blockquote>
<pre class="example">
# openssl rand -base64 16 &gt; iv.b64
# IV=$(base64 -d iv.b64 | hexdump  -v -e &#39;/1 &#34;%02X&#34;&#39;)
</pre>
</blockquote>
</blockquote>
<p>
The secret to be defined can now be encrypted, in this case we&#39;re
telling openssl to base64 encode the result, but it could be left as
raw bytes if desired.</p>
<blockquote>
<blockquote>
<pre class="example">
# SECRET=$(printf &#34;letmein&#34; |
           openssl enc -aes-256-cbc -a -K $KEY -iv $IV)
</pre>
</blockquote>
</blockquote>
<p>
When launching QEMU, create a master secret pointing to <strong>key.b64</strong> and
specify that to be used to decrypt the user password. Pass the
contents of <strong>iv.b64</strong> to the second secret</p>
<blockquote>
<blockquote>
<pre class="example">
# qemu-system-x86_64 \
    -object secret,id=secmaster0,format=base64,file=key.b64 \
    -object secret,id=sec0,keyid=secmaster0,format=base64,\
        data=$SECRET,iv=$(&lt;iv.b64)
</pre>
</blockquote>
</blockquote>
<ul>
<li>
<p><strong>*-object</strong>
sev-guest,id=id,cbitpos=cbitpos,reduced-phys-bits=val,[sev-device=string,policy=policy,handle=handle,dh-cert-file=file,session-file=file,kernel-hashes=on|off]* :: Create
a Secure Encrypted Virtualization (SEV) guest object, which can be
used to provide the guest memory encryption support on AMD
processors.</p>
<p>
When memory encryption is enabled, one of the physical address bit
(aka the C-bit) is utilized to mark if a memory page is protected.
The <strong>cbitpos</strong> is used to provide the C-bit position. The C-bit
position is Host family dependent hence user must provide this
value. On EPYC, the value should be 47.</p>
<p>
When memory encryption is enabled, we loose certain bits in physical
address space. The <strong>reduced-phys-bits</strong> is used to provide the number
of bits we loose in physical address space. Similar to C-bit, the
value is Host family dependent. On EPYC, a guest will lose a maximum
of 1 bit, so the value should be 1.</p>
<p>
The <strong>sev-device</strong> provides the device file to use for communicating
with the SEV firmware running inside AMD Secure Processor. The
default device is &#39;/dev/sev&#39;. If hardware supports memory encryption
then /dev/sev devices are created by CCP driver.</p>
<p>
The <strong>policy</strong> provides the guest policy to be enforced by the SEV
firmware and restrict what configuration and operational commands
can be performed on this guest by the hypervisor. The policy should
be provided by the guest owner and is bound to the guest and cannot
be changed throughout the lifetime of the guest. The default is 0.</p>
<p>
If guest <strong>policy</strong> allows sharing the key with another SEV guest then
<strong>handle</strong> can be use to provide handle of the guest from which to
share the key.</p>
<p>
The <strong>dh-cert-file</strong> and <strong>session-file</strong> provides the guest owner&#39;s
Public Diffie-Hillman key defined in SEV spec. The PDH and session
parameters are used for establishing a cryptographic session with
the guest owner to negotiate keys used for attestation. The file
must be encoded in base64.</p>
<p>
The <strong>kernel-hashes</strong> adds the hashes of given kernel/initrd/ cmdline
to a designated guest firmware page for measured Linux boot with
-kernel. The default is off. (Since 6.2)</p>
<p>
e.g to launch a SEV guest</p>
<blockquote>
<pre class="example">
# qemu-system-x86_64 \
    ...... \
    -object sev-guest,id=sev0,cbitpos=47,reduced-phys-bits=1 \
    -machine ...,memory-encryption=sev0 \
    .....
</pre>
</blockquote>
</li>
<li>
<p><strong>*-object</strong> authz-simple,id=id,identity=string* :: Create an
authorization object that will control access to network services.</p>
<p>
The <strong>identity</strong> parameter is identifies the user and its format
depends on the network service that authorization object is
associated with. For authorizing based on TLS x509 certificates, the
identity must be the x509 distinguished name. Note that care must be
taken to escape any commas in the distinguished name.</p>
<p>
An example authorization object to validate a x509 distinguished
name would look like:</p>
<blockquote>
<pre class="example">
# qemu-system-x86_64 \
    ... \
    -object &#39;authz-simple,id=auth0,identity=CN=laptop.example.com,,O=Example Org,,L=London,,ST=London,,C=GB&#39; \
    ...
</pre>
</blockquote>
</li>
</ul>
<p>Note the use of quotes due to the x509 distinguished name containing
whitespace, and escaping of &#39;,&#39;.</p>
<ul>
<li>
<p><strong>*-object</strong>
authz-listfile,id=id,filename=path,refresh=on|off* :: Create an
authorization object that will control access to network services.</p>
<p>
The <strong>filename</strong> parameter is the fully qualified path to a file
containing the access control list rules in JSON format.</p>
<p>
An example set of rules that match against SASL usernames might look
like:</p>
<blockquote>
<pre class="example">
{
  &#34;rules&#34;: [
     { &#34;match&#34;: &#34;fred&#34;, &#34;policy&#34;: &#34;allow&#34;, &#34;format&#34;: &#34;exact&#34; },
     { &#34;match&#34;: &#34;bob&#34;, &#34;policy&#34;: &#34;allow&#34;, &#34;format&#34;: &#34;exact&#34; },
     { &#34;match&#34;: &#34;danb&#34;, &#34;policy&#34;: &#34;deny&#34;, &#34;format&#34;: &#34;glob&#34; },
     { &#34;match&#34;: &#34;dan*&#34;, &#34;policy&#34;: &#34;allow&#34;, &#34;format&#34;: &#34;exact&#34; },
  ],
  &#34;policy&#34;: &#34;deny&#34;
}
</pre>
</blockquote>
</li>
</ul>
<p>When checking access the object will iterate over all the rules and
the first rule to match will have its <strong>policy</strong> value returned as the
result. If no rules match, then the default <strong>policy</strong> value is
returned.</p>
<p>
The rules can either be an exact string match, or they can use the
simple UNIX glob pattern matching to allow wildcards to be used.</p>
<p>
If <strong>refresh</strong> is set to true the file will be monitored and
automatically reloaded whenever its content changes.</p>
<p>
As with the <strong>authz-simple</strong> object, the format of the identity strings
being matched depends on the network service, but is usually a TLS
x509 distinguished name, or a SASL username.</p>
<p>
An example authorization object to validate a SASL username would look
like:</p>
<blockquote>
<blockquote>
<pre class="example">
# qemu-system-x86_64 \
    ... \
    -object authz-simple,id=auth0,filename=/etc/qemu/vnc-sasl.acl,refresh=on \
    ...
</pre>
</blockquote>
</blockquote>
<dl>
<dt>
<strong>*-object</strong> authz-pam,id=id,service=string*
</dt>
<dd>
<p>Create an
authorization object that will control access to network services.</p>
<p>
The <strong>service</strong> parameter provides the name of a PAM service to use
for authorization. It requires that a file <strong>/etc/pam.d/service</strong>
exist to provide the configuration for the <strong>account</strong> subsystem.</p>
<p>
An example authorization object to validate a TLS x509 distinguished
name would look like:</p>
<blockquote>
<pre class="example">
# qemu-system-x86_64 \
    ... \
    -object authz-pam,id=auth0,service=qemu-vnc \
    ...
</pre>
</blockquote>
</dd>
</dl>
<p>There would then be a corresponding config file for PAM at
<strong>/etc/pam.d/qemu-vnc</strong> that contains:</p>
<blockquote>
<blockquote>
<pre class="example">
account requisite  pam_listfile.so item=user sense=allow \
           file=/etc/qemu/vnc.allow
</pre>
</blockquote>
</blockquote>
<p>
Finally the <strong>/etc/qemu/vnc.allow</strong> file would contain the list of x509
distinguished names that are permitted access</p>
<blockquote>
<blockquote>
<pre class="example">
CN=laptop.example.com,O=Example Home,L=London,ST=London,C=GB
</pre>
</blockquote>
</blockquote>
<ul>
<li>
<p><strong>*-object</strong>
iothread,id=id,poll-max-ns=poll-max-ns,poll-grow=poll-grow,poll-shrink=poll-shrink,aio-max-batch=aio-max-batch* :: Creates
a dedicated event loop thread that devices can be assigned to. This
is known as an IOThread. By default device emulation happens in vCPU
threads or the main event loop thread. This can become a scalability
bottleneck. IOThreads allow device emulation and I/O to run on other
host CPUs.</p>
<p>
The <strong>id</strong> parameter is a unique ID that will be used to reference
this IOThread from <strong>-device …,iothread=id</strong>. Multiple devices can
be assigned to an IOThread. Note that not all devices support an
<strong>iothread</strong> parameter.</p>
<p>
The <strong>query-iothreads</strong> QMP command lists IOThreads and reports their
thread IDs so that the user can configure host CPU pinning/affinity.</p>
<p>
IOThreads use an adaptive polling algorithm to reduce event loop
latency. Instead of entering a blocking system call to monitor file
descriptors and then pay the cost of being woken up when an event
occurs, the polling algorithm spins waiting for events for a short
time. The algorithm&#39;s default parameters are suitable for many cases
but can be adjusted based on knowledge of the workload and/or host
device latency.</p>
<p>
The <strong>poll-max-ns</strong> parameter is the maximum number of nanoseconds to
busy wait for events. Polling can be disabled by setting this value
to 0.</p>
<p>
The <strong>poll-grow</strong> parameter is the multiplier used to increase the
polling time when the algorithm detects it is missing events due to
not polling long enough.</p>
<p>
The <strong>poll-shrink</strong> parameter is the divisor used to decrease the
polling time when the algorithm detects it is spending too long
polling without encountering events.</p>
<p>
The <strong>aio-max-batch</strong> parameter is the maximum number of requests in a
batch for the AIO engine, 0 means that the engine will use its
default.</p>
<p>
The IOThread parameters can be modified at run-time using the
<strong>qom-set</strong> command (where <strong>iothread1</strong> is the IOThread&#39;s <strong>id</strong>):</p>
<blockquote>
<pre class="example">
(qemu) qom-set /objects/iothread1 poll-max-ns 100000
</pre>
</blockquote>
</li>
</ul>
</dd>
</dl>
</blockquote>
<p>
During the graphical emulation, you can use special key combinations
from the following table to change modes. By default the modifier is
Ctrl-Alt (used in the table below) which can be changed with <strong>-display</strong>
suboption <strong>mod=</strong> where appropriate. For example, <strong>-display sdl,</strong>
grab-mod=lshift-lctrl-lalt changes the modifier key to Ctrl-Alt-Shift,
while <strong>-display sdl,grab-mod=rctrl</strong> changes it to the right Ctrl key.</p>
<blockquote>
<dl>
<dt>
<strong>Ctrl-Alt-f</strong>
</dt>
<dd>Toggle full screen</dd>
<dt>
<strong>Ctrl-Alt-+</strong>
</dt>
<dd>Enlarge the screen</dd>
<dt>
<strong>Ctrl-Alt–</strong>
</dt>
<dd>Shrink the screen</dd>
<dt>
<strong>Ctrl-Alt-u</strong>
</dt>
<dd>Restore the screen&#39;s un-scaled dimensions</dd>
<dt>
<strong>Ctrl-Alt-n</strong>
</dt>
<dd>
<p>Switch to virtual console &#39;n&#39;. Standard console
mappings are:</p>
<dl>
<dt>
<strong><em>1</em></strong>
</dt>
<dd>Target system display</dd>
<dt>
<strong><em>2</em></strong>
</dt>
<dd>Monitor</dd>
<dt>
<strong><em>3</em></strong>
</dt>
<dd>Serial port</dd>
</dl>
</dd>
<dt>
<strong>Ctrl-Alt-g</strong>
</dt>
<dd>Toggle mouse and keyboard grab.</dd>
</dl>
</blockquote>
<p>
In the virtual consoles, you can use Ctrl-Up, Ctrl-Down, Ctrl-PageUp and
Ctrl-PageDown to move in the back log.</p>
<p>
During emulation, if you are using a character backend multiplexer
(which is the default if you are using <strong>-nographic</strong>) then several
commands are available via an escape sequence. These key sequences all
start with an escape character, which is Ctrl-a by default, but can be
changed with <strong>-echr</strong>. The list below assumes you&#39;re using the default.</p>
<blockquote>
<dl>
<dt>
<strong>Ctrl-a h</strong>
</dt>
<dd>Print this help</dd>
<dt>
<strong>Ctrl-a x</strong>
</dt>
<dd>Exit emulator</dd>
<dt>
<strong>Ctrl-a s</strong>
</dt>
<dd>Save disk data back to file (if -snapshot)</dd>
<dt>
<strong>Ctrl-a t</strong>
</dt>
<dd>Toggle console timestamps</dd>
<dt>
<strong>Ctrl-a b</strong>
</dt>
<dd>Send break (magic sysrq in Linux)</dd>
<dt>
<strong>Ctrl-a c</strong>
</dt>
<dd>Rotate between the frontends connected to the
multiplexer (usually this switches between the monitor and the
console)</dd>
<dt>
<strong>Ctrl-a Ctrl-a</strong>
</dt>
<dd>Send the escape character to the frontend</dd>
</dl>
</blockquote>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-17" class="outline-2">
<h2 id="headline-17">
NOTES
</h2>
<div id="outline-text-headline-17" class="outline-text-2">
<p>In addition to using normal file images for the emulated storage
devices, QEMU can also use networked resources such as iSCSI devices.
These are specified using a special URL syntax.</p>
<blockquote>
<dl>
<dt>
<strong><strong>iSCSI</strong></strong>
</dt>
<dd>
<p>iSCSI support allows QEMU to access iSCSI resources
directly and use as images for the guest storage. Both disk and cdrom
images are supported.</p>
<p>
Syntax for specifying iSCSI LUNs is
&#34;iscsi://&lt;target-ip&gt;[:&lt;port&gt;]/&lt;target-iqn&gt;/&lt;lun&gt;&#34;</p>
<p>
By default qemu will use the iSCSI initiator-name
&#39;iqn.2008-11.org.linux-kvm[:&lt;name&gt;]&#39; but this can also be set from the
command line or a configuration file.</p>
<p>
Since version QEMU 2.4 it is possible to specify a iSCSI request
timeout to detect stalled requests and force a reestablishment of the
session. The timeout is specified in seconds. The default is 0 which
means no timeout. Libiscsi 1.15.0 or greater is required for this
feature.</p>
<p>
Example (without authentication):</p>
<blockquote>
<pre class="example">
qemu-system-x86_64 -iscsi initiator-name=iqn.2001-04.com.example:my-initiator \
                 -cdrom iscsi://192.0.2.1/iqn.2001-04.com.example/2 \
                 -drive file=iscsi://192.0.2.1/iqn.2001-04.com.example/1
</pre>
</blockquote>
</dd>
</dl>
<p>Example (CHAP username/password via URL):</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 -drive file=iscsi://user%password@192.0.2.1/iqn.2001-04.com.example/1
</pre>
</blockquote>
</blockquote>
<p>
Example (CHAP username/password via environment variables):</p>
<blockquote>
<blockquote>
<pre class="example">
LIBISCSI_CHAP_USERNAME=&#34;user&#34; \
LIBISCSI_CHAP_PASSWORD=&#34;password&#34; \
qemu-system-x86_64 -drive file=iscsi://192.0.2.1/iqn.2001-04.com.example/1
</pre>
</blockquote>
</blockquote>
<dl>
<dt>
<strong><strong>NBD</strong></strong>
</dt>
<dd>
<p>QEMU supports NBD (Network Block Devices) both using TCP
protocol as well as Unix Domain Sockets. With TCP, the default port
is 10809.</p>
<p>
Syntax for specifying a NBD device using TCP, in preferred URI form:
&#34;nbd://&lt;server-ip&gt;[:&lt;port&gt;]/[&lt;export&gt;]&#34;</p>
<p>
Syntax for specifying a NBD device using Unix Domain Sockets; remember
that &#39;?&#39; is a shell glob character and may need quoting:
&#34;nbd+unix:///[&lt;export&gt;]?socket=&lt;domain-socket&gt;&#34;</p>
<p>
Older syntax that is also recognized:
&#34;nbd:&lt;server-ip&gt;:&lt;port&gt;[:exportname=&lt;export&gt;]&#34;</p>
<p>
Syntax for specifying a NBD device using Unix Domain Sockets
&#34;nbd:unix:&lt;domain-socket&gt;[:exportname=&lt;export&gt;]&#34;</p>
<p>
Example for TCP</p>
<blockquote>
<pre class="example">
qemu-system-x86_64 --drive file=nbd:192.0.2.1:30000
</pre>
</blockquote>
</dd>
</dl>
<p>Example for Unix Domain Sockets</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 --drive file=nbd:unix:/tmp/nbd-socket
</pre>
</blockquote>
</blockquote>
<dl>
<dt>
<strong><strong>SSH</strong></strong>
</dt>
<dd>
<p>QEMU supports SSH (Secure Shell) access to remote disks.</p>
<p>
Examples:</p>
<blockquote>
<pre class="example">
qemu-system-x86_64 -drive file=ssh://user@host/path/to/disk.img
qemu-system-x86_64 -drive file.driver=ssh,file.user=user,file.host=host,file.port=22,file.path=/path/to/disk.img
</pre>
</blockquote>
</dd>
</dl>
<p>Currently authentication must be done using ssh-agent. Other
authentication methods may be supported in future.</p>
<dl>
<dt>
<strong><strong>GlusterFS</strong></strong>
</dt>
<dd>
<p>GlusterFS is a user space distributed file system.
QEMU supports the use of GlusterFS volumes for hosting VM disk images
using TCP and Unix Domain Sockets transport protocols.</p>
<p>
Syntax for specifying a VM disk image on GlusterFS volume is</p>
<blockquote>
<pre class="example">
URI:
gluster[+type]://[host[:port]]/volume/path[?socket=...][,debug=N][,logfile=...]

JSON:
&#39;json:{&#34;driver&#34;:&#34;qcow2&#34;,&#34;file&#34;:{&#34;driver&#34;:&#34;gluster&#34;,&#34;volume&#34;:&#34;testvol&#34;,&#34;path&#34;:&#34;a.img&#34;,&#34;debug&#34;:N,&#34;logfile&#34;:&#34;...&#34;,
                                 &#34;server&#34;:[{&#34;type&#34;:&#34;tcp&#34;,&#34;host&#34;:&#34;...&#34;,&#34;port&#34;:&#34;...&#34;},
                                           {&#34;type&#34;:&#34;unix&#34;,&#34;socket&#34;:&#34;...&#34;}]}}&#39;
</pre>
</blockquote>
</dd>
</dl>
<p>Example</p>
<blockquote>
<blockquote>
<pre class="example">
URI:
qemu-system-x86_64 --drive file=gluster://192.0.2.1/testvol/a.img,
                               file.debug=9,file.logfile=/var/log/qemu-gluster.log

JSON:
qemu-system-x86_64 &#39;json:{&#34;driver&#34;:&#34;qcow2&#34;,
                          &#34;file&#34;:{&#34;driver&#34;:&#34;gluster&#34;,
                                   &#34;volume&#34;:&#34;testvol&#34;,&#34;path&#34;:&#34;a.img&#34;,
                                   &#34;debug&#34;:9,&#34;logfile&#34;:&#34;/var/log/qemu-gluster.log&#34;,
                                   &#34;server&#34;:[{&#34;type&#34;:&#34;tcp&#34;,&#34;host&#34;:&#34;1.2.3.4&#34;,&#34;port&#34;:24007},
                                             {&#34;type&#34;:&#34;unix&#34;,&#34;socket&#34;:&#34;/var/run/glusterd.socket&#34;}]}}&#39;
qemu-system-x86_64 -drive driver=qcow2,file.driver=gluster,file.volume=testvol,file.path=/path/a.img,
                                      file.debug=9,file.logfile=/var/log/qemu-gluster.log,
                                      file.server.0.type=tcp,file.server.0.host=1.2.3.4,file.server.0.port=24007,
                                      file.server.1.type=unix,file.server.1.socket=/var/run/glusterd.socket
</pre>
</blockquote>
</blockquote>
<p>
See also <em><a href="http://www.gluster.org">http://www.gluster.org</a></em>.</p>
<dl>
<dt>
<strong><strong>HTTP/HTTPS/FTP/FTPS</strong></strong>
</dt>
<dd>
<p>QEMU supports read-only access to files
accessed over http(s) and ftp(s).</p>
<p>
Syntax using a single filename:</p>
<blockquote>
<pre class="example">
&lt;protocol&gt;://[&lt;username&gt;[:&lt;password&gt;]@]&lt;host&gt;/&lt;path&gt;
</pre>
</blockquote>
</dd>
</dl>
<p>where:</p>
<blockquote>
<dl>
<dt>
<strong><strong>protocol</strong></strong>
</dt>
<dd>&#39;http&#39;, &#39;https&#39;, &#39;ftp&#39;, or &#39;ftps&#39;.</dd>
<dt>
<strong><strong>username</strong></strong>
</dt>
<dd>Optional username for authentication to the remote
server.</dd>
<dt>
<strong><strong>password</strong></strong>
</dt>
<dd>Optional password for authentication to the remote
server.</dd>
<dt>
<strong><strong>host</strong></strong>
</dt>
<dd>Address of the remote server.</dd>
<dt>
<strong><strong>path</strong></strong>
</dt>
<dd>Path on the remote server, including any query string.</dd>
</dl>
</blockquote>
<p>
The following options are also supported:</p>
<blockquote>
<dl>
<dt>
<strong><strong>url</strong></strong>
</dt>
<dd>The full URL when passing options to the driver explicitly.</dd>
<dt>
<strong><strong>readahead</strong></strong>
</dt>
<dd>The amount of data to read ahead with each range
request to the remote server. This value may optionally have the
suffix &#39;T&#39;, &#39;G&#39;, &#39;M&#39;, &#39;K&#39;, &#39;k&#39; or &#39;b&#39;. If it does not have a suffix,
it will be assumed to be in bytes. The value must be a multiple of 512
bytes. It defaults to 256k.</dd>
<dt>
<strong><strong>sslverify</strong></strong>
</dt>
<dd>Whether to verify the remote server&#39;s certificate
when connecting over SSL. It can have the value &#39;on&#39; or &#39;off&#39;. It
defaults to &#39;on&#39;.</dd>
<dt>
<strong><strong>cookie</strong></strong>
</dt>
<dd>Send this cookie (it can also be a list of cookies
separated by &#39;;&#39;) with each outgoing request. Only supported when
using protocols such as HTTP which support cookies, otherwise ignored.</dd>
<dt>
<strong><strong>timeout</strong></strong>
</dt>
<dd>Set the timeout in seconds of the CURL connection. This
timeout is the time that CURL waits for a response from the remote
server to get the size of the image to be downloaded. If not set, the
default timeout of 5 seconds is used.</dd>
</dl>
</blockquote>
<p>
Note that when passing options to qemu explicitly, <strong>driver</strong> is the value
of &lt;protocol&gt;.</p>
<p>
Example: boot from a remote Fedora 20 live ISO image</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-system-x86_64 --drive media=cdrom,file=https://archives.fedoraproject.org/pub/archive/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso,readonly

qemu-system-x86_64 --drive media=cdrom,file.driver=http,file.url=http://archives.fedoraproject.org/pub/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso,readonly
</pre>
</blockquote>
</blockquote>
<p>
Example: boot from a remote Fedora 20 cloud image using a local overlay
for writes, copy-on-read, and a readahead of 64k</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-img create -f qcow2 -o backing_file=&#39;json:{&#34;file.driver&#34;:&#34;http&#34;,, &#34;file.url&#34;:&#34;http://archives.fedoraproject.org/pub/archive/fedora/linux/releases/20/Images/x86_64/Fedora-x86_64-20-20131211.1-sda.qcow2&#34;,, &#34;file.readahead&#34;:&#34;64k&#34;}&#39; /tmp/Fedora-x86_64-20-20131211.1-sda.qcow2

qemu-system-x86_64 -drive file=/tmp/Fedora-x86_64-20-20131211.1-sda.qcow2,copy-on-read=on
</pre>
</blockquote>
</blockquote>
<p>
Example: boot from an image stored on a VMware vSphere server with a
self-signed certificate using a local overlay for writes, a readahead of
64k and a timeout of 10 seconds.</p>
<blockquote>
<blockquote>
<pre class="example">
qemu-img create -f qcow2 -o backing_file=&#39;json:{&#34;file.driver&#34;:&#34;https&#34;,, &#34;file.url&#34;:&#34;https://user:password@vsphere.example.com/folder/test/test-flat.vmdk?dcPath=Datacenter&amp;dsName=datastore1&#34;,, &#34;file.sslverify&#34;:&#34;off&#34;,, &#34;file.readahead&#34;:&#34;64k&#34;,, &#34;file.timeout&#34;:10}&#39; /tmp/test.qcow2

qemu-system-x86_64 -drive file=/tmp/test.qcow2
</pre>
</blockquote>
</blockquote>
</blockquote>
</div>
</div>
<div id="outline-container-headline-18" class="outline-2">
<h2 id="headline-18">
SEE ALSO
</h2>
<div id="outline-text-headline-18" class="outline-text-2">
<p>The HTML documentation of QEMU for more precise information and Linux
user mode emulator invocation.</p>
</div>
</div>
<div id="outline-container-headline-19" class="outline-2">
<h2 id="headline-19">
AUTHOR
</h2>
<div id="outline-text-headline-19" class="outline-text-2">
<p>Fabrice Bellard</p>
</div>
</div>
<div id="outline-container-headline-20" class="outline-2">
<h2 id="headline-20">
COPYRIGHT
</h2>
<div id="outline-text-headline-20" class="outline-text-2">
<p>2024, The QEMU Project Developers</p>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.95916b5b8c09add4922ea47e674b5da7fc4b6347a3e8c4e25e98b4b7d236080b.js" integrity="sha256-lZFrW4wJrdSSLqR&#43;Z0tdp/xLY0ej6MTiXpi0t9I2CAs=" crossorigin="anonymous"></script>
    </body>
</html>
