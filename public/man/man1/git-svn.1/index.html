<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - git-svn.1 | Technical Notes</title>

    <link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - git-svn.1</h1>
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
NAME
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>git-svn - Bidirectional operation between a Subversion repository and
Git</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
SYNOPSIS
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<pre class="example">
git svn &lt;command&gt; [&lt;options&gt;] [&lt;arguments&gt;]
</pre>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
DESCRIPTION
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p><em>git svn</em> is a simple conduit for changesets between Subversion and Git.
It provides a bidirectional flow of changes between a Subversion and a
Git repository.</p>
<p>
<em>git svn</em> can track a standard Subversion repository, following the
common &#34;trunk/branches/tags&#34; layout, with the –stdlayout option. It can
also follow branches and tags in any layout with the -T/-t/-b options
(see options to <em>init</em> below, and also the <em>clone</em> command).</p>
<p>
Once tracking a Subversion repository (with any of the above methods),
the Git repository can be updated from Subversion by the <em>fetch</em> command
and Subversion updated from Git by the <em>dcommit</em> command.</p>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
COMMANDS
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<p><em>init</em></p>
<blockquote>
<p>Initializes an empty Git repository with additional metadata directories
for <em>git svn</em>. The Subversion URL may be specified as a command-line
argument, or as full URL arguments to -T/-t/-b. Optionally, the target
directory to operate on can be specified as a second argument. Normally
this command initializes the current directory.</p>
<p>
-T&lt;trunk-subdir&gt;, –trunk=&lt;trunk-subdir&gt;, -t&lt;tags-subdir&gt;,
–tags=&lt;tags-subdir&gt;, -b&lt;branches-subdir&gt;, –branches=&lt;branches-subdir&gt;,
-s, –stdlayout</p>
<blockquote>
<p>These are optional command-line options for init. Each of these flags
can point to a relative repository path (–tags=project/tags) or a full
url (–tags=<a href="https://foo.org/project/tags).">https://foo.org/project/tags).</a> You can specify more than one
–tags and/or –branches options, in case your Subversion repository
places tags or branches under multiple paths. The option –stdlayout is
a shorthand way of setting trunk,tags,branches as the relative paths,
which is the Subversion default. If any of the other options are given
as well, they take precedence.</p>
</blockquote>
<p>
–no-metadata</p>
<blockquote>
<p>Set the <em>noMetadata</em> option in the [svn-remote] config. This option is
not recommended, please read the <em>svn.noMetadata</em> section of this
manpage before using this option.</p>
</blockquote>
<p>
–use-svm-props</p>
<blockquote>
<p>Set the <em>useSvmProps</em> option in the [svn-remote] config.</p>
</blockquote>
<p>
–use-svnsync-props</p>
<blockquote>
<p>Set the <em>useSvnsyncProps</em> option in the [svn-remote] config.</p>
</blockquote>
<p>
–rewrite-root=&lt;URL&gt;</p>
<blockquote>
<p>Set the <em>rewriteRoot</em> option in the [svn-remote] config.</p>
</blockquote>
<p>
–rewrite-uuid=&lt;UUID&gt;</p>
<blockquote>
<p>Set the <em>rewriteUUID</em> option in the [svn-remote] config.</p>
</blockquote>
<p>
–username=&lt;user&gt;</p>
<blockquote>
<p>For transports that SVN handles authentication for (http, https, and
plain svn), specify the username. For other transports (e.g.
<strong>svn+ssh://</strong>), you must include the username in the URL, e.g.
<strong>svn+ssh://foo@svn.bar.com/project</strong></p>
</blockquote>
<p>
–prefix=&lt;prefix&gt;</p>
<blockquote>
<p>This allows one to specify a prefix which is prepended to the names of
remotes if trunk/branches/tags are specified. The prefix does not
automatically include a trailing slash, so be sure you include one in
the argument if that is what you want. If –branches/-b is specified,
the prefix must include a trailing slash. Setting a prefix (with a
trailing slash) is strongly encouraged in any case, as your SVN-tracking
refs will then be located at &#34;refs/remotes/$prefix/*&#34;, which is
compatible with Git&#39;s own remote-tracking ref layout
(refs/remotes/$remote/*). Setting a prefix is also useful if you wish to
track multiple projects that share a common repository. By default, the
prefix is set to <em>origin/</em>.</p>
<blockquote>
<p>\\</p>
<p>
<strong>Note</strong></p>
<p>
\\
Before Git v2.0, the default prefix was &#34;&#34; (no prefix). This meant that
SVN-tracking refs were put at &#34;refs/remotes/*&#34;, which is incompatible
with how Git&#39;s own remote-tracking refs are organized. If you still want
the old default, you can get it by passing <strong>–prefix &#34;&#34;</strong> on the command
line (<strong>–prefix=&#34;&#34;</strong> may not work if your Perl&#39;s Getopt::Long is &lt;
v2.37).</p>
</blockquote>
</blockquote>
<p>
–ignore-refs=&lt;regex&gt;</p>
<blockquote>
<p>When passed to <em>init</em> or <em>clone</em> this regular expression will be
preserved as a config key. See <em>fetch</em> for a description of
<strong>–ignore-refs</strong>.</p>
</blockquote>
<p>
–ignore-paths=&lt;regex&gt;</p>
<blockquote>
<p>When passed to <em>init</em> or <em>clone</em> this regular expression will be
preserved as a config key. See <em>fetch</em> for a description of
<strong>–ignore-paths</strong>.</p>
</blockquote>
<p>
–include-paths=&lt;regex&gt;</p>
<blockquote>
<p>When passed to <em>init</em> or <em>clone</em> this regular expression will be
preserved as a config key. See <em>fetch</em> for a description of
<strong>–include-paths</strong>.</p>
</blockquote>
<p>
–no-minimize-url</p>
<blockquote>
<p>When tracking multiple directories (using –stdlayout, –branches, or
–tags options), git svn will attempt to connect to the root (or highest
allowed level) of the Subversion repository. This default allows better
tracking of history if entire projects are moved within a repository,
but may cause issues on repositories where read access restrictions are
in place. Passing <strong>–no-minimize-url</strong> will allow git svn to accept URLs
as-is without attempting to connect to a higher level directory. This
option is off by default when only one URL/branch is tracked (it would
do little good).</p>
</blockquote>
</blockquote>
<p>
<em>fetch</em></p>
<blockquote>
<p>Fetch unfetched revisions from the Subversion remote we are tracking.
The name of the [svn-remote &#34;…&#34;] section in the $GIT_DIR/config file
may be specified as an optional command-line argument.</p>
<p>
This automatically updates the rev_map if needed (see
<em>$GIT_DIR/svn/**</em>.rev_map.*/ in the FILES section below for details).</p>
<p>
–localtime</p>
<blockquote>
<p>Store Git commit times in the local time zone instead of UTC. This makes
<em>git log</em> (even without –date=local) show the same times that <strong>svn log</strong>
would in the local time zone.</p>
<p>
This doesn&#39;t interfere with interoperating with the Subversion
repository you cloned from, but if you wish for your local Git
repository to be able to interoperate with someone else&#39;s local Git
repository, either don&#39;t use this option or you should both use it in
the same local time zone.</p>
</blockquote>
<p>
–parent</p>
<blockquote>
<p>Fetch only from the SVN parent of the current HEAD.</p>
</blockquote>
<p>
–ignore-refs=&lt;regex&gt;</p>
<blockquote>
<p>Ignore refs for branches or tags matching the Perl regular expression. A
&#34;negative look-ahead assertion&#34; like
<strong>^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$</strong> can be used
to allow only certain refs.</p>
<blockquote>
<pre class="example">
config key: svn-remote.&lt;name&gt;.ignore-refs
</pre>
</blockquote>
<p>
If the ignore-refs configuration key is set, and the command-line option
is also given, both regular expressions will be used.</p>
</blockquote>
<p>
–ignore-paths=&lt;regex&gt;</p>
<blockquote>
<p>This allows one to specify a Perl regular expression that will cause
skipping of all matching paths from checkout from SVN. The
<strong>–ignore-paths</strong> option should match for every <em>fetch</em> (including
automatic fetches due to <em>clone</em>, <em>dcommit</em>, <em>rebase</em>, etc) on a given
repository.</p>
<blockquote>
<pre class="example">
config key: svn-remote.&lt;name&gt;.ignore-paths
</pre>
</blockquote>
<p>
If the ignore-paths configuration key is set, and the command-line
option is also given, both regular expressions will be used.</p>
<p>
Examples:</p>
<p>
Skip &#34;doc*&#34; directory for every fetch</p>
<blockquote>
<blockquote>
<pre class="example">
--ignore-paths=&#34;^doc&#34;
</pre>
</blockquote>
</blockquote>
<p>
Skip &#34;branches&#34; and &#34;tags&#34; of first level directories</p>
<blockquote>
<blockquote>
<pre class="example">
--ignore-paths=&#34;^[^/]+/(?:branches|tags)&#34;
</pre>
</blockquote>
</blockquote>
</blockquote>
<p>
–include-paths=&lt;regex&gt;</p>
<blockquote>
<p>This allows one to specify a Perl regular expression that will cause the
inclusion of only matching paths from checkout from SVN. The
<strong>–include-paths</strong> option should match for every <em>fetch</em> (including
automatic fetches due to <em>clone</em>, <em>dcommit</em>, <em>rebase</em>, etc) on a given
repository. <strong>–ignore-paths</strong> takes precedence over <strong>–include-paths</strong>.</p>
<blockquote>
<pre class="example">
config key: svn-remote.&lt;name&gt;.include-paths
</pre>
</blockquote>
</blockquote>
<p>
–log-window-size=&lt;n&gt;</p>
<blockquote>
<p>Fetch &lt;n&gt; log entries per request when scanning Subversion history. The
default is 100. For very large Subversion repositories, larger values
may be needed for <em>clone///fetch</em> to complete in reasonable time. But
overly large values may lead to higher memory usage and request
timeouts.</p>
</blockquote>
</blockquote>
<p>
<em>clone</em></p>
<blockquote>
<p>Runs <em>init</em> and <em>fetch</em>. It will automatically create a directory based
on the basename of the URL passed to it; or if a second argument is
passed; it will create a directory and work within that. It accepts all
arguments that the <em>init</em> and <em>fetch</em> commands accept; with the
exception of <strong>–fetch-all</strong> and <strong>–parent</strong>. After a repository is cloned,
the <em>fetch</em> command will be able to update revisions without affecting
the working tree; and the <em>rebase</em> command will be able to update the
working tree with the latest changes.</p>
<p>
–preserve-empty-dirs</p>
<blockquote>
<p>Create a placeholder file in the local Git repository for each empty
directory fetched from Subversion. This includes directories that become
empty by removing all entries in the Subversion repository (but not the
directory itself). The placeholder files are also tracked and removed
when no longer necessary.</p>
</blockquote>
<p>
–placeholder-filename=&lt;filename&gt;</p>
<blockquote>
<p>Set the name of placeholder files created by –preserve-empty-dirs.
Default: &#34;.gitignore&#34;</p>
</blockquote>
</blockquote>
<p>
<em>rebase</em></p>
<blockquote>
<p>This fetches revisions from the SVN parent of the current HEAD and
rebases the current (uncommitted to SVN) work against it.</p>
<p>
This works similarly to <strong>svn update</strong> or <em>git pull</em> except that it
preserves linear history with <em>git rebase</em> instead of <em>git merge</em> for
ease of dcommitting with <em>git svn</em>.</p>
<p>
This accepts all options that <em>git svn fetch</em> and <em>git rebase</em> accept.
However, <strong>–fetch-all</strong> only fetches from the current [svn-remote], and
not all [svn-remote] definitions.</p>
<p>
Like <em>git rebase</em>; this requires that the working tree be clean and have
no uncommitted changes.</p>
<p>
This automatically updates the rev_map if needed (see
<em>$GIT_DIR/svn/**</em>.rev_map.*/ in the FILES section below for details).</p>
<p>
-l, –local</p>
<blockquote>
<p>Do not fetch remotely; only run <em>git rebase</em> against the last fetched
commit from the upstream SVN.</p>
</blockquote>
</blockquote>
<p>
<em>dcommit</em></p>
<blockquote>
<p>Commit each diff from the current branch directly to the SVN repository,
and then rebase or reset (depending on whether or not there is a diff
between SVN and head). This will create a revision in SVN for each
commit in Git.</p>
<p>
When an optional Git branch name (or a Git commit object name) is
specified as an argument, the subcommand works on the specified branch,
not on the current branch.</p>
<p>
Use of <em>dcommit</em> is preferred to <em>set-tree</em> (below).</p>
<p>
–no-rebase</p>
<blockquote>
<p>After committing, do not rebase or reset.</p>
</blockquote>
<p>
–commit-url &lt;URL&gt;</p>
<blockquote>
<p>Commit to this SVN URL (the full path). This is intended to allow
existing <em>git svn</em> repositories created with one transport method (e.g.
<strong>svn://</strong> or <strong>http://</strong> for anonymous read) to be reused if a user is
later given access to an alternate transport method (e.g. <strong>svn+ssh://</strong>
or <strong>https://</strong>) for commit.</p>
<blockquote>
<pre class="example">
config key: svn-remote.&lt;name&gt;.commiturl
config key: svn.commiturl (overwrites all svn-remote.&lt;name&gt;.commiturl options)
</pre>
</blockquote>
<p>
Note that the SVN URL of the commiturl config key includes the SVN
branch. If you rather want to set the commit URL for an entire SVN
repository use svn-remote.&lt;name&gt;.pushurl instead.</p>
<p>
Using this option for any other purpose (don&#39;t ask) is very strongly
discouraged.</p>
</blockquote>
<p>
–mergeinfo=&lt;mergeinfo&gt;</p>
<blockquote>
<p>Add the given merge information during the dcommit (e.g.
<strong>–mergeinfo=&#34;/branches/foo:1-10&#34;</strong>). All svn server versions can store
this information (as a property), and svn clients starting from version
1.5 can make use of it. To specify merge information from multiple
branches, use a single space character between the branches
(<strong>–mergeinfo=&#34;/branches/foo:1-10 /branches/bar:3,5-6,8&#34;</strong>)</p>
<blockquote>
<pre class="example">
config key: svn.pushmergeinfo
</pre>
</blockquote>
<p>
This option will cause git-svn to attempt to automatically populate the
svn:mergeinfo property in the SVN repository when possible. Currently,
this can only be done when dcommitting non-fast-forward merges where all
parents but the first have already been pushed into SVN.</p>
</blockquote>
<p>
–interactive</p>
<blockquote>
<p>Ask the user to confirm that a patch set should actually be sent to SVN.
For each patch, one may answer &#34;yes&#34; (accept this patch), &#34;no&#34; (discard
this patch), &#34;all&#34; (accept all patches), or &#34;quit&#34;.</p>
<p>
<em>git svn dcommit</em> returns immediately if answer is &#34;no&#34; or &#34;quit&#34;,
without committing anything to SVN.</p>
</blockquote>
</blockquote>
<p>
<em>branch</em></p>
<blockquote>
<p>Create a branch in the SVN repository.</p>
<p>
-m, –message</p>
<blockquote>
<p>Allows to specify the commit message.</p>
</blockquote>
<p>
-t, –tag</p>
<blockquote>
<p>Create a tag by using the tags_subdir instead of the branches_subdir
specified during git svn init.</p>
</blockquote>
<p>
-d&lt;path&gt;, –destination=&lt;path&gt;</p>
<blockquote>
<p>If more than one –branches (or –tags) option was given to the <em>init</em>
or <em>clone</em> command, you must provide the location of the branch (or tag)
you wish to create in the SVN repository. &lt;path&gt; specifies which path to
use to create the branch or tag and should match the pattern on the
left-hand side of one of the configured branches or tags refspecs. You
can see these refspecs with the commands</p>
<blockquote>
<pre class="example">
git config --get-all svn-remote.&lt;name&gt;.branches
git config --get-all svn-remote.&lt;name&gt;.tags
</pre>
</blockquote>
<p>
where &lt;name&gt; is the name of the SVN repository as specified by the -R
option to <em>init</em> (or &#34;svn&#34; by default).</p>
</blockquote>
<p>
–username</p>
<blockquote>
<p>Specify the SVN username to perform the commit as. This option overrides
the <em>username</em> configuration property.</p>
</blockquote>
<p>
–commit-url</p>
<blockquote>
<p>Use the specified URL to connect to the destination Subversion
repository. This is useful in cases where the source SVN repository is
read-only. This option overrides configuration property <em>commiturl</em>.</p>
<blockquote>
<pre class="example">
git config --get-all svn-remote.&lt;name&gt;.commiturl
</pre>
</blockquote>
</blockquote>
<p>
–parents</p>
<blockquote>
<p>Create parent folders. This parameter is equivalent to the parameter
–parents on svn cp commands and is useful for non-standard repository
layouts.</p>
</blockquote>
</blockquote>
<p>
<em>tag</em></p>
<blockquote>
<p>Create a tag in the SVN repository. This is a shorthand for <em>branch -t</em>.</p>
</blockquote>
<p>
<em>log</em></p>
<blockquote>
<p>This should make it easy to look up svn log messages when svn users
refer to -r/–revision numbers.</p>
<p>
The following features from ‘svn log&#39; are supported:</p>
<p>
-r &lt;n&gt;[:&lt;n&gt;], –revision=&lt;n&gt;[:&lt;n&gt;]</p>
<blockquote>
<p>is supported, non-numeric args are not: HEAD, NEXT, BASE, PREV, etc …</p>
</blockquote>
<p>
-v, –verbose</p>
<blockquote>
<p>it&#39;s not completely compatible with the –verbose output in svn log, but
reasonably close.</p>
</blockquote>
<p>
–limit=&lt;n&gt;</p>
<blockquote>
<p>is NOT the same as –max-count, doesn&#39;t count merged/excluded commits</p>
</blockquote>
<p>
–incremental</p>
<blockquote>
<p>supported</p>
</blockquote>
<p>
New features:</p>
<p>
–show-commit</p>
<blockquote>
<p>shows the Git commit sha1, as well</p>
</blockquote>
<p>
–oneline</p>
<blockquote>
<p>our version of –pretty=oneline</p>
</blockquote>
<blockquote>
<p>\\</p>
<p>
<strong>Note</strong></p>
<p>
\\
SVN itself only stores times in UTC and nothing else. The regular svn
client converts the UTC time to the local time (or based on the TZ=
environment). This command has the same behaviour.</p>
</blockquote>
<p>
Any other arguments are passed directly to <em>git log</em></p>
</blockquote>
<p>
<em>blame</em></p>
<blockquote>
<p>Show what revision and author last modified each line of a file. The
output of this mode is format-compatible with the output of ‘svn blame&#39;
by default. Like the SVN blame command, local uncommitted changes in the
working tree are ignored; the version of the file in the HEAD revision
is annotated. Unknown arguments are passed directly to <em>git blame</em>.</p>
<p>
–git-format</p>
<blockquote>
<p>Produce output in the same format as <em>git blame</em>, but with SVN revision
numbers instead of Git commit hashes. In this mode, changes that haven&#39;t
been committed to SVN (including local working-copy edits) are shown as
revision 0.</p>
</blockquote>
</blockquote>
<p>
<em>find-rev</em></p>
<blockquote>
<p>When given an SVN revision number of the form <em>rN</em>, returns the
corresponding Git commit hash (this can optionally be followed by a
tree-ish to specify which branch should be searched). When given a
tree-ish, returns the corresponding SVN revision number.</p>
<p>
-B, –before</p>
<blockquote>
<p>Don&#39;t require an exact match if given an SVN revision, instead find the
commit corresponding to the state of the SVN repository (on the current
branch) at the specified revision.</p>
</blockquote>
<p>
-A, –after</p>
<blockquote>
<p>Don&#39;t require an exact match if given an SVN revision; if there is not
an exact match return the closest match searching forward in the
history.</p>
</blockquote>
</blockquote>
<p>
<em>set-tree</em></p>
<blockquote>
<p>You should consider using <em>dcommit</em> instead of this command. Commit
specified commit or tree objects to SVN. This relies on your imported
fetch data being up to date. This makes absolutely no attempts to do
patching when committing to SVN, it simply overwrites files with those
specified in the tree or commit. All merging is assumed to have taken
place independently of <em>git svn</em> functions.</p>
</blockquote>
<p>
<em>create-ignore</em></p>
<blockquote>
<p>Recursively finds the svn:ignore property on directories and creates
matching .gitignore files. The resulting files are staged to be
committed, but are not committed. Use -r/–revision to refer to a
specific revision.</p>
</blockquote>
<p>
<em>show-ignore</em></p>
<blockquote>
<p>Recursively finds and lists the svn:ignore property on directories. The
output is suitable for appending to the $GIT_DIR/info/exclude file.</p>
</blockquote>
<p>
<em>mkdirs</em></p>
<blockquote>
<p>Attempts to recreate empty directories that core Git cannot track based
on information in $GIT_DIR/svn/&lt;refname&gt;/unhandled.log files. Empty
directories are automatically recreated when using &#34;git svn clone&#34; and
&#34;git svn rebase&#34;, so &#34;mkdirs&#34; is intended for use after commands like
&#34;git checkout&#34; or &#34;git reset&#34;. (See the svn-remote.&lt;name&gt;.automkdirs
config file option for more information.)</p>
</blockquote>
<p>
<em>commit-diff</em></p>
<blockquote>
<p>Commits the diff of two tree-ish arguments from the command-line. This
command does not rely on being inside a <strong>git svn init</strong>-ed repository.
This command takes three arguments, (a) the original tree to diff
against, (b) the new tree result, (c) the URL of the target Subversion
repository. The final argument (URL) may be omitted if you are working
from a <em>git svn</em>-aware repository (that has been <strong>init</strong>-ed with <em>git
svn</em>). The -r&lt;revision&gt; option is required for this.</p>
<p>
The commit message is supplied either directly with the <strong>-m</strong> or <strong>-F</strong>
option, or indirectly from the tag or commit when the second tree-ish
denotes such an object, or it is requested by invoking an editor (see
<strong>–edit</strong> option below).</p>
<p>
-m &lt;msg&gt;, –message=&lt;msg&gt;</p>
<blockquote>
<p>Use the given <strong>msg</strong> as the commit message. This option disables the
<strong>–edit</strong> option.</p>
</blockquote>
<p>
-F &lt;filename&gt;, –file=&lt;filename&gt;</p>
<blockquote>
<p>Take the commit message from the given file. This option disables the
<strong>–edit</strong> option.</p>
</blockquote>
</blockquote>
<p>
<em>info</em></p>
<blockquote>
<p>Shows information about a file or directory similar to what ‘svn info&#39;
provides. Does not currently support a -r/–revision argument. Use the
–url option to output only the value of the <em>URL:</em> field.</p>
</blockquote>
<p>
<em>proplist</em></p>
<blockquote>
<p>Lists the properties stored in the Subversion repository about a given
file or directory. Use -r/–revision to refer to a specific Subversion
revision.</p>
</blockquote>
<p>
<em>propget</em></p>
<blockquote>
<p>Gets the Subversion property given as the first argument, for a file. A
specific revision can be specified with -r/–revision.</p>
</blockquote>
<p>
<em>propset</em></p>
<blockquote>
<p>Sets the Subversion property given as the first argument, to the value
given as the second argument for the file given as the third argument.</p>
<p>
Example:</p>
<blockquote>
<pre class="example">
git svn propset svn:keywords &#34;FreeBSD=%H&#34; devel/py-tipper/Makefile
</pre>
</blockquote>
<p>
This will set the property <em>svn:keywords</em> to <em>FreeBSD=%H</em> for the file
<em>devel/py-tipper/Makefile</em>.</p>
</blockquote>
<p>
<em>show-externals</em></p>
<blockquote>
<p>Shows the Subversion externals. Use -r/–revision to specify a specific
revision.</p>
</blockquote>
<p>
<em>gc</em></p>
<blockquote>
<p>Compress $GIT_DIR/svn/&lt;refname&gt;/unhandled.log files and remove
$GIT_DIR/svn/&lt;refname&gt;/index files.</p>
</blockquote>
<p>
<em>reset</em></p>
<blockquote>
<p>Undoes the effects of <em>fetch</em> back to the specified revision. This
allows you to re-<em>fetch</em> an SVN revision. Normally the contents of an
SVN revision should never change and <em>reset</em> should not be necessary.
However, if SVN permissions change, or if you alter your –ignore-paths
option, a <em>fetch</em> may fail with &#34;not found in commit&#34; (file not
previously visible) or &#34;checksum mismatch&#34; (missed a modification). If
the problem file cannot be ignored forever (with –ignore-paths) the
only way to repair the repo is to use <em>reset</em>.</p>
<p>
Only the rev_map and refs/remotes/git-svn are changed (see
<em>$GIT_DIR/svn/**</em>.rev_map.*/ in the FILES section below for details).
Follow <em>reset</em> with a <em>fetch</em> and then <em>git reset</em> or <em>git rebase</em> to
move local branches onto the new tree.</p>
<p>
-r &lt;n&gt;, –revision=&lt;n&gt;</p>
<blockquote>
<p>Specify the most recent revision to keep. All later revisions are
discarded.</p>
</blockquote>
<p>
-p, –parent</p>
<blockquote>
<p>Discard the specified revision as well, keeping the nearest parent
instead.</p>
</blockquote>
<p>
Example:</p>
<blockquote>
<p>Assume you have local changes in &#34;master&#34;, but you need to refetch &#34;r2&#34;.</p>
<blockquote>
<pre class="example">
    r1---r2---r3 remotes/git-svn
                \
                 A---B master
</pre>
</blockquote>
<p>
Fix the ignore-paths or SVN permissions problem that caused &#34;r2&#34; to be
incomplete in the first place. Then:</p>
<blockquote>
<pre class="example">
git svn reset -r2 -p
git svn fetch
</pre>
</blockquote>
<blockquote>
<pre class="example">
    r1---r2--r3 remotes/git-svn
      \
       r2---r3---A---B master
</pre>
</blockquote>
<p>
Then fixup &#34;master&#34; with <em>git rebase</em>. Do NOT use <em>git merge</em> or your
history will not be compatible with a future <em>dcommit</em>!</p>
<blockquote>
<pre class="example">
git rebase --onto remotes/git-svn A^ master
</pre>
</blockquote>
<blockquote>
<pre class="example">
    r1---r2--r3 remotes/git-svn
                \
                 A--B master
</pre>
</blockquote>
</blockquote>
</blockquote>
</div>
</div>
<div id="outline-container-headline-5" class="outline-2">
<h2 id="headline-5">
OPTIONS
</h2>
<div id="outline-text-headline-5" class="outline-text-2">
<p>–shared[=(false|true|umask|group|all|world|everybody)],
–template=&lt;template-directory&gt;</p>
<blockquote>
<p>Only used with the <em>init</em> command. These are passed directly to <em>git
init</em>.</p>
</blockquote>
<p>
-r &lt;arg&gt;, –revision &lt;arg&gt;</p>
<blockquote>
<p>Used with the <em>fetch</em> command.</p>
<p>
This allows revision ranges for partial/cauterized history to be
supported. $NUMBER, $NUMBER1:$NUMBER2 (numeric ranges), $NUMBER:HEAD,
and BASE:$NUMBER are all supported.</p>
<p>
This can allow you to make partial mirrors when running fetch; but is
generally not recommended because history will be skipped and lost.</p>
</blockquote>
<p>
-, –stdin</p>
<blockquote>
<p>Only used with the <em>set-tree</em> command.</p>
<p>
Read a list of commits from stdin and commit them in reverse order. Only
the leading sha1 is read from each line, so <em>git rev-list
–pretty=oneline</em> output can be used.</p>
</blockquote>
<p>
–rmdir</p>
<blockquote>
<p>Only used with the <em>dcommit</em>, <em>set-tree</em> and <em>commit-diff</em> commands.</p>
<p>
Remove directories from the SVN tree if there are no files left behind.
SVN can version empty directories, and they are not removed by default
if there are no files left in them. Git cannot version empty
directories. Enabling this flag will make the commit to SVN act like
Git.</p>
<blockquote>
<pre class="example">
config key: svn.rmdir
</pre>
</blockquote>
</blockquote>
<p>
-e, –edit</p>
<blockquote>
<p>Only used with the <em>dcommit</em>, <em>set-tree</em> and <em>commit-diff</em> commands.</p>
<p>
Edit the commit message before committing to SVN. This is off by default
for objects that are commits, and forced on when committing tree
objects.</p>
<blockquote>
<pre class="example">
config key: svn.edit
</pre>
</blockquote>
</blockquote>
<p>
-l&lt;num&gt;, –find-copies-harder</p>
<blockquote>
<p>Only used with the <em>dcommit</em>, <em>set-tree</em> and <em>commit-diff</em> commands.</p>
<p>
They are both passed directly to <em>git diff-tree</em>; see *git-diff-tree*(1)
for more information.</p>
<blockquote>
<pre class="example">
config key: svn.l
config key: svn.findcopiesharder
</pre>
</blockquote>
</blockquote>
<p>
-A&lt;filename&gt;, –authors-file=&lt;filename&gt;</p>
<blockquote>
<p>Syntax is compatible with the file used by <em>git cvsimport</em> but an empty
email address can be supplied with <em>&lt;&gt;</em>:</p>
<blockquote>
<pre class="example">
        loginname = Joe User &lt;user@example.com&gt;
</pre>
</blockquote>
<p>
If this option is specified and <em>git svn</em> encounters an SVN committer
name that does not exist in the authors-file, <em>git svn</em> will abort
operation. The user will then have to add the appropriate entry.
Re-running the previous <em>git svn</em> command after the authors-file is
modified should continue operation.</p>
<blockquote>
<pre class="example">
config key: svn.authorsfile
</pre>
</blockquote>
</blockquote>
<p>
–authors-prog=&lt;filename&gt;</p>
<blockquote>
<p>If this option is specified, for each SVN committer name that does not
exist in the authors file, the given file is executed with the committer
name as the first argument. The program is expected to return a single
line of the form &#34;Name &lt;email&gt;&#34; or &#34;Name &lt;&gt;&#34;, which will be treated as
if included in the authors file.</p>
<p>
Due to historical reasons a relative <em>filename</em> is first searched
relative to the current directory for <em>init</em> and <em>clone</em> and relative to
the root of the working tree for <em>fetch</em>. If <em>filename</em> is not found, it
is searched like any other command in <em>$PATH</em>.</p>
<blockquote>
<pre class="example">
config key: svn.authorsProg
</pre>
</blockquote>
</blockquote>
<p>
-q, –quiet</p>
<blockquote>
<p>Make <em>git svn</em> less verbose. Specify a second time to make it even less
verbose.</p>
</blockquote>
<p>
-m, –merge, -s&lt;strategy&gt;, –strategy=&lt;strategy&gt;, -p, –rebase-merges</p>
<blockquote>
<p>These are only used with the <em>dcommit</em> and <em>rebase</em> commands.</p>
<p>
Passed directly to <em>git rebase</em> when using <em>dcommit</em> if a <em>git reset</em>
cannot be used (see <em>dcommit</em>).</p>
</blockquote>
<p>
-n, –dry-run</p>
<blockquote>
<p>This can be used with the <em>dcommit</em>, <em>rebase</em>, <em>branch</em> and <em>tag</em>
commands.</p>
<p>
For <em>dcommit</em>, print out the series of Git arguments that would show
which diffs would be committed to SVN.</p>
<p>
For <em>rebase</em>, display the local branch associated with the upstream svn
repository associated with the current branch and the URL of svn
repository that will be fetched from.</p>
<p>
For <em>branch</em> and <em>tag</em>, display the urls that will be used for copying
when creating the branch or tag.</p>
</blockquote>
<p>
–use-log-author</p>
<blockquote>
<p>When retrieving svn commits into Git (as part of <em>fetch</em>, <em>rebase</em>, or
<em>dcommit</em> operations), look for the first <strong>From:</strong> line or
<strong>Signed-off-by</strong> trailer in the log message and use that as the author
string.</p>
<blockquote>
<pre class="example">
config key: svn.useLogAuthor
</pre>
</blockquote>
</blockquote>
<p>
–add-author-from</p>
<blockquote>
<p>When committing to svn from Git (as part of <em>set-tree</em> or <em>dcommit</em>
operations), if the existing log message doesn&#39;t already have a <strong>From:</strong>
or <strong>Signed-off-by</strong> trailer, append a <strong>From:</strong> line based on the Git
commit&#39;s author string. If you use this, then <strong>–use-log-author</strong> will
retrieve a valid author string for all commits.</p>
<blockquote>
<pre class="example">
config key: svn.addAuthorFrom
</pre>
</blockquote>
</blockquote>
</div>
</div>
<div id="outline-container-headline-6" class="outline-2">
<h2 id="headline-6">
ADVANCED OPTIONS
</h2>
<div id="outline-text-headline-6" class="outline-text-2">
<p>-i&lt;GIT_SVN_ID&gt;, –id &lt;GIT_SVN_ID&gt;</p>
<blockquote>
<p>This sets GIT_SVN_ID (instead of using the environment). This allows the
user to override the default refname to fetch from when tracking a
single URL. The <em>log</em> and <em>dcommit</em> commands no longer require this
switch as an argument.</p>
</blockquote>
<p>
-R&lt;remote-name&gt;, –svn-remote &lt;remote-name&gt;</p>
<blockquote>
<p>Specify the [svn-remote &#34;&lt;remote-name&gt;&#34;] section to use, this allows SVN
multiple repositories to be tracked. Default: &#34;svn&#34;</p>
</blockquote>
<p>
–follow-parent</p>
<blockquote>
<p>This option is only relevant if we are tracking branches (using one of
the repository layout options –trunk, –tags, –branches, –stdlayout).
For each tracked branch, try to find out where its revision was copied
from, and set a suitable parent in the first Git commit for the branch.
This is especially helpful when we&#39;re tracking a directory that has been
moved around within the repository. If this feature is disabled, the
branches created by <em>git svn</em> will all be linear and not share any
history, meaning that there will be no information on where branches
were branched off or merged. However, following long/convoluted
histories can take a long time, so disabling this feature may speed up
the cloning process. This feature is enabled by default, use
–no-follow-parent to disable it.</p>
<blockquote>
<pre class="example">
config key: svn.followparent
</pre>
</blockquote>
</blockquote>
</div>
</div>
<div id="outline-container-headline-7" class="outline-2">
<h2 id="headline-7">
CONFIG FILE-ONLY OPTIONS
</h2>
<div id="outline-text-headline-7" class="outline-text-2">
<p>svn.noMetadata, svn-remote.&lt;name&gt;.noMetadata</p>
<blockquote>
<p>This gets rid of the <em>git-svn-id:</em> lines at the end of every commit.</p>
<p>
This option can only be used for one-shot imports as <em>git svn</em> will not
be able to fetch again without metadata. Additionally, if you lose your
<em>$GIT_DIR/svn/**</em>.rev_map.*/ files, <em>git svn</em> will not be able to
rebuild them.</p>
<p>
The <em>git svn log</em> command will not work on repositories using this,
either. Using this conflicts with the <em>useSvmProps</em> option for
(hopefully) obvious reasons.</p>
<p>
This option is NOT recommended as it makes it difficult to track down
old references to SVN revision numbers in existing documentation, bug
reports, and archives. If you plan to eventually migrate from SVN to Git
and are certain about dropping SVN history, consider
<strong>git-filter-repo</strong>[1] instead. filter-repo also allows reformatting of
metadata for ease-of-reading and rewriting authorship info for
non-&#34;svn.authorsFile&#34; users.</p>
</blockquote>
<p>
svn.useSvmProps, svn-remote.&lt;name&gt;.useSvmProps</p>
<blockquote>
<p>This allows <em>git svn</em> to re-map repository URLs and UUIDs from mirrors
created using SVN::Mirror (or svk) for metadata.</p>
<p>
If an SVN revision has a property, &#34;svm:headrev&#34;, it is likely that the
revision was created by SVN::Mirror (also used by SVK). The property
contains a repository UUID and a revision. We want to make it look like
we are mirroring the original URL, so introduce a helper function that
returns the original identity URL and UUID, and use it when generating
metadata in commit messages.</p>
</blockquote>
<p>
svn.useSvnsyncProps, svn-remote.&lt;name&gt;.useSvnsyncprops</p>
<blockquote>
<p>Similar to the useSvmProps option; this is for users of the svnsync(1)
command distributed with SVN 1.4.x and later.</p>
</blockquote>
<p>
svn-remote.&lt;name&gt;.rewriteRoot</p>
<blockquote>
<p>This allows users to create repositories from alternate URLs. For
example, an administrator could run <em>git svn</em> on the server locally
(accessing via <a href="//)">//)</a> but wish to distribute the repository with a
public http:// or svn:// URL in the metadata so users of it will see the
public URL.</p>
</blockquote>
<p>
svn-remote.&lt;name&gt;.rewriteUUID</p>
<blockquote>
<p>Similar to the useSvmProps option; this is for users who need to remap
the UUID manually. This may be useful in situations where the original
UUID is not available via either useSvmProps or useSvnsyncProps.</p>
</blockquote>
<p>
svn-remote.&lt;name&gt;.pushurl</p>
<blockquote>
<p>Similar to Git&#39;s <strong>remote.&lt;name&gt;.pushurl</strong>, this key is designed to be
used in cases where <em>url</em> points to an SVN repository via a read-only
transport, to provide an alternate read/write transport. It is assumed
that both keys point to the same repository. Unlike <em>commiturl</em>,
<em>pushurl</em> is a base path. If either <em>commiturl</em> or <em>pushurl</em> could be
used, <em>commiturl</em> takes precedence.</p>
</blockquote>
<p>
svn.brokenSymlinkWorkaround</p>
<blockquote>
<p>This disables potentially expensive checks to workaround broken symlinks
checked into SVN by broken clients. Set this option to &#34;false&#34; if you
track a SVN repository with many empty blobs that are not symlinks. This
option may be changed while <em>git svn</em> is running and take effect on the
next revision fetched. If unset, <em>git svn</em> assumes this option to be
&#34;true&#34;.</p>
</blockquote>
<p>
svn.pathnameencoding</p>
<blockquote>
<p>This instructs git svn to recode pathnames to a given encoding. It can
be used by windows users and by those who work in non-utf8 locales to
avoid corrupted file names with non-ASCII characters. Valid encodings
are the ones supported by Perl&#39;s Encode module.</p>
</blockquote>
<p>
svn-remote.&lt;name&gt;.automkdirs</p>
<blockquote>
<p>Normally, the &#34;git svn clone&#34; and &#34;git svn rebase&#34; commands attempt to
recreate empty directories that are in the Subversion repository. If
this option is set to &#34;false&#34;, then empty directories will only be
created if the &#34;git svn mkdirs&#34; command is run explicitly. If unset,
<em>git svn</em> assumes this option to be &#34;true&#34;.</p>
</blockquote>
<p>
Since the noMetadata, rewriteRoot, rewriteUUID, useSvnsyncProps and
useSvmProps options all affect the metadata generated and used by <em>git
svn</em>; they <strong>must</strong> be set in the configuration file before any history is
imported and these settings should never be changed once they are set.</p>
<p>
Additionally, only one of these options can be used per svn-remote
section because they affect the <em>git-svn-id:</em> metadata line, except for
rewriteRoot and rewriteUUID which can be used together.</p>
</div>
</div>
<div id="outline-container-headline-8" class="outline-2">
<h2 id="headline-8">
BASIC EXAMPLES
</h2>
<div id="outline-text-headline-8" class="outline-text-2">
<p>Tracking and contributing to the trunk of a Subversion-managed project
(ignoring tags and branches):</p>
<blockquote>
<pre class="example">
# Clone a repo (like git clone):
        git svn clone http://svn.example.com/project/trunk
# Enter the newly cloned directory:
        cd trunk
# You should be on master branch, double-check with git branch
        git branch
# Do some work and commit locally to Git:
        git commit ...
# Something is committed to SVN, rebase your local changes against the
# latest changes in SVN:
        git svn rebase
# Now commit your changes (that were committed previously using Git) to SVN,
# as well as automatically updating your working HEAD:
        git svn dcommit
# Append svn:ignore settings to the default Git exclude file:
        git svn show-ignore &gt;&gt; .git/info/exclude
</pre>
</blockquote>
<p>
Tracking and contributing to an entire Subversion-managed project
(complete with a trunk, tags and branches):</p>
<blockquote>
<pre class="example">
# Clone a repo with standard SVN directory layout (like git clone):
        git svn clone http://svn.example.com/project --stdlayout --prefix svn/
# Or, if the repo uses a non-standard directory layout:
        git svn clone http://svn.example.com/project -T tr -b branch -t tag --prefix svn/
# View all branches and tags you have cloned:
        git branch -r
# Create a new branch in SVN
        git svn branch waldo
# Reset your master to trunk (or any other branch, replacing trunk
# with the appropriate name):
        git reset --hard svn/trunk
# You may only dcommit to one branch/tag/trunk at a time.  The usage
# of dcommit/rebase/show-ignore should be the same as above.
</pre>
</blockquote>
<p>
The initial <em>git svn clone</em> can be quite time-consuming (especially for
large Subversion repositories). If multiple people (or one person with
multiple machines) want to use <em>git svn</em> to interact with the same
Subversion repository, you can do the initial <em>git svn clone</em> to a
repository on a server and have each person clone that repository with
<em>git clone</em>:</p>
<blockquote>
<pre class="example">
# Do the initial import on a server
        ssh server &#34;cd /pub &amp;&amp; git svn clone http://svn.example.com/project [options...]&#34;
# Clone locally - make sure the refs/remotes/ space matches the server
        mkdir project
        cd project
        git init
        git remote add origin server:/pub/project
        git config --replace-all remote.origin.fetch +refs/remotes/*:refs/remotes/*
        git fetch
# Prevent fetch/pull from remote Git server in the future,
# we only want to use git svn for future updates
        git config --remove-section remote.origin
# Create a local branch from one of the branches just fetched
        git checkout -b master FETCH_HEAD
# Initialize git svn locally (be sure to use the same URL and
# --stdlayout/-T/-b/-t/--prefix options as were used on server)
        git svn init http://svn.example.com/project [options...]
# Pull the latest changes from Subversion
        git svn rebase
</pre>
</blockquote>
</div>
</div>
<div id="outline-container-headline-9" class="outline-2">
<h2 id="headline-9">
REBASE VS. PULL/MERGE
</h2>
<div id="outline-text-headline-9" class="outline-text-2">
<p>Prefer to use <em>git svn rebase</em> or <em>git rebase</em>, rather than <em>git pull</em>
or <em>git merge</em> to synchronize unintegrated commits with a <em>git svn</em>
branch. Doing so will keep the history of unintegrated commits linear
with respect to the upstream SVN repository and allow the use of the
preferred <em>git svn dcommit</em> subcommand to push unintegrated commits back
into SVN.</p>
<p>
Originally, <em>git svn</em> recommended that developers pulled or merged from
the <em>git svn</em> branch. This was because the author favored <strong>git svn
set-tree B</strong> to commit a single head rather than the <strong>git svn set-tree
A..B</strong> notation to commit multiple commits. Use of <em>git pull</em> or <em>git
merge</em> with <strong>git svn set-tree A..B</strong> will cause non-linear history to be
flattened when committing into SVN and this can lead to merge commits
unexpectedly reversing previous commits in SVN.</p>
</div>
</div>
<div id="outline-container-headline-10" class="outline-2">
<h2 id="headline-10">
MERGE TRACKING
</h2>
<div id="outline-text-headline-10" class="outline-text-2">
<p>While <em>git svn</em> can track copy history (including branches and tags) for
repositories adopting a standard layout, it cannot yet represent merge
history that happened inside git back upstream to SVN users. Therefore
it is advised that users keep history as linear as possible inside Git
to ease compatibility with SVN (see the CAVEATS section below).</p>
</div>
</div>
<div id="outline-container-headline-11" class="outline-2">
<h2 id="headline-11">
HANDLING OF SVN BRANCHES
</h2>
<div id="outline-text-headline-11" class="outline-text-2">
<p>If <em>git svn</em> is configured to fetch branches (and –follow-branches is
in effect), it sometimes creates multiple Git branches for one SVN
branch, where the additional branches have names of the form
<em>branchname@nnn</em> (with nnn an SVN revision number). These additional
branches are created if <em>git svn</em> cannot find a parent commit for the
first commit in an SVN branch, to connect the branch to the history of
the other branches.</p>
<p>
Normally, the first commit in an SVN branch consists of a copy
operation. <em>git svn</em> will read this commit to get the SVN revision the
branch was created from. It will then try to find the Git commit that
corresponds to this SVN revision, and use that as the parent of the
branch. However, it is possible that there is no suitable Git commit to
serve as parent. This will happen, among other reasons, if the SVN
branch is a copy of a revision that was not fetched by <em>git svn</em> (e.g.
because it is an old revision that was skipped with <strong>–revision</strong>), or if
in SVN a directory was copied that is not tracked by <em>git svn</em> (such as
a branch that is not tracked at all, or a subdirectory of a tracked
branch). In these cases, <em>git svn</em> will still create a Git branch, but
instead of using an existing Git commit as the parent of the branch, it
will read the SVN history of the directory the branch was copied from
and create appropriate Git commits. This is indicated by the message
&#34;Initializing parent: &lt;branchname&gt;&#34;.</p>
<p>
Additionally, it will create a special branch named
<em>&lt;branchname&gt;@&lt;SVN-Revision&gt;</em>, where &lt;SVN-Revision&gt; is the SVN revision
number the branch was copied from. This branch will point to the newly
created parent commit of the branch. If in SVN the branch was deleted
and later recreated from a different version, there will be multiple
such branches with an <em>@</em>.</p>
<p>
Note that this may mean that multiple Git commits are created for a
single SVN revision.</p>
<p>
An example: in an SVN repository with a standard trunk/tags/branches
layout, a directory trunk/sub is created in r.100. In r.200, trunk/sub
is branched by copying it to branches/. <em>git svn clone -s</em> will then
create a branch <em>sub</em>. It will also create new Git commits for r.100
through r.199 and use these as the history of branch <em>sub</em>. Thus there
will be two Git commits for each revision from r.100 to r.199 (one
containing trunk/, one containing trunk/sub/). Finally, it will create a
branch <em>sub@200</em> pointing to the new parent commit of branch <em>sub</em> (i.e.
the commit for r.200 and trunk/sub/).</p>
</div>
</div>
<div id="outline-container-headline-12" class="outline-2">
<h2 id="headline-12">
CAVEATS
</h2>
<div id="outline-text-headline-12" class="outline-text-2">
<p>For the sake of simplicity and interoperating with Subversion, it is
recommended that all <em>git svn</em> users clone, fetch and dcommit directly
from the SVN server, and avoid all <em>git clone///pull///merge///push</em>
operations between Git repositories and branches. The recommended method
of exchanging code between Git branches and users is <em>git format-patch</em>
and <em>git am</em>, or just dcommit&#39;ing to the SVN repository.</p>
<p>
Running <em>git merge</em> or <em>git pull</em> is NOT recommended on a branch you
plan to <em>dcommit</em> from because Subversion users cannot see any merges
you&#39;ve made. Furthermore, if you merge or pull from a Git branch that is
a mirror of an SVN branch, <em>dcommit</em> may commit to the wrong branch.</p>
<p>
If you do merge, note the following rule: <em>git svn dcommit</em> will attempt
to commit on top of the SVN commit named in</p>
<blockquote>
<pre class="example">
git log --grep=^git-svn-id: --first-parent -1
</pre>
</blockquote>
<p>
You <em>must</em> therefore ensure that the most recent commit of the branch
you want to dcommit to is the <em>first</em> parent of the merge. Chaos will
ensue otherwise, especially if the first parent is an older commit on
the same SVN branch.</p>
<p>
<em>git clone</em> does not clone branches under the refs/remotes/ hierarchy or
any <em>git svn</em> metadata, or config. So repositories created and managed
with using <em>git svn</em> should use <em>rsync</em> for cloning, if cloning is to be
done at all.</p>
<p>
Since <em>dcommit</em> uses rebase internally, any Git branches you <em>git push</em>
to before <em>dcommit</em> on will require forcing an overwrite of the existing
ref on the remote repository. This is generally considered bad practice,
see the *git-push*(1) documentation for details.</p>
<p>
Do not use the –amend option of *git-commit*(1) on a change you&#39;ve
already dcommitted. It is considered bad practice to –amend commits
you&#39;ve already pushed to a remote repository for other users, and
dcommit with SVN is analogous to that.</p>
<p>
When cloning an SVN repository, if none of the options for describing
the repository layout is used (–trunk, –tags, –branches,
–stdlayout), <em>git svn clone</em> will create a Git repository with
completely linear history, where branches and tags appear as separate
directories in the working copy. While this is the easiest way to get a
copy of a complete repository, for projects with many branches it will
lead to a working copy many times larger than just the trunk. Thus for
projects using the standard directory structure (trunk/branches/tags),
it is recommended to clone with option <strong>–stdlayout</strong>. If the project
uses a non-standard structure, and/or if branches and tags are not
required, it is easiest to only clone one directory (typically trunk),
without giving any repository layout options. If the full history with
branches and tags is required, the options <strong>–trunk</strong> / <strong>–branches</strong> /
<strong>–tags</strong> must be used.</p>
<p>
When using multiple –branches or –tags, <em>git svn</em> does not
automatically handle name collisions (for example, if two branches from
different paths have the same name, or if a branch and a tag have the
same name). In these cases, use <em>init</em> to set up your Git repository
then, before your first <em>fetch</em>, edit the $GIT_DIR/config file so that
the branches and tags are associated with different name spaces. For
example:</p>
<blockquote>
<pre class="example">
branches = stable/*:refs/remotes/svn/stable/*
branches = debug/*:refs/remotes/svn/debug/*
</pre>
</blockquote>
</div>
</div>
<div id="outline-container-headline-13" class="outline-2">
<h2 id="headline-13">
CONFIGURATION
</h2>
<div id="outline-text-headline-13" class="outline-text-2">
<p><em>git svn</em> stores [svn-remote] configuration information in the
repository $GIT_DIR/config file. It is similar the core Git [remote]
sections except <em>fetch</em> keys do not accept glob arguments; but they are
instead handled by the <em>branches</em> and <em>tags</em> keys. Since some SVN
repositories are oddly configured with multiple projects glob expansions
such those listed below are allowed:</p>
<blockquote>
<pre class="example">
[svn-remote &#34;project-a&#34;]
        url = http://server.org/svn
        fetch = trunk/project-a:refs/remotes/project-a/trunk
        branches = branches/*/project-a:refs/remotes/project-a/branches/*
        branches = branches/release_*:refs/remotes/project-a/branches/release_*
        branches = branches/re*se:refs/remotes/project-a/branches/*
        tags = tags/*/project-a:refs/remotes/project-a/tags/*
</pre>
</blockquote>
<p>
Keep in mind that the <strong>*</strong> (asterisk) wildcard of the local ref (right of
the <strong>:</strong>) <strong>must</strong> be the farthest right path component; however the remote
wildcard may be anywhere as long as it&#39;s an independent path component
(surrounded by <strong>/</strong> or EOL). This type of configuration is not
automatically created by <em>init</em> and should be manually entered with a
text-editor or using <em>git config</em>.</p>
<p>
Also note that only one asterisk is allowed per word. For example:</p>
<blockquote>
<pre class="example">
branches = branches/re*se:refs/remotes/project-a/branches/*
</pre>
</blockquote>
<p>
will match branches <em>release</em>, <em>rese</em>, <em>re123se</em>, however</p>
<blockquote>
<pre class="example">
branches = branches/re*s*e:refs/remotes/project-a/branches/*
</pre>
</blockquote>
<p>
will produce an error.</p>
<p>
It is also possible to fetch a subset of branches or tags by using a
comma-separated list of names within braces. For example:</p>
<blockquote>
<pre class="example">
[svn-remote &#34;huge-project&#34;]
        url = http://server.org/svn
        fetch = trunk/src:refs/remotes/trunk
        branches = branches/{red,green}/src:refs/remotes/project-a/branches/*
        tags = tags/{1.0,2.0}/src:refs/remotes/project-a/tags/*
</pre>
</blockquote>
<p>
Multiple fetch, branches, and tags keys are supported:</p>
<blockquote>
<pre class="example">
[svn-remote &#34;messy-repo&#34;]
        url = http://server.org/svn
        fetch = trunk/project-a:refs/remotes/project-a/trunk
        fetch = branches/demos/june-project-a-demo:refs/remotes/project-a/demos/june-demo
        branches = branches/server/*:refs/remotes/project-a/branches/*
        branches = branches/demos/2011/*:refs/remotes/project-a/2011-demos/*
        tags = tags/server/*:refs/remotes/project-a/tags/*
</pre>
</blockquote>
<p>
Creating a branch in such a configuration requires disambiguating which
location to use using the -d or –destination flag:</p>
<blockquote>
<pre class="example">
$ git svn branch -d branches/server release-2-3-0
</pre>
</blockquote>
<p>
Note that git-svn keeps track of the highest revision in which a branch
or tag has appeared. If the subset of branches or tags is changed after
fetching, then $GIT_DIR/svn/.metadata must be manually edited to remove
(or reset) branches-maxRev and/or tags-maxRev as appropriate.</p>
</div>
</div>
<div id="outline-container-headline-14" class="outline-2">
<h2 id="headline-14">
FILES
</h2>
<div id="outline-text-headline-14" class="outline-text-2">
<p>$GIT_DIR/svn/**/.rev_map.*</p>
<blockquote>
<p>Mapping between Subversion revision numbers and Git commit names. In a
repository where the noMetadata option is not set, this can be rebuilt
from the git-svn-id: lines that are at the end of every commit (see the
<em>svn.noMetadata</em> section above for details).</p>
<p>
<em>git svn fetch</em> and <em>git svn rebase</em> automatically update the rev_map if
it is missing or not up to date. <em>git svn reset</em> automatically rewinds
it.</p>
</blockquote>
</div>
</div>
<div id="outline-container-headline-15" class="outline-2">
<h2 id="headline-15">
BUGS
</h2>
<div id="outline-text-headline-15" class="outline-text-2">
<p>We ignore all SVN properties except svn:executable. Any unhandled
properties are logged to $GIT_DIR/svn/&lt;refname&gt;/unhandled.log</p>
<p>
Renamed and copied directories are not detected by Git and hence not
tracked when committing to SVN. I do not plan on adding support for this
as it&#39;s quite difficult and time-consuming to get working for all the
possible corner cases (Git doesn&#39;t do it, either). Committing renamed
and copied files is fully supported if they&#39;re similar enough for Git to
detect them.</p>
<p>
In SVN, it is possible (though discouraged) to commit changes to a tag
(because a tag is just a directory copy, thus technically the same as a
branch). When cloning an SVN repository, <em>git svn</em> cannot know if such a
commit to a tag will happen in the future. Thus it acts conservatively
and imports all SVN tags as branches, prefixing the tag name with
<em>tags/</em>.</p>
</div>
</div>
<div id="outline-container-headline-16" class="outline-2">
<h2 id="headline-16">
SEE ALSO
</h2>
<div id="outline-text-headline-16" class="outline-text-2">
<p>*git-rebase*(1)</p>
</div>
</div>
<div id="outline-container-headline-17" class="outline-2">
<h2 id="headline-17">
GIT
</h2>
<div id="outline-text-headline-17" class="outline-text-2">
<p>Part of the *git*(1) suite</p>
</div>
</div>
<div id="outline-container-headline-18" class="outline-2">
<h2 id="headline-18">
NOTES
</h2>
<div id="outline-text-headline-18" class="outline-text-2">
<dl>
<dt>
1.
</dt>
<dd>git-filter-repo

https://github.com/newren/git-filter-repo</dd>
</dl>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.js"></script>
    </body>
</html>
