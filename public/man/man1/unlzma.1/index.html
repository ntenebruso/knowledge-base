<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - unlzma.1 | Technical Notes</title>

      <link rel="stylesheet" href="/css/main.min.a9ecaac9d4f7845fc2de4738f7709cab0bd1c3d19c3466fadd637a6987603257.css" integrity="sha256-qeyqydT3hF/C3kc493CcqwvRw9GcNGb63WN6aYdgMlc=" crossorigin="anonymous">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - unlzma.1</h1>
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
NAME
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>xz, unxz, xzcat, lzma, unlzma, lzcat - Compress or decompress .xz and
.lzma files</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
SYNOPSIS
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p><strong>xz</strong> [/option…/] [/file…/]</p>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
COMMAND ALIASES
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p><strong>unxz</strong> is equivalent to <strong>xz –decompress</strong>.<br>
<strong>xzcat</strong> is equivalent to <strong>xz –decompress –stdout</strong>.<br>
<strong>lzma</strong> is equivalent to <strong>xz –format=lzma</strong>.<br>
<strong>unlzma</strong> is equivalent to <strong>xz –format=lzma –decompress</strong>.<br>
<strong>lzcat</strong> is equivalent to <strong>xz –format=lzma –decompress –stdout</strong>.</p>
<p>
When writing scripts that need to decompress files, it is recommended to
always use the name <strong>xz</strong> with appropriate arguments (<strong>xz -d</strong> or <strong>xz
-dc</strong>) instead of the names <strong>unxz</strong> and <strong>xzcat</strong>.</p>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
DESCRIPTION
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<p><strong>xz</strong> is a general-purpose data compression tool with command line syntax
similar to <strong>gzip*(1) and *bzip2*(1). The native file format is the *.xz</strong>
format, but the legacy <strong>.lzma</strong> format used by LZMA Utils and raw
compressed streams with no container format headers are also supported.
In addition, decompression of the <strong>.lz</strong> format used by <strong>lzip</strong> is
supported.</p>
<p>
<strong>xz</strong> compresses or decompresses each <em>file</em> according to the selected
operation mode. If no <em>files</em> are given or <em>file</em> is <strong>-</strong>, <strong>xz</strong> reads
from standard input and writes the processed data to standard output.
<strong>xz</strong> will refuse (display an error and skip the <em>file</em>) to write
compressed data to standard output if it is a terminal. Similarly, <strong>xz</strong>
will refuse to read compressed data from standard input if it is a
terminal.</p>
<p>
Unless <strong>–stdout</strong> is specified, <em>files</em> other than <strong>-</strong> are written to a
new file whose name is derived from the source <em>file</em> name:</p>
<ul>
<li>When compressing, the suffix of the target file format (<strong>.xz</strong> or
<strong>.lzma</strong>) is appended to the source filename to get the target
filename.</li>
<li>When decompressing, the <strong>.xz</strong>, <strong>.lzma</strong>, or <strong>.lz</strong> suffix is removed
from the filename to get the target filename. <strong>xz</strong> also recognizes the
suffixes <strong>.txz</strong> and <strong>.tlz</strong>, and replaces them with the <strong>.tar</strong> suffix.</li>
</ul>
<p>If the target file already exists, an error is displayed and the <em>file</em>
is skipped.</p>
<p>
Unless writing to standard output, <strong>xz</strong> will display a warning and skip
the <em>file</em> if any of the following applies:</p>
<ul>
<li><em>File</em> is not a regular file. Symbolic links are not followed, and
thus they are not considered to be regular files.</li>
<li><em>File</em> has more than one hard link.</li>
<li><em>File</em> has setuid, setgid, or sticky bit set.</li>
<li>The operation mode is set to compress and the <em>file</em> already has a
suffix of the target file format (<strong>.xz</strong> or <strong>.txz</strong> when compressing to
the <strong>.xz</strong> format, and <strong>.lzma</strong> or <strong>.tlz</strong> when compressing to the
<strong>.lzma</strong> format).</li>
<li>The operation mode is set to decompress and the <em>file</em> doesn&#39;t have a
suffix of any of the supported file formats (<strong>.xz</strong>, <strong>.txz</strong>, <strong>.lzma</strong>,
<strong>.tlz</strong>, or <strong>.lz</strong>).</li>
</ul>
<p>After successfully compressing or decompressing the <em>file</em>, <strong>xz</strong> copies
the owner, group, permissions, access time, and modification time from
the source <em>file</em> to the target file. If copying the group fails, the
permissions are modified so that the target file doesn&#39;t become
accessible to users who didn&#39;t have permission to access the source
<em>file</em>. <strong>xz</strong> doesn&#39;t support copying other metadata like access control
lists or extended attributes yet.</p>
<p>
Once the target file has been successfully closed, the source <em>file</em> is
removed unless <strong>–keep</strong> was specified. The source <em>file</em> is never
removed if the output is written to standard output or if an error
occurs.</p>
<p>
Sending <strong>SIGINFO</strong> or <strong>SIGUSR1</strong> to the <strong>xz</strong> process makes it print
progress information to standard error. This has only limited use since
when standard error is a terminal, using <strong>–verbose</strong> will display an
automatically updating progress indicator.</p>
<div id="outline-container-headline-5" class="outline-3">
<h3 id="headline-5">
Memory usage
</h3>
<div id="outline-text-headline-5" class="outline-text-3">
<p>The memory usage of <strong>xz</strong> varies from a few hundred kilobytes to several
gigabytes depending on the compression settings. The settings used when
compressing a file determine the memory requirements of the
decompressor. Typically the decompressor needs 5 % to 20 % of the amount
of memory that the compressor needed when creating the file. For
example, decompressing a file created with <strong>xz -9</strong> currently requires 65
MiB of memory. Still, it is possible to have <strong>.xz</strong> files that require
several gigabytes of memory to decompress.</p>
<p>
Especially users of older systems may find the possibility of very large
memory usage annoying. To prevent uncomfortable surprises, <strong>xz</strong> has a
built-in memory usage limiter, which is disabled by default. While some
operating systems provide ways to limit the memory usage of processes,
relying on it wasn&#39;t deemed to be flexible enough (for example, using
*ulimit*(1) to limit virtual memory tends to cripple *mmap*(2)).</p>
<p>
The memory usage limiter can be enabled with the command line option
<strong>–memlimit=*/limit/. Often it is more convenient to enable the limiter
by default by setting the environment variable *XZ_DEFAULTS</strong>, for
example, <strong>XZ_DEFAULTS=–memlimit=150MiB</strong>. It is possible to set the
limits separately for compression and decompression by using
<strong>–memlimit-compress=*/limit/ and *–memlimit-decompress=*/limit/. Using
these two options outside *XZ_DEFAULTS</strong> is rarely useful because a
single run of <strong>xz</strong> cannot do both compression and decompression and
<strong>–memlimit=*/limit/ (or *-M</strong> <em>limit</em>) is shorter to type on the command
line.</p>
<p>
If the specified memory usage limit is exceeded when decompressing, <strong>xz</strong>
will display an error and decompressing the file will fail. If the limit
is exceeded when compressing, <strong>xz</strong> will try to scale the settings down
so that the limit is no longer exceeded (except when using
<strong>–format=raw</strong> or <strong>–no-adjust</strong>). This way the operation won&#39;t fail
unless the limit is very small. The scaling of the settings is done in
steps that don&#39;t match the compression level presets, for example, if
the limit is only slightly less than the amount required for <strong>xz -9</strong>,
the settings will be scaled down only a little, not all the way down to
<strong>xz -8</strong>.</p>
</div>
</div>
<div id="outline-container-headline-6" class="outline-3">
<h3 id="headline-6">
Concatenation and padding with .xz files
</h3>
<div id="outline-text-headline-6" class="outline-text-3">
<p>It is possible to concatenate <strong>.xz</strong> files as is. <strong>xz</strong> will decompress
such files as if they were a single <strong>.xz</strong> file.</p>
<p>
It is possible to insert padding between the concatenated parts or after
the last part. The padding must consist of null bytes and the size of
the padding must be a multiple of four bytes. This can be useful, for
example, if the <strong>.xz</strong> file is stored on a medium that measures file
sizes in 512-byte blocks.</p>
<p>
Concatenation and padding are not allowed with <strong>.lzma</strong> files or raw
streams.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-7" class="outline-2">
<h2 id="headline-7">
OPTIONS
</h2>
<div id="outline-text-headline-7" class="outline-text-2">
<div id="outline-container-headline-8" class="outline-3">
<h3 id="headline-8">
Integer suffixes and special values
</h3>
<div id="outline-text-headline-8" class="outline-text-3">
<p>In most places where an integer argument is expected, an optional suffix
is supported to easily indicate large integers. There must be no space
between the integer and the suffix.</p>
<dl>
<dt>
<strong>KiB</strong>
</dt>
<dd>Multiply the integer by 1,024 (2^10). <strong>Ki</strong>, <strong>k</strong>, <strong>kB</strong>, <strong>K</strong>,
and <strong>KB</strong> are accepted as synonyms for <strong>KiB</strong>.</dd>
<dt>
<strong>MiB</strong>
</dt>
<dd>Multiply the integer by 1,048,576 (2^20). <strong>Mi</strong>, <strong>m</strong>, <strong>M</strong>, and
<strong>MB</strong> are accepted as synonyms for <strong>MiB</strong>.</dd>
<dt>
<strong>GiB</strong>
</dt>
<dd>Multiply the integer by 1,073,741,824 (2^30). <strong>Gi</strong>, <strong>g</strong>, <strong>G</strong>,
and <strong>GB</strong> are accepted as synonyms for <strong>GiB</strong>.</dd>
</dl>
<p>The special value <strong>max</strong> can be used to indicate the maximum integer
value supported by the option.</p>
</div>
</div>
<div id="outline-container-headline-9" class="outline-3">
<h3 id="headline-9">
Operation mode
</h3>
<div id="outline-text-headline-9" class="outline-text-3">
<p>If multiple operation mode options are given, the last one takes effect.</p>
<dl>
<dt>
<strong>-z</strong>, <strong>–compress</strong>
</dt>
<dd>Compress. This is the default operation mode
when no operation mode option is specified and no other operation mode
is implied from the command name (for example, <strong>unxz</strong> implies
<strong>–decompress</strong>).</dd>
<dt>
<strong>-d</strong>, <strong>–decompress</strong>, <strong>–uncompress</strong>
</dt>
<dd>Decompress.</dd>
<dt>
<strong>-t</strong>, <strong>–test</strong>
</dt>
<dd>Test the integrity of compressed <em>files</em>. This
option is equivalent to <strong>–decompress –stdout</strong> except that the
decompressed data is discarded instead of being written to standard
output. No files are created or removed.</dd>
<dt>
<strong>-l</strong>, <strong>–list</strong>
</dt>
<dd>Print information about compressed <em>files</em>. No
uncompressed output is produced, and no files are created or removed.
In list mode, the program cannot read the compressed data from
standard input or from other unseekable sources.</dd>
<dt>
?
</dt>
<dd>:: The default listing shows basic information about <em>files</em>, one
file per line. To get more detailed information, use also the
<strong>–verbose</strong> option. For even more information, use <strong>–verbose</strong> twice,
but note that this may be slow, because getting all the extra
information requires many seeks. The width of verbose output exceeds
80 characters, so piping the output to, for example, <strong>less -S</strong> may be
convenient if the terminal isn&#39;t wide enough.</dd>
<dt>
?
</dt>
<dd>:: The exact output may vary between <strong>xz</strong> versions and different
locales. For machine-readable output, <strong>–robot –list</strong> should be used.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-10" class="outline-3">
<h3 id="headline-10">
Operation modifiers
</h3>
<div id="outline-text-headline-10" class="outline-text-3">
<dl>
<dt>
<strong>-k</strong>, <strong>–keep</strong>
</dt>
<dd>Don&#39;t delete the input files.</dd>
<dt>
?
</dt>
<dd>:: Since <strong>xz</strong> 5.2.6, this option also makes <strong>xz</strong> compress or
decompress even if the input is a symbolic link to a regular file, has
more than one hard link, or has the setuid, setgid, or sticky bit set.
The setuid, setgid, and sticky bits are not copied to the target file.
In earlier versions this was only done with <strong>–force</strong>.</dd>
<dt>
<strong>-f</strong>, <strong>–force</strong>
</dt>
<dd>
<p>This option has several effects:</p>
<ul>
<li>If the target file already exists, delete it before compressing or
decompressing.</li>
<li>Compress or decompress even if the input is a symbolic link to a
regular file, has more than one hard link, or has the setuid,
setgid, or sticky bit set. The setuid, setgid, and sticky bits are
not copied to the target file.</li>
<li>When used with <strong>–decompress</strong> <strong>–stdout</strong> and <strong>xz</strong> cannot recognize
the type of the source file, copy the source file as is to standard
output. This allows <strong>xzcat</strong> <strong>–force</strong> to be used like <strong>cat*(1) for
files that have not been compressed with *xz</strong>. Note that in future,
<strong>xz</strong> might support new compressed file formats, which may make <strong>xz</strong>
decompress more types of files instead of copying them as is to
standard output. <strong>–format=*/format/ can be used to restrict *xz</strong> to
decompress only a single file format.</li>
</ul>
</dd>
<dt>
<strong>-c</strong>, <strong>–stdout</strong>, <strong>–to-stdout</strong>
</dt>
<dd>Write the compressed or
decompressed data to standard output instead of a file. This implies
<strong>–keep</strong>.</dd>
<dt>
<strong>–single-stream</strong>
</dt>
<dd>Decompress only the first <strong>.xz</strong> stream, and
silently ignore possible remaining input data following the stream.
Normally such trailing garbage makes <strong>xz</strong> display an error.</dd>
<dt>
?
</dt>
<dd>:: <strong>xz</strong> never decompresses more than one stream from <strong>.lzma</strong> files or
raw streams, but this option still makes <strong>xz</strong> ignore the possible
trailing data after the <strong>.lzma</strong> file or raw stream.</dd>
<dt>
?
</dt>
<dd>:: This option has no effect if the operation mode is not
<strong>–decompress</strong> or <strong>–test</strong>.</dd>
<dt>
<strong>–no-sparse</strong>
</dt>
<dd>Disable creation of sparse files. By default, if
decompressing into a regular file, <strong>xz</strong> tries to make the file sparse
if the decompressed data contains long sequences of binary zeros. It
also works when writing to standard output as long as standard output
is connected to a regular file and certain additional conditions are
met to make it safe. Creating sparse files may save disk space and
speed up the decompression by reducing the amount of disk I/O.</dd>
<dt>
<strong>-S</strong> <em>.suf</em>, *–suffix=*/.suf/
</dt>
<dd>When compressing, use <em>.suf</em> as the
suffix for the target file instead of <strong>.xz</strong> or <strong>.lzma</strong>. If not writing
to standard output and the source file already has the suffix <em>.suf</em>,
a warning is displayed and the file is skipped.</dd>
<dt>
?
</dt>
<dd>:: When decompressing, recognize files with the suffix <em>.suf</em> in
addition to files with the <strong>.xz</strong>, <strong>.txz</strong>, <strong>.lzma</strong>, <strong>.tlz</strong>, or <strong>.lz</strong>
suffix. If the source file has the suffix <em>.suf</em>, the suffix is
removed to get the target filename.</dd>
<dt>
?
</dt>
<dd>:: When compressing or decompressing raw streams (<strong>–format=raw</strong>),
the suffix must always be specified unless writing to standard output,
because there is no default suffix for raw streams.</dd>
<dt>
<strong>–files</strong>[*=*/file/]
</dt>
<dd>Read the filenames to process from <em>file</em>; if
<em>file</em> is omitted, filenames are read from standard input. Filenames
must be terminated with the newline character. A dash (<strong>-</strong>) is taken
as a regular filename; it doesn&#39;t mean standard input. If filenames
are given also as command line arguments, they are processed before
the filenames read from <em>file</em>.</dd>
<dt>
<strong>–files0</strong>[*=*/file/]
</dt>
<dd>This is identical to <strong>–files</strong>[*=*/file/]
except that each filename must be terminated with the null character.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-11" class="outline-3">
<h3 id="headline-11">
Basic file format and compression options
</h3>
<div id="outline-text-headline-11" class="outline-text-3">
<dl>
<dt>
<strong>-F</strong> <em>format</em>, *–format=*/format/
</dt>
<dd>
<p>Specify the file <em>format</em> to
compress or decompress:</p>
<dl>
<dt>
<strong>auto</strong>
</dt>
<dd>This is the default. When compressing, <strong>auto</strong> is
equivalent to <strong>xz</strong>. When decompressing, the format of the input file
is automatically detected. Note that raw streams (created with
<strong>–format=raw</strong>) cannot be auto-detected.</dd>
<dt>
<strong>xz</strong>
</dt>
<dd>Compress to the <strong>.xz</strong> file format, or accept only <strong>.xz</strong>
files when decompressing.</dd>
<dt>
<strong>lzma</strong>, <strong>alone</strong>
</dt>
<dd>Compress to the legacy <strong>.lzma</strong> file format, or
accept only <strong>.lzma</strong> files when decompressing. The alternative name
<strong>alone</strong> is provided for backwards compatibility with LZMA Utils.</dd>
<dt>
<strong>lzip</strong>
</dt>
<dd>Accept only <strong>.lz</strong> files when decompressing. Compression is
not supported.</dd>
<dt>
?
</dt>
<dd>:: The <strong>.lz</strong> format version 0 and the unextended version 1 are
supported. Version 0 files were produced by <strong>lzip</strong> 1.3 and older.
Such files aren&#39;t common but may be found from file archives as a
few source packages were released in this format. People might have
old personal files in this format too. Decompression support for the
format version 0 was removed in <strong>lzip</strong> 1.18.</dd>
<dt>
?
</dt>
<dd>:: <strong>lzip</strong> 1.4 and later create files in the format version 1. The
sync flush marker extension to the format version 1 was added in
<strong>lzip</strong> 1.6. This extension is rarely used and isn&#39;t supported by
<strong>xz</strong> (diagnosed as corrupt input).</dd>
<dt>
<strong>raw</strong>
</dt>
<dd>Compress or uncompress a raw stream (no headers). This is
meant for advanced users only. To decode raw streams, you need use
<strong>–format=raw</strong> and explicitly specify the filter chain, which
normally would have been stored in the container headers.</dd>
</dl>
</dd>
<dt>
<strong>-C</strong> <em>check</em>, *–check=*/check/
</dt>
<dd>Specify the type of the integrity
check. The check is calculated from the uncompressed data and stored
in the <strong>.xz</strong> file. This option has an effect only when compressing
into the <strong>.xz</strong> format; the <strong>.lzma</strong> format doesn&#39;t support integrity
checks. The integrity check (if any) is verified when the <strong>.xz</strong> file
is decompressed.</dd>
<dt>
?
</dt>
<dd>
<p>:: Supported <em>check</em> types:</p>
<dl>
<dt>
<strong>none</strong>
</dt>
<dd>Don&#39;t calculate an integrity check at all. This is usually
a bad idea. This can be useful when integrity of the data is
verified by other means anyway.</dd>
<dt>
<strong>crc32</strong>
</dt>
<dd>Calculate CRC32 using the polynomial from IEEE-802.3
(Ethernet).</dd>
<dt>
<strong>crc64</strong>
</dt>
<dd>Calculate CRC64 using the polynomial from ECMA-182. This
is the default, since it is slightly better than CRC32 at detecting
damaged files and the speed difference is negligible.</dd>
<dt>
<strong>sha256</strong>
</dt>
<dd>Calculate SHA-256. This is somewhat slower than CRC32
and CRC64.</dd>
</dl>
</dd>
<dt>
?
</dt>
<dd>:: Integrity of the <strong>.xz</strong> headers is always verified with CRC32. It
is not possible to change or disable it.</dd>
<dt>
<strong>–ignore-check</strong>
</dt>
<dd>Don&#39;t verify the integrity check of the compressed
data when decompressing. The CRC32 values in the <strong>.xz</strong> headers will
still be verified normally.</dd>
<dt>
?
</dt>
<dd>
<p>:: <strong>Do not use this option unless you know what you are doing.</strong>
Possible reasons to use this option:</p>
<ul>
<li>Trying to recover data from a corrupt .xz file.</li>
<li>Speeding up decompression. This matters mostly with SHA-256 or with
files that have compressed extremely well. It&#39;s recommended to not
use this option for this purpose unless the file integrity is
verified externally in some other way.</li>
</ul>
</dd>
<dt>
<strong>-0</strong> … <strong>-9</strong>
</dt>
<dd>Select a compression preset level. The default is
<strong>-6</strong>. If multiple preset levels are specified, the last one takes
effect. If a custom filter chain was already specified, setting a
compression preset level clears the custom filter chain.</dd>
<dt>
?
</dt>
<dd>
<p>:: The differences between the presets are more significant than with
*gzip*(1) and *bzip2*(1). The selected compression settings determine
the memory requirements of the decompressor, thus using a too high
preset level might make it painful to decompress the file on an old
system with little RAM. Specifically, <strong>it&#39;s not a good idea to blindly
use -9 for everything</strong> like it often is with *gzip*(1) and *bzip2*(1).</p>
<dl>
<dt>
<strong>-0</strong> … <strong>-3</strong>
</dt>
<dd>These are somewhat fast presets. <strong>-0</strong> is sometimes
faster than <strong>gzip -9</strong> while compressing much better. The higher ones
often have speed comparable to *bzip2*(1) with comparable or better
compression ratio, although the results depend a lot on the type of
data being compressed.</dd>
<dt>
<strong>-4</strong> … <strong>-6</strong>
</dt>
<dd>Good to very good compression while keeping
decompressor memory usage reasonable even for old systems. <strong>-6</strong> is
the default, which is usually a good choice for distributing files
that need to be decompressible even on systems with only 16 MiB RAM.
(<strong>-5e</strong> or <strong>-6e</strong> may be worth considering too. See <strong>–extreme</strong>.)</dd>
<dt>
<strong>-7 … -9</strong>
</dt>
<dd>These are like <strong>-6</strong> but with higher compressor and
decompressor memory requirements. These are useful only when
compressing files bigger than 8 MiB, 16 MiB, and 32 MiB,
respectively.</dd>
</dl>
</dd>
<dt>
?
</dt>
<dd>:: On the same hardware, the decompression speed is approximately a
constant number of bytes of compressed data per second. In other
words, the better the compression, the faster the decompression will
usually be. This also means that the amount of uncompressed output
produced per second can vary a lot.</dd>
<dt>
?
</dt>
<dd>
<p>:: The following table summarises the features of the presets:</p>
<blockquote>
<table>
<tbody>
<tr>
<td class="align-right">Preset</td>
<td>DictSize</td>
<td class="align-right">CompCPU</td>
<td>CompMem</td>
<td>DecMem</td>
</tr>
<tr>
<td class="align-right">-0</td>
<td>256 KiB</td>
<td class="align-right">0</td>
<td>3 MiB</td>
<td>1 MiB</td>
</tr>
<tr>
<td class="align-right">-1</td>
<td>1 MiB</td>
<td class="align-right">1</td>
<td>9 MiB</td>
<td>2 MiB</td>
</tr>
<tr>
<td class="align-right">-2</td>
<td>2 MiB</td>
<td class="align-right">2</td>
<td>17 MiB</td>
<td>3 MiB</td>
</tr>
<tr>
<td class="align-right">-3</td>
<td>4 MiB</td>
<td class="align-right">3</td>
<td>32 MiB</td>
<td>5 MiB</td>
</tr>
<tr>
<td class="align-right">-4</td>
<td>4 MiB</td>
<td class="align-right">4</td>
<td>48 MiB</td>
<td>5 MiB</td>
</tr>
<tr>
<td class="align-right">-5</td>
<td>8 MiB</td>
<td class="align-right">5</td>
<td>94 MiB</td>
<td>9 MiB</td>
</tr>
<tr>
<td class="align-right">-6</td>
<td>8 MiB</td>
<td class="align-right">6</td>
<td>94 MiB</td>
<td>9 MiB</td>
</tr>
<tr>
<td class="align-right">-7</td>
<td>16 MiB</td>
<td class="align-right">6</td>
<td>186 MiB</td>
<td>17 MiB</td>
</tr>
<tr>
<td class="align-right">-8</td>
<td>32 MiB</td>
<td class="align-right">6</td>
<td>370 MiB</td>
<td>33 MiB</td>
</tr>
<tr>
<td class="align-right">-9</td>
<td>64 MiB</td>
<td class="align-right">6</td>
<td>674 MiB</td>
<td>65 MiB</td>
</tr>
</tbody>
</table>
</blockquote>
</dd>
<dt>
?
</dt>
<dd>
<p>:: Column descriptions:</p>
<ul>
<li>DictSize is the LZMA2 dictionary size. It is waste of memory to use
a dictionary bigger than the size of the uncompressed file. This is
why it is good to avoid using the presets <strong>-7</strong> … <strong>-9</strong> when there&#39;s
no real need for them. At <strong>-6</strong> and lower, the amount of memory
wasted is usually low enough to not matter.</li>
<li>CompCPU is a simplified representation of the LZMA2 settings that
affect compression speed. The dictionary size affects speed too, so
while CompCPU is the same for levels <strong>-6</strong> … <strong>-9</strong>, higher levels
still tend to be a little slower. To get even slower and thus
possibly better compression, see <strong>–extreme</strong>.</li>
<li>CompMem contains the compressor memory requirements in the
single-threaded mode. It may vary slightly between <strong>xz</strong> versions.</li>
<li>DecMem contains the decompressor memory requirements. That is, the
compression settings determine the memory requirements of the
decompressor. The exact decompressor memory usage is slightly more
than the LZMA2 dictionary size, but the values in the table have
been rounded up to the next full MiB.</li>
</ul>
</dd>
<dt>
?
</dt>
<dd>:: Memory requirements of the multi-threaded mode are significantly
higher than that of the single-threaded mode. With the default value
of <strong>–block-size</strong>, each thread needs 3*3*DictSize plus CompMem or
DecMem. For example, four threads with preset <strong>-6</strong> needs 660–670 MiB
of memory.</dd>
<dt>
<strong>-e</strong>, <strong>–extreme</strong>
</dt>
<dd>Use a slower variant of the selected compression
preset level (<strong>-0</strong> … <strong>-9</strong>) to hopefully get a little bit better
compression ratio, but with bad luck this can also make it worse.
Decompressor memory usage is not affected, but compressor memory usage
increases a little at preset levels <strong>-0</strong> … <strong>-3</strong>.</dd>
<dt>
?
</dt>
<dd>
<p>:: Since there are two presets with dictionary sizes 4 MiB and 8 MiB,
the presets <strong>-3e</strong> and <strong>-5e</strong> use slightly faster settings (lower
CompCPU) than <strong>-4e</strong> and <strong>-6e</strong>, respectively. That way no two presets
are identical.</p>
<blockquote>
<table>
<tbody>
<tr>
<td>Preset</td>
<td>DictSize</td>
<td class="align-right">CompCPU</td>
<td>CompMem</td>
<td>DecMem</td>
</tr>
<tr>
<td>-0e</td>
<td>256 KiB</td>
<td class="align-right">8</td>
<td>4 MiB</td>
<td>1 MiB</td>
</tr>
<tr>
<td>-1e</td>
<td>1 MiB</td>
<td class="align-right">8</td>
<td>13 MiB</td>
<td>2 MiB</td>
</tr>
<tr>
<td>-2e</td>
<td>2 MiB</td>
<td class="align-right">8</td>
<td>25 MiB</td>
<td>3 MiB</td>
</tr>
<tr>
<td>-3e</td>
<td>4 MiB</td>
<td class="align-right">7</td>
<td>48 MiB</td>
<td>5 MiB</td>
</tr>
<tr>
<td>-4e</td>
<td>4 MiB</td>
<td class="align-right">8</td>
<td>48 MiB</td>
<td>5 MiB</td>
</tr>
<tr>
<td>-5e</td>
<td>8 MiB</td>
<td class="align-right">7</td>
<td>94 MiB</td>
<td>9 MiB</td>
</tr>
<tr>
<td>-6e</td>
<td>8 MiB</td>
<td class="align-right">8</td>
<td>94 MiB</td>
<td>9 MiB</td>
</tr>
<tr>
<td>-7e</td>
<td>16 MiB</td>
<td class="align-right">8</td>
<td>186 MiB</td>
<td>17 MiB</td>
</tr>
<tr>
<td>-8e</td>
<td>32 MiB</td>
<td class="align-right">8</td>
<td>370 MiB</td>
<td>33 MiB</td>
</tr>
<tr>
<td>-9e</td>
<td>64 MiB</td>
<td class="align-right">8</td>
<td>674 MiB</td>
<td>65 MiB</td>
</tr>
</tbody>
</table>
</blockquote>
</dd>
<dt>
?
</dt>
<dd>:: For example, there are a total of four presets that use 8 MiB
dictionary, whose order from the fastest to the slowest is <strong>-5</strong>, <strong>-6</strong>,
<strong>-5e</strong>, and <strong>-6e</strong>.</dd>
<dt>
<strong>–fast</strong>
</dt>
<dd></dd>
<dt>
<strong>–best</strong>
</dt>
<dd></dd>
</dl>
<p>These are somewhat misleading aliases for <strong>-0</strong> and <strong>-9</strong>, respectively.
These are provided only for backwards compatibility with LZMA Utils.
Avoid using these options.</p>
<dl>
<dt>
*–block-size=*/size/
</dt>
<dd>When compressing to the <strong>.xz</strong> format, split
the input data into blocks of <em>size</em> bytes. The blocks are compressed
independently from each other, which helps with multi-threading and
makes limited random-access decompression possible. This option is
typically used to override the default block size in multi-threaded
mode, but this option can be used in single-threaded mode too.</dd>
<dt>
?
</dt>
<dd>:: In multi-threaded mode about three times <em>size</em> bytes will be
allocated in each thread for buffering input and output. The default
<em>size</em> is three times the LZMA2 dictionary size or 1 MiB, whichever is
more. Typically a good value is 2–4 times the size of the LZMA2
dictionary or at least 1 MiB. Using <em>size</em> less than the LZMA2
dictionary size is waste of RAM because then the LZMA2 dictionary
buffer will never get fully used. In multi-threaded mode, the sizes of
the blocks are stored in the block headers. This size information is
required for multi-threaded decompression.</dd>
<dt>
?
</dt>
<dd>:: In single-threaded mode no block splitting is done by default.
Setting this option doesn&#39;t affect memory usage. No size information
is stored in block headers, thus files created in single-threaded mode
won&#39;t be identical to files created in multi-threaded mode. The lack
of size information also means that <strong>xz</strong> won&#39;t be able decompress the
files in multi-threaded mode.</dd>
<dt>
*–block-list=*/items/
</dt>
<dd>When compressing to the <strong>.xz</strong> format, start
a new block with an optional custom filter chain after the given
intervals of uncompressed data.</dd>
<dt>
?
</dt>
<dd>:: The <em>items</em> are a comma-separated list. Each item consists of an
optional filter chain number between 0 and 9 followed by a colon (<strong>:</strong>)
and a required size of uncompressed data. Omitting an item (two or
more consecutive commas) is a shorthand to use the size and filters of
the previous item.</dd>
<dt>
?
</dt>
<dd>:: If the input file is bigger than the sum of the sizes in <em>items</em>,
the last item is repeated until the end of the file. A special value
of <strong>0</strong> may be used as the last size to indicate that the rest of the
file should be encoded as a single block.</dd>
<dt>
?
</dt>
<dd>
<p>:: An alternative filter chain for each block can be specified in
combination with the *–filters1=*/filters/ … *–filters9=*/filters/
options. These options define filter chains with an identifier between
1–9. Filter chain 0 can be used to refer to the default filter chain,
which is the same as not specifying a filter chain. The filter chain
identifier can be used before the uncompressed size, followed by a
colon (<strong>:</strong>). For example, if one specifies
<strong>–block-list=1:2MiB,3:2MiB,2:4MiB,,2MiB,0:4MiB</strong> then blocks will be
created using:</p>
<ul>
<li>The filter chain specified by <strong>–filters1</strong> and 2 MiB input</li>
<li>The filter chain specified by <strong>–filters3</strong> and 2 MiB input</li>
<li>The filter chain specified by <strong>–filters2</strong> and 4 MiB input</li>
<li>The filter chain specified by <strong>–filters2</strong> and 4 MiB input</li>
<li>The default filter chain and 2 MiB input</li>
<li>The default filter chain and 4 MiB input for every block until end
of input.</li>
</ul>
</dd>
<dt>
?
</dt>
<dd>:: If one specifies a size that exceeds the encoder&#39;s block size
(either the default value in threaded mode or the value specified with
*–block-size=*/size/), the encoder will create additional blocks
while keeping the boundaries specified in <em>items</em>. For example, if one
specifies <strong>–block-size=10MiB</strong>
<strong>–block-list=5MiB,10MiB,8MiB,12MiB,24MiB</strong> and the input file is 80
MiB, one will get 11 blocks: 5, 10, 8, 10, 2, 10, 10, 4, 10, 10, and 1
MiB.</dd>
<dt>
?
</dt>
<dd>:: In multi-threaded mode the sizes of the blocks are stored in the
block headers. This isn&#39;t done in single-threaded mode, so the encoded
output won&#39;t be identical to that of the multi-threaded mode.</dd>
<dt>
*–flush-timeout=*/timeout/
</dt>
<dd>When compressing, if more than
<em>timeout</em> milliseconds (a positive integer) has passed since the
previous flush and reading more input would block, all the pending
input data is flushed from the encoder and made available in the
output stream. This can be useful if <strong>xz</strong> is used to compress data
that is streamed over a network. Small <em>timeout</em> values make the data
available at the receiving end with a small delay, but large <em>timeout</em>
values give better compression ratio.</dd>
<dt>
?
</dt>
<dd>:: This feature is disabled by default. If this option is specified
more than once, the last one takes effect. The special <em>timeout</em> value
of <strong>0</strong> can be used to explicitly disable this feature.</dd>
<dt>
?
</dt>
<dd>:: This feature is not available on non-POSIX systems.</dd>
<dt>
?
</dt>
<dd>:: <strong>This feature is still experimental.</strong> Currently <strong>xz</strong> is unsuitable
for decompressing the stream in real time due to how <strong>xz</strong> does
buffering.</dd>
<dt>
*–memlimit-compress=*/limit/
</dt>
<dd>Set a memory usage limit for
compression. If this option is specified multiple times, the last one
takes effect.</dd>
<dt>
?
</dt>
<dd>:: If the compression settings exceed the <em>limit</em>, <strong>xz</strong> will attempt
to adjust the settings downwards so that the limit is no longer
exceeded and display a notice that automatic adjustment was done. The
adjustments are done in this order: reducing the number of threads,
switching to single-threaded mode if even one thread in multi-threaded
mode exceeds the <em>limit</em>, and finally reducing the LZMA2 dictionary
size.</dd>
<dt>
?
</dt>
<dd>:: When compressing with <strong>–format=raw</strong> or if <strong>–no-adjust</strong> has been
specified, only the number of threads may be reduced since it can be
done without affecting the compressed output.</dd>
<dt>
?
</dt>
<dd>:: If the <em>limit</em> cannot be met even with the adjustments described
above, an error is displayed and <strong>xz</strong> will exit with exit status 1.</dd>
<dt>
?
</dt>
<dd>
<p>:: The <em>limit</em> can be specified in multiple ways:</p>
<ul>
<li>The <em>limit</em> can be an absolute value in bytes. Using an integer
suffix like <strong>MiB</strong> can be useful. Example:
<strong>–memlimit-compress=80MiB</strong></li>
<li>The <em>limit</em> can be specified as a percentage of total physical
memory (RAM). This can be useful especially when setting the
<strong>XZ_DEFAULTS</strong> environment variable in a shell initialization script
that is shared between different computers. That way the limit is
automatically bigger on systems with more memory. Example:
<strong>–memlimit-compress=70%</strong></li>
<li>The <em>limit</em> can be reset back to its default value by setting it to
<strong>0</strong>. This is currently equivalent to setting the <em>limit</em> to <strong>max</strong>
(no memory usage limit).</li>
</ul>
</dd>
<dt>
?
</dt>
<dd>:: For 32-bit <strong>xz</strong> there is a special case: if the <em>limit</em> would be
over <strong>4020 MiB</strong>, the <em>limit</em> is set to <strong>4020 MiB</strong>. On MIPS32 <strong>2000
MiB</strong> is used instead. (The values <strong>0</strong> and <strong>max</strong> aren&#39;t affected by
this. A similar feature doesn&#39;t exist for decompression.) This can be
helpful when a 32-bit executable has access to 4 GiB address space (2
GiB on MIPS32) while hopefully doing no harm in other situations.</dd>
<dt>
?
</dt>
<dd>:: See also the section <strong>Memory usage</strong>.</dd>
<dt>
*–memlimit-decompress=*/limit/
</dt>
<dd>Set a memory usage limit for
decompression. This also affects the <strong>–list</strong> mode. If the operation
is not possible without exceeding the <em>limit</em>, <strong>xz</strong> will display an
error and decompressing the file will fail. See
*–memlimit-compress=*/limit/ for possible ways to specify the
<em>limit</em>.</dd>
<dt>
*–memlimit-mt-decompress=*/limit/
</dt>
<dd>Set a memory usage limit for
multi-threaded decompression. This can only affect the number of
threads; this will never make <strong>xz</strong> refuse to decompress a file. If
<em>limit</em> is too low to allow any multi-threading, the <em>limit</em> is
ignored and <strong>xz</strong> will continue in single-threaded mode. Note that if
also <strong>–memlimit-decompress</strong> is used, it will always apply to both
single-threaded and multi-threaded modes, and so the effective <em>limit</em>
for multi-threading will never be higher than the limit set with
<strong>–memlimit-decompress</strong>.</dd>
<dt>
?
</dt>
<dd>:: In contrast to the other memory usage limit options,
<strong>–memlimit-mt-decompress=*/limit/ has a system-specific default
<em>limit</em>. *xz –info-memory</strong> can be used to see the current value.</dd>
<dt>
?
</dt>
<dd>:: This option and its default value exist because without any limit
the threaded decompressor could end up allocating an insane amount of
memory with some input files. If the default <em>limit</em> is too low on
your system, feel free to increase the <em>limit</em> but never set it to a
value larger than the amount of usable RAM as with appropriate input
files <strong>xz</strong> will attempt to use that amount of memory even with a low
number of threads. Running out of memory or swapping will not improve
decompression performance.</dd>
<dt>
?
</dt>
<dd>:: See <strong>–memlimit-compress=*/limit/ for possible ways to specify the
<em>limit</em>. Setting <em>limit</em> to *0</strong> resets the <em>limit</em> to the default
system-specific value.</dd>
<dt>
<strong>-M</strong> <em>limit</em>, *–memlimit=*/limit/, *–memory=*/limit/
</dt>
<dd>This is
equivalent to specifying *–memlimit-compress=*/limit/
*–memlimit-decompress=*/limit/ *–memlimit-mt-decompress=*/limit/.</dd>
<dt>
<strong>–no-adjust</strong>
</dt>
<dd>Display an error and exit if the memory usage limit
cannot be met without adjusting settings that affect the compressed
output. That is, this prevents <strong>xz</strong> from switching the encoder from
multi-threaded mode to single-threaded mode and from reducing the
LZMA2 dictionary size. Even when this option is used the number of
threads may be reduced to meet the memory usage limit as that won&#39;t
affect the compressed output.</dd>
<dt>
?
</dt>
<dd>:: Automatic adjusting is always disabled when creating raw streams
(<strong>–format=raw</strong>).</dd>
<dt>
<strong>-T</strong> <em>threads</em>, *–threads=*/threads/
</dt>
<dd>Specify the number of worker
threads to use. Setting <em>threads</em> to a special value <strong>0</strong> makes <strong>xz</strong>
use up to as many threads as the processor(s) on the system support.
The actual number of threads can be fewer than <em>threads</em> if the input
file is not big enough for threading with the given settings or if
using more threads would exceed the memory usage limit.</dd>
<dt>
?
</dt>
<dd>:: The single-threaded and multi-threaded compressors produce
different output. Single-threaded compressor will give the smallest
file size but only the output from the multi-threaded compressor can
be decompressed using multiple threads. Setting <em>threads</em> to <strong>1</strong> will
use the single-threaded mode. Setting <em>threads</em> to any other value,
including <strong>0</strong>, will use the multi-threaded compressor even if the
system supports only one hardware thread. (<strong>xz</strong> 5.2.x used
single-threaded mode in this situation.)</dd>
<dt>
?
</dt>
<dd>:: To use multi-threaded mode with only one thread, set <em>threads</em> to
<strong>+1</strong>. The <strong>+</strong> prefix has no effect with values other than <strong>1</strong>. A
memory usage limit can still make <strong>xz</strong> switch to single-threaded mode
unless <strong>–no-adjust</strong> is used. Support for the <strong>+</strong> prefix was added in
<strong>xz</strong> 5.4.0.</dd>
<dt>
?
</dt>
<dd>:: If an automatic number of threads has been requested and no memory
usage limit has been specified, then a system-specific default soft
limit will be used to possibly limit the number of threads. It is a
soft limit in sense that it is ignored if the number of threads
becomes one, thus a soft limit will never stop <strong>xz</strong> from compressing
or decompressing. This default soft limit will not make <strong>xz</strong> switch
from multi-threaded mode to single-threaded mode. The active limits
can be seen with <strong>xz –info-memory</strong>.</dd>
<dt>
?
</dt>
<dd>:: Currently the only threading method is to split the input into
blocks and compress them independently from each other. The default
block size depends on the compression level and can be overridden with
the *–block-size=*/size/ option.</dd>
<dt>
?
</dt>
<dd>:: Threaded decompression only works on files that contain multiple
blocks with size information in block headers. All large enough files
compressed in multi-threaded mode meet this condition, but files
compressed in single-threaded mode don&#39;t even if *–block-size=*/size/
has been used.</dd>
<dt>
?
</dt>
<dd>:: The default value for <em>threads</em> is <strong>0</strong>. In <strong>xz</strong> 5.4.x and older
the default is <strong>1</strong>.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-12" class="outline-3">
<h3 id="headline-12">
Custom compressor filter chains
</h3>
<div id="outline-text-headline-12" class="outline-text-3">
<p>A custom filter chain allows specifying the compression settings in
detail instead of relying on the settings associated to the presets.
When a custom filter chain is specified, preset options (<strong>-0</strong> … <strong>-9</strong>
and <strong>–extreme</strong>) earlier on the command line are forgotten. If a preset
option is specified after one or more custom filter chain options, the
new preset takes effect and the custom filter chain options specified
earlier are forgotten.</p>
<p>
A filter chain is comparable to piping on the command line. When
compressing, the uncompressed input goes to the first filter, whose
output goes to the next filter (if any). The output of the last filter
gets written to the compressed file. The maximum number of filters in
the chain is four, but typically a filter chain has only one or two
filters.</p>
<p>
Many filters have limitations on where they can be in the filter chain:
some filters can work only as the last filter in the chain, some only as
a non-last filter, and some work in any position in the chain. Depending
on the filter, this limitation is either inherent to the filter design
or exists to prevent security issues.</p>
<p>
A custom filter chain can be specified in two different ways. The
options *–filters=*/filters/ and *–filters1=*/filters/ …
*–filters9=*/filters/ allow specifying an entire filter chain in one
option using the liblzma filter string syntax. Alternatively, a filter
chain can be specified by using one or more individual filter options in
the order they are wanted in the filter chain. That is, the order of the
individual filter options is significant! When decoding raw streams
(<strong>–format=raw</strong>), the filter chain must be specified in the same order
as it was specified when compressing. Any individual filter or preset
options specified before the full chain option (*–filters=*/filters/)
will be forgotten. Individual filters specified after the full chain
option will reset the filter chain.</p>
<p>
Both the full and individual filter options take filter-specific
<em>options</em> as a comma-separated list. Extra commas in <em>options</em> are
ignored. Every option has a default value, so specify those you want to
change.</p>
<p>
To see the whole filter chain and <em>options</em>, use <strong>xz -vv</strong> (that is, use
<strong>–verbose</strong> twice). This works also for viewing the filter chain options
used by presets.</p>
<dl>
<dt>
*–filters=*/filters/
</dt>
<dd>Specify the full filter chain or a preset in
a single option. Each filter can be separated by spaces or two dashes
(<strong>–</strong>). <em>filters</em> may need to be quoted on the shell command line so
it is parsed as a single option. To denote <em>options</em>, use <strong>:</strong> or <strong>=</strong>.
A preset can be prefixed with a <strong>-</strong> and followed with zero or more
flags. The only supported flag is <strong>e</strong> to apply the same options as
<strong>–extreme</strong>.</dd>
<dt>
*–filters1*=/filters/ … *–filters9*=/filters/
</dt>
<dd>Specify up to
nine additional filter chains that can be used with <strong>–block-list</strong>.</dd>
<dt>
?
</dt>
<dd>:: For example, when compressing an archive with executable files
followed by text files, the executable part could use a filter chain
with a BCJ filter and the text part only the LZMA2 filter.</dd>
<dt>
<strong>–filters-help</strong>
</dt>
<dd>Display a help message describing how to specify
presets and custom filter chains in the <strong>–filters</strong> and
*–filters1=*/filters/ … *–filters9=*/filters/ options, and exit
successfully.</dd>
<dt>
<strong>–lzma1</strong>[*=*/options/]
</dt>
<dd></dd>
<dt>
<strong>–lzma2</strong>[*=*/options/]
</dt>
<dd></dd>
</dl>
<p>Add LZMA1 or LZMA2 filter to the filter chain. These filters can be used
only as the last filter in the chain.</p>
<ul>
<li>:: LZMA1 is a legacy filter, which is supported almost solely due to
the legacy <strong>.lzma</strong> file format, which supports only LZMA1. LZMA2 is an
updated version of LZMA1 to fix some practical issues of LZMA1. The
<strong>.xz</strong> format uses LZMA2 and doesn&#39;t support LZMA1 at all. Compression
speed and ratios of LZMA1 and LZMA2 are practically the same.</li>
<li>
<p>:: LZMA1 and LZMA2 share the same set of <em>options</em>:</p>
<dl>
<dt>
*preset=*/preset/
</dt>
<dd>Reset all LZMA1 or LZMA2 <em>options</em> to <em>preset</em>.
<em>Preset</em> consist of an integer, which may be followed by
single-letter preset modifiers. The integer can be from <strong>0</strong> to <strong>9</strong>,
matching the command line options <strong>-0</strong> … <strong>-9</strong>. The only supported
modifier is currently <strong>e</strong>, which matches <strong>–extreme</strong>. If no <strong>preset</strong>
is specified, the default values of LZMA1 or LZMA2 <em>options</em> are
taken from the preset <strong>6</strong>.</dd>
<dt>
*dict=*/size/
</dt>
<dd>Dictionary (history buffer) <em>size</em> indicates how
many bytes of the recently processed uncompressed data is kept in
memory. The algorithm tries to find repeating byte sequences
(matches) in the uncompressed data, and replace them with references
to the data currently in the dictionary. The bigger the dictionary,
the higher is the chance to find a match. Thus, increasing
dictionary <em>size</em> usually improves compression ratio, but a
dictionary bigger than the uncompressed file is waste of memory.</dd>
<dt>
?
</dt>
<dd>:: Typical dictionary <em>size</em> is from 64 KiB to 64 MiB. The minimum
is 4 KiB. The maximum for compression is currently 1.5 GiB (1536
MiB). The decompressor already supports dictionaries up to one byte
less than 4 GiB, which is the maximum for the LZMA1 and LZMA2 stream
formats.</dd>
<dt>
?
</dt>
<dd>:: Dictionary <em>size</em> and match finder (<em>mf</em>) together determine the
memory usage of the LZMA1 or LZMA2 encoder. The same (or bigger)
dictionary <em>size</em> is required for decompressing that was used when
compressing, thus the memory usage of the decoder is determined by
the dictionary size used when compressing. The <strong>.xz</strong> headers store
the dictionary <em>size</em> either as 2^/n/ or 2^/n/ + 2^(<em>n</em>-1), so these
<em>sizes</em> are somewhat preferred for compression. Other <em>sizes</em> will
get rounded up when stored in the <strong>.xz</strong> headers.</dd>
<dt>
*lc=*/lc/
</dt>
<dd>Specify the number of literal context bits. The minimum
is 0 and the maximum is 4; the default is 3. In addition, the sum of
<em>lc</em> and <em>lp</em> must not exceed 4.</dd>
<dt>
?
</dt>
<dd>:: All bytes that cannot be encoded as matches are encoded as
literals. That is, literals are simply 8-bit bytes that are encoded
one at a time.</dd>
<dt>
?
</dt>
<dd>:: The literal coding makes an assumption that the highest <em>lc</em>
bits of the previous uncompressed byte correlate with the next byte.
For example, in typical English text, an upper-case letter is often
followed by a lower-case letter, and a lower-case letter is usually
followed by another lower-case letter. In the US-ASCII character
set, the highest three bits are 010 for upper-case letters and 011
for lower-case letters. When <em>lc</em> is at least 3, the literal coding
can take advantage of this property in the uncompressed data.</dd>
<dt>
?
</dt>
<dd>:: The default value (3) is usually good. If you want maximum
compression, test <strong>lc=4</strong>. Sometimes it helps a little, and sometimes
it makes compression worse. If it makes it worse, test <strong>lc=2</strong> too.</dd>
<dt>
*lp=*/lp/
</dt>
<dd>Specify the number of literal position bits. The
minimum is 0 and the maximum is 4; the default is 0.</dd>
<dt>
?
</dt>
<dd>:: <em>Lp</em> affects what kind of alignment in the uncompressed data is
assumed when encoding literals. See <em>pb</em> below for more information
about alignment.</dd>
<dt>
*pb=*/pb/
</dt>
<dd>Specify the number of position bits. The minimum is 0
and the maximum is 4; the default is 2.</dd>
<dt>
?
</dt>
<dd>:: <em>Pb</em> affects what kind of alignment in the uncompressed data is
assumed in general. The default means four-byte alignment
(2^/pb/=2^2=4), which is often a good choice when there&#39;s no better
guess.</dd>
<dt>
?
</dt>
<dd>:: When the alignment is known, setting <em>pb</em> accordingly may reduce
the file size a little. For example, with text files having one-byte
alignment (US-ASCII, ISO-8859-<strong>, UTF-8), setting *pb=0</strong> can improve
compression slightly. For UTF-16 text, <strong>pb=1</strong> is a good choice. If
the alignment is an odd number like 3 bytes, <strong>pb=0</strong> might be the
best choice.</dd>
<dt>
?
</dt>
<dd>:: Even though the assumed alignment can be adjusted with <em>pb</em> and
<em>lp</em>, LZMA1 and LZMA2 still slightly favor 16-byte alignment. It
might be worth taking into account when designing file formats that
are likely to be often compressed with LZMA1 or LZMA2.</dd>
<dt>
*mf=*/mf/
</dt>
<dd>Match finder has a major effect on encoder speed,
memory usage, and compression ratio. Usually Hash Chain match
finders are faster than Binary Tree match finders. The default
depends on the <em>preset</em>: 0 uses <strong>hc3</strong>, 1–3 use <strong>hc4</strong>, and the rest
use <strong>bt4</strong>.</dd>
<dt>
?
</dt>
<dd>
<p>:: The following match finders are supported. The memory usage
formulas below are rough approximations, which are closest to the
reality when <em>dict</em> is a power of two.</p>
<dl>
<dt>
<strong>hc3</strong>
</dt>
<dd>Hash Chain with 2- and 3-byte hashing<br>
Minimum value for <em>nice</em>: 3<br>
Memory usage:<br>
<em>dict</em> * 7.5 (if <em>dict</em> &lt;= 16 MiB);<br>
<em>dict</em> * 5.5 + 64 MiB (if <em>dict</em> &gt; 16 MiB)</dd>
<dt>
<strong>hc4</strong>
</dt>
<dd>Hash Chain with 2-, 3-, and 4-byte hashing<br>
Minimum value for <em>nice</em>: 4<br>
Memory usage:<br>
<em>dict</em> * 7.5 (if <em>dict</em> &lt;= 32 MiB);<br>
<em>dict</em> * 6.5 (if <em>dict</em> &gt; 32 MiB)</dd>
<dt>
<strong>bt2</strong>
</dt>
<dd>Binary Tree with 2-byte hashing<br>
Minimum value for <em>nice</em>: 2<br>
Memory usage: <em>dict</em> * 9.5</dd>
<dt>
<strong>bt3</strong>
</dt>
<dd>Binary Tree with 2- and 3-byte hashing<br>
Minimum value for <em>nice</em>: 3<br>
Memory usage:<br>
<em>dict</em> * 11.5 (if <em>dict</em> &lt;= 16 MiB);<br>
<em>dict</em> * 9.5 + 64 MiB (if <em>dict</em> &gt; 16 MiB)</dd>
<dt>
<strong>bt4</strong>
</dt>
<dd>Binary Tree with 2-, 3-, and 4-byte hashing<br>
Minimum value for <em>nice</em>: 4<br>
Memory usage:<br>
<em>dict</em> * 11.5 (if <em>dict</em> &lt;= 32 MiB);<br>
<em>dict</em> * 10.5 (if <em>dict</em> &gt; 32 MiB)</dd>
</dl>
</dd>
<dt>
*mode=*/mode/
</dt>
<dd>Compression <em>mode</em> specifies the method to analyze
the data produced by the match finder. Supported <em>modes</em> are <strong>fast</strong>
and <strong>normal</strong>. The default is <strong>fast</strong> for <em>presets</em> 0–3 and <strong>normal</strong>
for <em>presets</em> 4–9.</dd>
<dt>
?
</dt>
<dd>:: Usually <strong>fast</strong> is used with Hash Chain match finders and
<strong>normal</strong> with Binary Tree match finders. This is also what the
<em>presets</em> do.</dd>
<dt>
*nice=*/nice/
</dt>
<dd>Specify what is considered to be a nice length for
a match. Once a match of at least <em>nice</em> bytes is found, the
algorithm stops looking for possibly better matches.</dd>
<dt>
?
</dt>
<dd>:: <em>Nice</em> can be 2–273 bytes. Higher values tend to give better
compression ratio at the expense of speed. The default depends on
the <em>preset</em>.</dd>
<dt>
*depth=*/depth/
</dt>
<dd>Specify the maximum search depth in the match
finder. The default is the special value of 0, which makes the
compressor determine a reasonable <em>depth</em> from <em>mf</em> and <em>nice</em>.</dd>
<dt>
?
</dt>
<dd>:: Reasonable <em>depth</em> for Hash Chains is 4–100 and 16–1000 for
Binary Trees. Using very high values for <em>depth</em> can make the
encoder extremely slow with some files. Avoid setting the <em>depth</em>
over 1000 unless you are prepared to interrupt the compression in
case it is taking far too long.</dd>
</dl>
</li>
<li>:: When decoding raw streams (<strong>–format=raw</strong>), LZMA2 needs only the
dictionary <em>size</em>. LZMA1 needs also <em>lc</em>, <em>lp</em>, and <em>pb</em>.</li>
<li><strong>–x86</strong>[*=*/options/] :: </li>
<li><strong>–arm</strong>[*=*/options/] :: - <strong>–armthumb</strong>[*=*/options/] :: - <strong>–arm64</strong>[*=*/options/] :: - <strong>–powerpc</strong>[*=*/options/] :: - <strong>–ia64</strong>[*=*/options/] :: - <strong>–sparc</strong>[*=*/options/] :: - <strong>–riscv</strong>[*=*/options/] :: </li>
</ul>
<p>Add a branch/call/jump (BCJ) filter to the filter chain. These filters
can be used only as a non-last filter in the filter chain.</p>
<ul>
<li>:: A BCJ filter converts relative addresses in the machine code to
their absolute counterparts. This doesn&#39;t change the size of the data
but it increases redundancy, which can help LZMA2 to produce 0–15 %
smaller <strong>.xz</strong> file. The BCJ filters are always reversible, so using a
BCJ filter for wrong type of data doesn&#39;t cause any data loss,
although it may make the compression ratio slightly worse. The BCJ
filters are very fast and use an insignificant amount of memory.</li>
<li>
<p>:: These BCJ filters have known problems related to the compression
ratio:</p>
<ul>
<li>Some types of files containing executable code (for example, object
files, static libraries, and Linux kernel modules) have the
addresses in the instructions filled with filler values. These BCJ
filters will still do the address conversion, which will make the
compression worse with these files.</li>
<li>If a BCJ filter is applied on an archive, it is possible that it
makes the compression ratio worse than not using a BCJ filter. For
example, if there are similar or even identical executables then
filtering will likely make the files less similar and thus
compression is worse. The contents of non-executable files in the
same archive can matter too. In practice one has to try with and
without a BCJ filter to see which is better in each situation.</li>
</ul>
</li>
<li>
<p>:: Different instruction sets have different alignment: the
executable file must be aligned to a multiple of this value in the
input data to make the filter work.</p>
<blockquote>
<table>
<tbody>
<tr>
<td>Filter</td>
<td class="align-right">Alignment</td>
<td>Notes</td>
</tr>
<tr>
<td>x86</td>
<td class="align-right">1</td>
<td>32-bit or 64-bit x86</td>
</tr>
<tr>
<td>ARM</td>
<td class="align-right">4</td>
<td></td>
</tr>
<tr>
<td>ARM-Thumb</td>
<td class="align-right">2</td>
<td></td>
</tr>
<tr>
<td>ARM64</td>
<td class="align-right">4</td>
<td>4096-byte alignment is best</td>
</tr>
<tr>
<td>PowerPC</td>
<td class="align-right">4</td>
<td>Big endian only</td>
</tr>
<tr>
<td>IA-64</td>
<td class="align-right">16</td>
<td>Itanium</td>
</tr>
<tr>
<td>SPARC</td>
<td class="align-right">4</td>
<td></td>
</tr>
<tr>
<td>RISC-V</td>
<td class="align-right">2</td>
<td></td>
</tr>
</tbody>
</table>
</blockquote>
</li>
<li>
<p>:: Since the BCJ-filtered data is usually compressed with LZMA2, the
compression ratio may be improved slightly if the LZMA2 options are
set to match the alignment of the selected BCJ filter. Examples:</p>
<ul>
<li>IA-64 filter has 16-byte alignment so <strong>pb=4,lp=4,lc=0</strong> is good with
LZMA2 (2^4=16).</li>
<li>RISC-V code has 2-byte or 4-byte alignment depending on whether the
file contains 16-bit compressed instructions (the C extension). When
16-bit instructions are used, <strong>pb=2,lp=1,lc=3</strong> or <strong>pb=1,lp=1,lc=3</strong>
is good. When 16-bit instructions aren&#39;t present, <strong>pb=2,lp=2,lc=2</strong>
is the best. <strong>readelf -h</strong> can be used to check if &#34;RVC&#34; appears on
the &#34;Flags&#34; line.</li>
<li>ARM64 is always 4-byte aligned so <strong>pb=2,lp=2,lc=2</strong> is the best.</li>
<li>The x86 filter is an exception. It&#39;s usually good to stick to
LZMA2&#39;s defaults (<strong>pb=2,lp=0,lc=3</strong>) when compressing x86
executables.</li>
</ul>
</li>
<li>
<p>:: All BCJ filters support the same <em>options</em>:</p>
<dl>
<dt>
*start=*/offset/
</dt>
<dd>Specify the start <em>offset</em> that is used when
converting between relative and absolute addresses. The <em>offset</em>
must be a multiple of the alignment of the filter (see the table
above). The default is zero. In practice, the default is good;
specifying a custom <em>offset</em> is almost never useful.</dd>
</dl>
</li>
<li><strong>–delta</strong>[*=*/options/] :: Add the Delta filter to the filter chain.
The Delta filter can be only used as a non-last filter in the filter
chain.</li>
<li>:: Currently only simple byte-wise delta calculation is supported. It
can be useful when compressing, for example, uncompressed bitmap
images or uncompressed PCM audio. However, special purpose algorithms
may give significantly better results than Delta + LZMA2. This is true
especially with audio, which compresses faster and better, for
example, with *flac*(1).</li>
<li>
<p>:: Supported <em>options</em>:</p>
<dl>
<dt>
*dist=*/distance/
</dt>
<dd>Specify the <em>distance</em> of the delta calculation
in bytes. <em>distance</em> must be 1–256. The default is 1.</dd>
<dt>
?
</dt>
<dd>:: For example, with <strong>dist=2</strong> and eight-byte input A1 B1 A2 B3 A3
B5 A4 B7, the output will be A1 B1 01 02 01 02 01 02.</dd>
</dl>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-13" class="outline-3">
<h3 id="headline-13">
Other options
</h3>
<div id="outline-text-headline-13" class="outline-text-3">
<dl>
<dt>
<strong>-q</strong>, <strong>–quiet</strong>
</dt>
<dd>Suppress warnings and notices. Specify this twice
to suppress errors too. This option has no effect on the exit status.
That is, even if a warning was suppressed, the exit status to indicate
a warning is still used.</dd>
<dt>
<strong>-v</strong>, <strong>–verbose</strong>
</dt>
<dd>Be verbose. If standard error is connected to a
terminal, <strong>xz</strong> will display a progress indicator. Specifying
<strong>–verbose</strong> twice will give even more verbose output.</dd>
<dt>
?
</dt>
<dd>
<p>:: The progress indicator shows the following information:</p>
<ul>
<li>Completion percentage is shown if the size of the input file is
known. That is, the percentage cannot be shown in pipes.</li>
<li>Amount of compressed data produced (compressing) or consumed
(decompressing).</li>
<li>Amount of uncompressed data consumed (compressing) or produced
(decompressing).</li>
<li>Compression ratio, which is calculated by dividing the amount of
compressed data processed so far by the amount of uncompressed data
processed so far.</li>
<li>Compression or decompression speed. This is measured as the amount
of uncompressed data consumed (compression) or produced
(decompression) per second. It is shown after a few seconds have
passed since <strong>xz</strong> started processing the file.</li>
<li>Elapsed time in the format M:SS or H:MM:SS.</li>
<li>Estimated remaining time is shown only when the size of the input
file is known and a couple of seconds have already passed since <strong>xz</strong>
started processing the file. The time is shown in a less precise
format which never has any colons, for example, 2 min 30 s.</li>
</ul>
</dd>
<dt>
?
</dt>
<dd>:: When standard error is not a terminal, <strong>–verbose</strong> will make <strong>xz</strong>
print the filename, compressed size, uncompressed size, compression
ratio, and possibly also the speed and elapsed time on a single line
to standard error after compressing or decompressing the file. The
speed and elapsed time are included only when the operation took at
least a few seconds. If the operation didn&#39;t finish, for example, due
to user interruption, also the completion percentage is printed if the
size of the input file is known.</dd>
<dt>
<strong>-Q</strong>, <strong>–no-warn</strong>
</dt>
<dd>Don&#39;t set the exit status to 2 even if a
condition worth a warning was detected. This option doesn&#39;t affect the
verbosity level, thus both <strong>–quiet</strong> and <strong>–no-warn</strong> have to be used
to not display warnings and to not alter the exit status.</dd>
<dt>
<strong>–robot</strong>
</dt>
<dd>Print messages in a machine-parsable format. This is
intended to ease writing frontends that want to use <strong>xz</strong> instead of
liblzma, which may be the case with various scripts. The output with
this option enabled is meant to be stable across <strong>xz</strong> releases. See
the section <strong>ROBOT MODE</strong> for details.</dd>
<dt>
<strong>–info-memory</strong>
</dt>
<dd>Display, in human-readable format, how much
physical memory (RAM) and how many processor threads <strong>xz</strong> thinks the
system has and the memory usage limits for compression and
decompression, and exit successfully.</dd>
<dt>
<strong>-h</strong>, <strong>–help</strong>
</dt>
<dd>Display a help message describing the most commonly
used options, and exit successfully.</dd>
<dt>
<strong>-H</strong>, <strong>–long-help</strong>
</dt>
<dd>Display a help message describing all features
of <strong>xz</strong>, and exit successfully</dd>
<dt>
<strong>-V</strong>, <strong>–version</strong>
</dt>
<dd>Display the version number of <strong>xz</strong> and liblzma in
human readable format. To get machine-parsable output, specify
<strong>–robot</strong> before <strong>–version</strong>.</dd>
</dl>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-14" class="outline-2">
<h2 id="headline-14">
ROBOT MODE
</h2>
<div id="outline-text-headline-14" class="outline-text-2">
<p>The robot mode is activated with the <strong>–robot</strong> option. It makes the
output of <strong>xz</strong> easier to parse by other programs. Currently <strong>–robot</strong> is
supported only together with <strong>–list</strong>, <strong>–filters-help</strong>,
<strong>–info-memory</strong>, and <strong>–version</strong>. It will be supported for compression
and decompression in the future.</p>
<div id="outline-container-headline-15" class="outline-3">
<h3 id="headline-15">
List mode
</h3>
<div id="outline-text-headline-15" class="outline-text-3">
<p><strong>xz –robot –list</strong> uses tab-separated output. The first column of every
line has a string that indicates the type of the information found on
that line:</p>
<dl>
<dt>
<strong>name</strong>
</dt>
<dd>This is always the first line when starting to list a file.
The second column on the line is the filename.</dd>
<dt>
<strong>file</strong>
</dt>
<dd>This line contains overall information about the <strong>.xz</strong> file.
This line is always printed after the <strong>name</strong> line.</dd>
<dt>
<strong>stream</strong>
</dt>
<dd>This line type is used only when <strong>–verbose</strong> was
specified. There are as many <strong>stream</strong> lines as there are streams in
the <strong>.xz</strong> file.</dd>
<dt>
<strong>block</strong>
</dt>
<dd>This line type is used only when <strong>–verbose</strong> was specified.
There are as many <strong>block</strong> lines as there are blocks in the <strong>.xz</strong> file.
The <strong>block</strong> lines are shown after all the <strong>stream</strong> lines; different
line types are not interleaved.</dd>
<dt>
<strong>summary</strong>
</dt>
<dd>This line type is used only when <strong>–verbose</strong> was
specified twice. This line is printed after all <strong>block</strong> lines. Like
the <strong>file</strong> line, the <strong>summary</strong> line contains overall information about
the <strong>.xz</strong> file.</dd>
<dt>
<strong>totals</strong>
</dt>
<dd>This line is always the very last line of the list output.
It shows the total counts and sizes.</dd>
</dl>
<p>The columns of the <strong>file</strong> lines:</p>
<blockquote>
<ol>
<li value="2">Number of streams in the file</li>
<li>Total number of blocks in the stream(s)</li>
<li>Compressed size of the file</li>
<li>Uncompressed size of the file</li>
<li>Compression ratio, for example, <strong>0.123</strong>. If ratio is over 9.999,
three dashes (<strong>—</strong>) are displayed instead of the ratio.</li>
<li>Comma-separated list of integrity check names. The following strings
are used for the known check types: <strong>None</strong>, <strong>CRC32</strong>, <strong>CRC64</strong>, and
<strong>SHA-256</strong>. For unknown check types, *Unknown-*/N/ is used, where <em>N</em>
is the Check ID as a decimal number (one or two digits).</li>
<li>Total size of stream padding in the file</li>
</ol>
</blockquote>
<p>
The columns of the <strong>stream</strong> lines:</p>
<blockquote>
<ol>
<li value="2">Stream number (the first stream is 1)</li>
<li>Number of blocks in the stream</li>
<li>Compressed start offset</li>
<li>Uncompressed start offset</li>
<li>Compressed size (does not include stream padding)</li>
<li>Uncompressed size</li>
<li>Compression ratio</li>
<li>Name of the integrity check</li>
<li>Size of stream padding</li>
</ol>
</blockquote>
<p>
The columns of the <strong>block</strong> lines:</p>
<blockquote>
<ol>
<li value="2">Number of the stream containing this block</li>
<li>Block number relative to the beginning of the stream (the first block
is 1)</li>
<li>Block number relative to the beginning of the file</li>
<li>Compressed start offset relative to the beginning of the file</li>
<li>Uncompressed start offset relative to the beginning of the file</li>
<li>Total compressed size of the block (includes headers)</li>
<li>Uncompressed size</li>
<li>Compression ratio</li>
<li>Name of the integrity check</li>
</ol>
</blockquote>
<p>
If <strong>–verbose</strong> was specified twice, additional columns are included on
the <strong>block</strong> lines. These are not displayed with a single <strong>–verbose</strong>,
because getting this information requires many seeks and can thus be
slow:</p>
<blockquote>
<ol>
<li value="11">Value of the integrity check in hexadecimal</li>
<li>Block header size</li>
<li>Block flags: <strong>c</strong> indicates that compressed size is present, and <strong>u</strong>
indicates that uncompressed size is present. If the flag is not set,
a dash (<strong>-</strong>) is shown instead to keep the string length fixed. New
flags may be added to the end of the string in the future.</li>
<li>Size of the actual compressed data in the block (this excludes the
block header, block padding, and check fields)</li>
<li>Amount of memory (in bytes) required to decompress this block with
this <strong>xz</strong> version</li>
<li>Filter chain. Note that most of the options used at compression time
cannot be known, because only the options that are needed for
decompression are stored in the <strong>.xz</strong> headers.</li>
</ol>
</blockquote>
<p>
The columns of the <strong>summary</strong> lines:</p>
<blockquote>
<ol>
<li value="2">Amount of memory (in bytes) required to decompress this file
with this <strong>xz</strong> version</li>
<li><strong>yes</strong> or <strong>no</strong> indicating if all block headers have both compressed
size and uncompressed size stored in them</li>
</ol>
<p><em>Since</em> <strong>xz</strong> <em>5.1.2alpha:</em></p>
<ol>
<li value="4">Minimum <strong>xz</strong> version required to decompress the file</li>
</ol>
</blockquote>
<p>
The columns of the <strong>totals</strong> line:</p>
<blockquote>
<ol>
<li value="2">Number of streams</li>
<li>Number of blocks</li>
<li>Compressed size</li>
<li>Uncompressed size</li>
<li>Average compression ratio</li>
<li>Comma-separated list of integrity check names that were present in
the files</li>
<li>Stream padding size</li>
<li>Number of files. This is here to keep the order of the earlier
columns the same as on <strong>file</strong> lines.</li>
</ol>
</blockquote>
<p>
If <strong>–verbose</strong> was specified twice, additional columns are included on
the <strong>totals</strong> line:</p>
<blockquote>
<ol>
<li value="10">Maximum amount of memory (in bytes) required to decompress the
files with this <strong>xz</strong> version</li>
<li><strong>yes</strong> or <strong>no</strong> indicating if all block headers have both compressed
size and uncompressed size stored in them</li>
</ol>
<p><em>Since</em> <strong>xz</strong> <em>5.1.2alpha:</em></p>
<ol>
<li value="12">Minimum <strong>xz</strong> version required to decompress the file</li>
</ol>
</blockquote>
<p>
Future versions may add new line types and new columns can be added to
the existing line types, but the existing columns won&#39;t be changed.</p>
</div>
</div>
<div id="outline-container-headline-16" class="outline-3">
<h3 id="headline-16">
Filters help
</h3>
<div id="outline-text-headline-16" class="outline-text-3">
<p><strong>xz –robot –filters-help</strong> prints the supported filters in the
following format:</p>
<p>
/filter/*:*/option/*=&lt;*/value/*&gt;,*/option/*=&lt;*/value/*&gt;*…</p>
<dl>
<dt>
<em>filter</em>
</dt>
<dd>Name of the filter</dd>
<dt>
<em>option</em>
</dt>
<dd>Name of a filter specific option</dd>
<dt>
<em>value</em>
</dt>
<dd>Numeric <em>value</em> ranges appear as <strong>&lt;*/min/</strong>-<strong>/max/*&gt;</strong>.
String <em>value</em> choices are shown within <strong>&lt; &gt;</strong> and separated by a <strong>|</strong>
character.</dd>
</dl>
<p>Each filter is printed on its own line.</p>
</div>
</div>
<div id="outline-container-headline-17" class="outline-3">
<h3 id="headline-17">
Memory limit information
</h3>
<div id="outline-text-headline-17" class="outline-text-3">
<p><strong>xz –robot –info-memory</strong> prints a single line with multiple
tab-separated columns:</p>
<ol>
<li>Total amount of physical memory (RAM) in bytes.</li>
<li>Memory usage limit for compression in bytes (<strong>–memlimit-compress</strong>).
A special value of <strong>0</strong> indicates the default setting which for
single-threaded mode is the same as no limit.</li>
<li>Memory usage limit for decompression in bytes
(<strong>–memlimit-decompress</strong>). A special value of <strong>0</strong> indicates the
default setting which for single-threaded mode is the same as no
limit.</li>
<li>Since <strong>xz</strong> 5.3.4alpha: Memory usage for multi-threaded decompression
in bytes (<strong>–memlimit-mt-decompress</strong>). This is never zero because a
system-specific default value shown in the column 5 is used if no
limit has been specified explicitly. This is also never greater than
the value in the column 3 even if a larger value has been specified
with <strong>–memlimit-mt-decompress</strong>.</li>
<li>Since <strong>xz</strong> 5.3.4alpha: A system-specific default memory usage limit
that is used to limit the number of threads when compressing with an
automatic number of threads (<strong>–threads=0</strong>) and no memory usage limit
has been specified (<strong>–memlimit-compress</strong>). This is also used as the
default value for <strong>–memlimit-mt-decompress</strong>.</li>
<li>Since <strong>xz</strong> 5.3.4alpha: Number of available processor threads.</li>
</ol>
<p>In the future, the output of <strong>xz –robot –info-memory</strong> may have more
columns, but never more than a single line.</p>
</div>
</div>
<div id="outline-container-headline-18" class="outline-3">
<h3 id="headline-18">
Version
</h3>
<div id="outline-text-headline-18" class="outline-text-3">
<p><strong>xz –robot –version</strong> prints the version number of <strong>xz</strong> and liblzma in
the following format:</p>
<p>
*XZ_VERSION=*/XYYYZZZS/<br>
*LIBLZMA_VERSION=*/XYYYZZZS/</p>
<dl>
<dt>
<em>X</em>
</dt>
<dd>Major version.</dd>
<dt>
<em>YYY</em>
</dt>
<dd>Minor version. Even numbers are stable. Odd numbers are alpha
or beta versions.</dd>
<dt>
<em>ZZZ</em>
</dt>
<dd>Patch level for stable releases or just a counter for
development releases.</dd>
<dt>
<em>S</em>
</dt>
<dd>Stability. 0 is alpha, 1 is beta, and 2 is stable. <em>S</em> should
be always 2 when <em>YYY</em> is even.</dd>
</dl>
<p><em>XYYYZZZS</em> are the same on both lines if <strong>xz</strong> and liblzma are from the
same XZ Utils release.</p>
<p>
Examples: 4.999.9beta is <strong>49990091</strong> and 5.0.0 is <strong>50000002</strong>.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-19" class="outline-2">
<h2 id="headline-19">
EXIT STATUS
</h2>
<div id="outline-text-headline-19" class="outline-text-2">
<dl>
<dt>
<strong>0</strong>
</dt>
<dd>All is good.</dd>
<dt>
<strong>1</strong>
</dt>
<dd>An error occurred.</dd>
<dt>
<strong>2</strong>
</dt>
<dd>Something worth a warning occurred, but no actual errors
occurred.</dd>
</dl>
<p>Notices (not warnings or errors) printed on standard error don&#39;t affect
the exit status.</p>
</div>
</div>
<div id="outline-container-headline-20" class="outline-2">
<h2 id="headline-20">
ENVIRONMENT
</h2>
<div id="outline-text-headline-20" class="outline-text-2">
<p><strong>xz</strong> parses space-separated lists of options from the environment
variables <strong>XZ_DEFAULTS</strong> and <strong>XZ_OPT</strong>, in this order, before parsing the
options from the command line. Note that only options are parsed from
the environment variables; all non-options are silently ignored. Parsing
is done with *getopt_long*(3) which is used also for the command line
arguments.</p>
<dl>
<dt>
<strong>XZ_DEFAULTS</strong>
</dt>
<dd>User-specific or system-wide default options.
Typically this is set in a shell initialization script to enable
<strong>xz</strong>&#39;s memory usage limiter by default. Excluding shell initialization
scripts and similar special cases, scripts must never set or unset
<strong>XZ_DEFAULTS</strong>.</dd>
<dt>
<strong>XZ_OPT</strong>
</dt>
<dd>
<p>This is for passing options to <strong>xz</strong> when it is not
possible to set the options directly on the <strong>xz</strong> command line. This is
the case when <strong>xz</strong> is run by a script or tool, for example, GNU
*tar*(1):</p>
<blockquote>
<pre class="example">
XZ_OPT=-2v tar caf foo.tar.xz foo
</pre>
</blockquote>
</dd>
<dt>
?
</dt>
<dd>
<p>:: Scripts may use <strong>XZ_OPT</strong>, for example, to set script-specific
default compression options. It is still recommended to allow users to
override <strong>XZ_OPT</strong> if that is reasonable. For example, in *sh*(1)
scripts one may use something like this:</p>
<blockquote>
<pre class="example">
XZ_OPT=${XZ_OPT-&#34;-7e&#34;}
export XZ_OPT
</pre>
</blockquote>
</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-21" class="outline-2">
<h2 id="headline-21">
LZMA UTILS COMPATIBILITY
</h2>
<div id="outline-text-headline-21" class="outline-text-2">
<p>The command line syntax of <strong>xz</strong> is practically a superset of <strong>lzma</strong>,
<strong>unlzma</strong>, and <strong>lzcat</strong> as found from LZMA Utils 4.32.x. In most cases, it
is possible to replace LZMA Utils with XZ Utils without breaking
existing scripts. There are some incompatibilities though, which may
sometimes cause problems.</p>
<div id="outline-container-headline-22" class="outline-3">
<h3 id="headline-22">
Compression preset levels
</h3>
<div id="outline-text-headline-22" class="outline-text-3">
<p>The numbering of the compression level presets is not identical in <strong>xz</strong>
and LZMA Utils. The most important difference is how dictionary sizes
are mapped to different presets. Dictionary size is roughly equal to the
decompressor memory usage.</p>
<blockquote>
<table>
<tbody>
<tr>
<td class="align-right">Level</td>
<td>xz</td>
<td>LZMA Utils</td>
</tr>
<tr>
<td class="align-right">-0</td>
<td>256 KiB</td>
<td>N/A</td>
</tr>
<tr>
<td class="align-right">-1</td>
<td>1 MiB</td>
<td>64 KiB</td>
</tr>
<tr>
<td class="align-right">-2</td>
<td>2 MiB</td>
<td>1 MiB</td>
</tr>
<tr>
<td class="align-right">-3</td>
<td>4 MiB</td>
<td>512 KiB</td>
</tr>
<tr>
<td class="align-right">-4</td>
<td>4 MiB</td>
<td>1 MiB</td>
</tr>
<tr>
<td class="align-right">-5</td>
<td>8 MiB</td>
<td>2 MiB</td>
</tr>
<tr>
<td class="align-right">-6</td>
<td>8 MiB</td>
<td>4 MiB</td>
</tr>
<tr>
<td class="align-right">-7</td>
<td>16 MiB</td>
<td>8 MiB</td>
</tr>
<tr>
<td class="align-right">-8</td>
<td>32 MiB</td>
<td>16 MiB</td>
</tr>
<tr>
<td class="align-right">-9</td>
<td>64 MiB</td>
<td>32 MiB</td>
</tr>
</tbody>
</table>
</blockquote>
<p>
The dictionary size differences affect the compressor memory usage too,
but there are some other differences between LZMA Utils and XZ Utils,
which make the difference even bigger:</p>
<blockquote>
<table>
<tbody>
<tr>
<td class="align-right">Level</td>
<td>xz</td>
<td>LZMA Utils 4.32.x</td>
</tr>
<tr>
<td class="align-right">-0</td>
<td>3 MiB</td>
<td>N/A</td>
</tr>
<tr>
<td class="align-right">-1</td>
<td>9 MiB</td>
<td>2 MiB</td>
</tr>
<tr>
<td class="align-right">-2</td>
<td>17 MiB</td>
<td>12 MiB</td>
</tr>
<tr>
<td class="align-right">-3</td>
<td>32 MiB</td>
<td>12 MiB</td>
</tr>
<tr>
<td class="align-right">-4</td>
<td>48 MiB</td>
<td>16 MiB</td>
</tr>
<tr>
<td class="align-right">-5</td>
<td>94 MiB</td>
<td>26 MiB</td>
</tr>
<tr>
<td class="align-right">-6</td>
<td>94 MiB</td>
<td>45 MiB</td>
</tr>
<tr>
<td class="align-right">-7</td>
<td>186 MiB</td>
<td>83 MiB</td>
</tr>
<tr>
<td class="align-right">-8</td>
<td>370 MiB</td>
<td>159 MiB</td>
</tr>
<tr>
<td class="align-right">-9</td>
<td>674 MiB</td>
<td>311 MiB</td>
</tr>
</tbody>
</table>
</blockquote>
<p>
The default preset level in LZMA Utils is <strong>-7</strong> while in XZ Utils it is
<strong>-6</strong>, so both use an 8 MiB dictionary by default.</p>
</div>
</div>
<div id="outline-container-headline-23" class="outline-3">
<h3 id="headline-23">
Streamed vs. non-streamed .lzma files
</h3>
<div id="outline-text-headline-23" class="outline-text-3">
<p>The uncompressed size of the file can be stored in the <strong>.lzma</strong> header.
LZMA Utils does that when compressing regular files. The alternative is
to mark that uncompressed size is unknown and use end-of-payload marker
to indicate where the decompressor should stop. LZMA Utils uses this
method when uncompressed size isn&#39;t known, which is the case, for
example, in pipes.</p>
<p>
<strong>xz</strong> supports decompressing <strong>.lzma</strong> files with or without end-of-payload
marker, but all <strong>.lzma</strong> files created by <strong>xz</strong> will use end-of-payload
marker and have uncompressed size marked as unknown in the <strong>.lzma</strong>
header. This may be a problem in some uncommon situations. For example,
a <strong>.lzma</strong> decompressor in an embedded device might work only with files
that have known uncompressed size. If you hit this problem, you need to
use LZMA Utils or LZMA SDK to create <strong>.lzma</strong> files with known
uncompressed size.</p>
</div>
</div>
<div id="outline-container-headline-24" class="outline-3">
<h3 id="headline-24">
Unsupported .lzma files
</h3>
<div id="outline-text-headline-24" class="outline-text-3">
<p>The <strong>.lzma</strong> format allows <em>lc</em> values up to 8, and <em>lp</em> values up to 4.
LZMA Utils can decompress files with any <em>lc</em> and <em>lp</em>, but always
creates files with <strong>lc=3</strong> and <strong>lp=0</strong>. Creating files with other <em>lc</em> and
<em>lp</em> is possible with <strong>xz</strong> and with LZMA SDK.</p>
<p>
The implementation of the LZMA1 filter in liblzma requires that the sum
of <em>lc</em> and <em>lp</em> must not exceed 4. Thus, <strong>.lzma</strong> files, which exceed
this limitation, cannot be decompressed with <strong>xz</strong>.</p>
<p>
LZMA Utils creates only <strong>.lzma</strong> files which have a dictionary size of
2^/n/ (a power of 2) but accepts files with any dictionary size. liblzma
accepts only <strong>.lzma</strong> files which have a dictionary size of 2^/n/ or
2^/n/ + 2^(<em>n</em>-1). This is to decrease false positives when detecting
<strong>.lzma</strong> files.</p>
<p>
These limitations shouldn&#39;t be a problem in practice, since practically
all <strong>.lzma</strong> files have been compressed with settings that liblzma will
accept.</p>
</div>
</div>
<div id="outline-container-headline-25" class="outline-3">
<h3 id="headline-25">
Trailing garbage
</h3>
<div id="outline-text-headline-25" class="outline-text-3">
<p>When decompressing, LZMA Utils silently ignore everything after the
first <strong>.lzma</strong> stream. In most situations, this is a bug. This also means
that LZMA Utils don&#39;t support decompressing concatenated <strong>.lzma</strong> files.</p>
<p>
If there is data left after the first <strong>.lzma</strong> stream, <strong>xz</strong> considers the
file to be corrupt unless <strong>–single-stream</strong> was used. This may break
obscure scripts which have assumed that trailing garbage is ignored.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-26" class="outline-2">
<h2 id="headline-26">
NOTES
</h2>
<div id="outline-text-headline-26" class="outline-text-2">
<div id="outline-container-headline-27" class="outline-3">
<h3 id="headline-27">
Compressed output may vary
</h3>
<div id="outline-text-headline-27" class="outline-text-3">
<p>The exact compressed output produced from the same uncompressed input
file may vary between XZ Utils versions even if compression options are
identical. This is because the encoder can be improved (faster or better
compression) without affecting the file format. The output can vary even
between different builds of the same XZ Utils version, if different
build options are used.</p>
<p>
The above means that once <strong>–rsyncable</strong> has been implemented, the
resulting files won&#39;t necessarily be rsyncable unless both old and new
files have been compressed with the same xz version. This problem can be
fixed if a part of the encoder implementation is frozen to keep
rsyncable output stable across xz versions.</p>
</div>
</div>
<div id="outline-container-headline-28" class="outline-3">
<h3 id="headline-28">
Embedded .xz decompressors
</h3>
<div id="outline-text-headline-28" class="outline-text-3">
<p>Embedded <strong>.xz</strong> decompressor implementations like XZ Embedded don&#39;t
necessarily support files created with integrity <em>check</em> types other
than <strong>none</strong> and <strong>crc32</strong>. Since the default is <strong>–check=crc64</strong>, you must
use <strong>–check=none</strong> or <strong>–check=crc32</strong> when creating files for embedded
systems.</p>
<p>
Outside embedded systems, all <strong>.xz</strong> format decompressors support all the
<em>check</em> types, or at least are able to decompress the file without
verifying the integrity check if the particular <em>check</em> is not
supported.</p>
<p>
XZ Embedded supports BCJ filters, but only with the default start
offset.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-29" class="outline-2">
<h2 id="headline-29">
EXAMPLES
</h2>
<div id="outline-text-headline-29" class="outline-text-2">
<div id="outline-container-headline-30" class="outline-3">
<h3 id="headline-30">
Basics
</h3>
<div id="outline-text-headline-30" class="outline-text-3">
<p>Compress the file <em>foo</em> into <em>foo.xz</em> using the default compression
level (<strong>-6</strong>), and remove <em>foo</em> if compression is successful:</p>
<blockquote>
<pre class="example">
xz foo
</pre>
</blockquote>
<p>
Decompress <em>bar.xz</em> into <em>bar</em> and don&#39;t remove <em>bar.xz</em> even if
decompression is successful:</p>
<blockquote>
<pre class="example">
xz -dk bar.xz
</pre>
</blockquote>
<p>
Create <em>baz.tar.xz</em> with the preset <strong>-4e</strong> (<strong>-4 –extreme</strong>), which is
slower than the default <strong>-6</strong>, but needs less memory for compression and
decompression (48 MiB and 5 MiB, respectively):</p>
<blockquote>
<pre class="example">
tar cf - baz | xz -4e &gt; baz.tar.xz
</pre>
</blockquote>
<p>
A mix of compressed and uncompressed files can be decompressed to
standard output with a single command:</p>
<blockquote>
<pre class="example">
xz -dcf a.txt b.txt.xz c.txt d.txt.lzma &gt; abcd.txt
</pre>
</blockquote>
</div>
</div>
<div id="outline-container-headline-31" class="outline-3">
<h3 id="headline-31">
Parallel compression of many files
</h3>
<div id="outline-text-headline-31" class="outline-text-3">
<p>On GNU and *BSD, *find*(1) and *xargs*(1) can be used to parallelize
compression of many files:</p>
<blockquote>
<pre class="example">
find . -type f \! -name &#39;*.xz&#39; -print0 \
    | xargs -0r -P4 -n16 xz -T1
</pre>
</blockquote>
<p>
The <strong>-P</strong> option to <strong>xargs*(1) sets the number of parallel *xz</strong>
processes. The best value for the <strong>-n</strong> option depends on how many files
there are to be compressed. If there are only a couple of files, the
value should probably be 1; with tens of thousands of files, 100 or even
more may be appropriate to reduce the number of <strong>xz</strong> processes that
*xargs*(1) will eventually create.</p>
<p>
The option <strong>-T1</strong> for <strong>xz</strong> is there to force it to single-threaded mode,
because *xargs*(1) is used to control the amount of parallelization.</p>
</div>
</div>
<div id="outline-container-headline-32" class="outline-3">
<h3 id="headline-32">
Robot mode
</h3>
<div id="outline-text-headline-32" class="outline-text-3">
<p>Calculate how many bytes have been saved in total after compressing
multiple files:</p>
<blockquote>
<pre class="example">
xz --robot --list *.xz | awk &#39;/^totals/{print $5-$4}&#39;
</pre>
</blockquote>
<p>
A script may want to know that it is using new enough <strong>xz</strong>. The
following <strong>sh*(1) script checks that the version number of the *xz</strong> tool
is at least 5.0.0. This method is compatible with old beta versions,
which didn&#39;t support the <strong>–robot</strong> option:</p>
<blockquote>
<pre class="example">
if ! eval &#34;$(xz --robot --version 2&gt; /dev/null)&#34; ||
        [ &#34;$XZ_VERSION&#34; -lt 50000002 ]; then
    echo &#34;Your xz is too old.&#34;
fi
unset XZ_VERSION LIBLZMA_VERSION
</pre>
</blockquote>
<p>
Set a memory usage limit for decompression using <strong>XZ_OPT</strong>, but if a
limit has already been set, don&#39;t increase it:</p>
<blockquote>
<pre class="example">
NEWLIM=$((123 &lt;&lt; 20))  # 123 MiB
OLDLIM=$(xz --robot --info-memory | cut -f3)
if [ $OLDLIM -eq 0 -o $OLDLIM -gt $NEWLIM ]; then
    XZ_OPT=&#34;$XZ_OPT --memlimit-decompress=$NEWLIM&#34;
    export XZ_OPT
fi
</pre>
</blockquote>
</div>
</div>
<div id="outline-container-headline-33" class="outline-3">
<h3 id="headline-33">
Custom compressor filter chains
</h3>
<div id="outline-text-headline-33" class="outline-text-3">
<p>The simplest use for custom filter chains is customizing a LZMA2 preset.
This can be useful, because the presets cover only a subset of the
potentially useful combinations of compression settings.</p>
<p>
The CompCPU columns of the tables from the descriptions of the options
<strong>-0</strong> … <strong>-9</strong> and <strong>–extreme</strong> are useful when customizing LZMA2 presets.
Here are the relevant parts collected from those two tables:</p>
<blockquote>
<table>
<tbody>
<tr>
<td class="align-right">Preset</td>
<td class="align-right">CompCPU</td>
</tr>
<tr>
<td class="align-right">-0</td>
<td class="align-right">0</td>
</tr>
<tr>
<td class="align-right">-1</td>
<td class="align-right">1</td>
</tr>
<tr>
<td class="align-right">-2</td>
<td class="align-right">2</td>
</tr>
<tr>
<td class="align-right">-3</td>
<td class="align-right">3</td>
</tr>
<tr>
<td class="align-right">-4</td>
<td class="align-right">4</td>
</tr>
<tr>
<td class="align-right">-5</td>
<td class="align-right">5</td>
</tr>
<tr>
<td class="align-right">-6</td>
<td class="align-right">6</td>
</tr>
<tr>
<td class="align-right">-5e</td>
<td class="align-right">7</td>
</tr>
<tr>
<td class="align-right">-6e</td>
<td class="align-right">8</td>
</tr>
</tbody>
</table>
</blockquote>
<p>
If you know that a file requires somewhat big dictionary (for example,
32 MiB) to compress well, but you want to compress it quicker than <strong>xz
-8</strong> would do, a preset with a low CompCPU value (for example, 1) can be
modified to use a bigger dictionary:</p>
<blockquote>
<pre class="example">
xz --lzma2=preset=1,dict=32MiB foo.tar
</pre>
</blockquote>
<p>
With certain files, the above command may be faster than <strong>xz -6</strong> while
compressing significantly better. However, it must be emphasized that
only some files benefit from a big dictionary while keeping the CompCPU
value low. The most obvious situation, where a big dictionary can help a
lot, is an archive containing very similar files of at least a few
megabytes each. The dictionary size has to be significantly bigger than
any individual file to allow LZMA2 to take full advantage of the
similarities between consecutive files.</p>
<p>
If very high compressor and decompressor memory usage is fine, and the
file being compressed is at least several hundred megabytes, it may be
useful to use an even bigger dictionary than the 64 MiB that <strong>xz -9</strong>
would use:</p>
<blockquote>
<pre class="example">
xz -vv --lzma2=dict=192MiB big_foo.tar
</pre>
</blockquote>
<p>
Using <strong>-vv</strong> (<strong>–verbose –verbose</strong>) like in the above example can be
useful to see the memory requirements of the compressor and
decompressor. Remember that using a dictionary bigger than the size of
the uncompressed file is waste of memory, so the above command isn&#39;t
useful for small files.</p>
<p>
Sometimes the compression time doesn&#39;t matter, but the decompressor
memory usage has to be kept low, for example, to make it possible to
decompress the file on an embedded system. The following command uses
<strong>-6e</strong> (<strong>-6 –extreme</strong>) as a base and sets the dictionary to only 64 KiB.
The resulting file can be decompressed with XZ Embedded (that&#39;s why
there is <strong>–check=crc32</strong>) using about 100 KiB of memory.</p>
<blockquote>
<pre class="example">
xz --check=crc32 --lzma2=preset=6e,dict=64KiB foo
</pre>
</blockquote>
<p>
If you want to squeeze out as many bytes as possible, adjusting the
number of literal context bits (<em>lc</em>) and number of position bits (<em>pb</em>)
can sometimes help. Adjusting the number of literal position bits (<em>lp</em>)
might help too, but usually <em>lc</em> and <em>pb</em> are more important. For
example, a source code archive contains mostly US-ASCII text, so
something like the following might give slightly (like 0.1 %) smaller
file than <strong>xz -6e</strong> (try also without <strong>lc=4</strong>):</p>
<blockquote>
<pre class="example">
xz --lzma2=preset=6e,pb=0,lc=4 source_code.tar
</pre>
</blockquote>
<p>
Using another filter together with LZMA2 can improve compression with
certain file types. For example, to compress a x86-32 or x86-64 shared
library using the x86 BCJ filter:</p>
<blockquote>
<pre class="example">
xz --x86 --lzma2 libfoo.so
</pre>
</blockquote>
<p>
Note that the order of the filter options is significant. If <strong>–x86</strong> is
specified after <strong>–lzma2</strong>, <strong>xz</strong> will give an error, because there cannot
be any filter after LZMA2, and also because the x86 BCJ filter cannot be
used as the last filter in the chain.</p>
<p>
The Delta filter together with LZMA2 can give good results with bitmap
images. It should usually beat PNG, which has a few more advanced
filters than simple delta but uses Deflate for the actual compression.</p>
<p>
The image has to be saved in uncompressed format, for example, as
uncompressed TIFF. The distance parameter of the Delta filter is set to
match the number of bytes per pixel in the image. For example, 24-bit
RGB bitmap needs <strong>dist=3</strong>, and it is also good to pass <strong>pb=0</strong> to LZMA2
to accommodate the three-byte alignment:</p>
<blockquote>
<pre class="example">
xz --delta=dist=3 --lzma2=pb=0 foo.tiff
</pre>
</blockquote>
<p>
If multiple images have been put into a single archive (for example,
<strong>.tar</strong>), the Delta filter will work on that too as long as all images
have the same number of bytes per pixel.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-34" class="outline-2">
<h2 id="headline-34">
SEE ALSO
</h2>
<div id="outline-text-headline-34" class="outline-text-2">
<p>*xzdec*(1), *xzdiff*(1), *xzgrep*(1), *xzless*(1), *xzmore*(1),
*gzip*(1), *bzip2*(1), *7z*(1)</p>
<p>
XZ Utils: &lt;<a href="https://tukaani.org/xz/">https://tukaani.org/xz/</a>&gt;<br>
XZ Embedded: &lt;<a href="https://tukaani.org/xz/embedded.html">https://tukaani.org/xz/embedded.html</a>&gt;<br>
LZMA SDK: &lt;<a href="https://7-zip.org/sdk.html">https://7-zip.org/sdk.html</a>&gt;</p>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.95916b5b8c09add4922ea47e674b5da7fc4b6347a3e8c4e25e98b4b7d236080b.js" integrity="sha256-lZFrW4wJrdSSLqR&#43;Z0tdp/xLY0ej6MTiXpi0t9I2CAs=" crossorigin="anonymous"></script>
    </body>
</html>
