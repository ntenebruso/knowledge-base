<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - zshzle.1 | Technical Notes</title>

      <link rel="stylesheet" href="/css/main.min.a9ecaac9d4f7845fc2de4738f7709cab0bd1c3d19c3466fadd637a6987603257.css" integrity="sha256-qeyqydT3hF/C3kc493CcqwvRw9GcNGb63WN6aYdgMlc=" crossorigin="anonymous">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - zshzle.1</h1>
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
NAME
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>zshzle - zsh command line editor</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
DESCRIPTION
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p>If the <strong>ZLE</strong> option is set (which it is by default in interactive
shells) and the shell input is attached to the terminal, the user is
able to edit command lines.</p>
<p>
There are two display modes. The first, multiline mode, is the default.
It only works if the <strong>TERM</strong> parameter is set to a valid terminal type
that can move the cursor up. The second, single line mode, is used if
<strong>TERM</strong> is invalid or incapable of moving the cursor up, or if the
<strong>SINGLE_LINE_ZLE</strong> option is set. This mode is similar to <strong>ksh</strong>, and uses
no termcap sequences. If <strong>TERM</strong> is &#34;emacs&#34;, the <strong>ZLE</strong> option will be
unset by default.</p>
<p>
The parameters <strong>BAUD</strong>, <strong>COLUMNS</strong>, and <strong>LINES</strong> are also used by the line
editor. See <em>Parameters Used By The Shell</em> in /zshparam/(1).</p>
<p>
The parameter <strong>zle_highlight</strong> is also used by the line editor; see
<em>Character Highlighting</em> below. Highlighting of special characters and
the region between the cursor and the mark (as set with
<strong>set-mark-command</strong> in Emacs mode, or by <strong>visual-mode</strong> in Vi mode) is
enabled by default; consult this reference for more information.
Irascible conservatives will wish to know that all highlighting may be
disabled by the following setting:</p>
<blockquote>
<pre class="example">
zle_highlight=(none)
</pre>
</blockquote>
<p>
In many places, references are made to the <strong>numeric argument</strong>. This can
by default be entered in emacs mode by holding the alt key and typing a
number, or pressing escape before each digit, and in vi command mode by
typing the number before entering a command. Generally the numeric
argument causes the next command entered to be repeated the specified
number of times, unless otherwise noted below; this is implemented by
the <strong>digit-argument</strong> widget. See also the <em>Arguments</em> subsection of the
<em>Widgets</em> section for some other ways the numeric argument can be
modified.</p>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
KEYMAPS
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p>A keymap in ZLE contains a set of bindings between key sequences and ZLE
commands. The empty key sequence cannot be bound.</p>
<p>
There can be any number of keymaps at any time, and each keymap has one
or more names. If all of a keymap&#39;s names are deleted, it disappears.
<strong>bindkey</strong> can be used to manipulate keymap names.</p>
<p>
Initially, there are eight keymaps:</p>
<dl>
<dt>
<strong>emacs</strong>
</dt>
<dd>EMACS emulation</dd>
<dt>
<strong>viins</strong>
</dt>
<dd>vi emulation - insert mode</dd>
<dt>
<strong>vicmd</strong>
</dt>
<dd>vi emulation - command mode</dd>
<dt>
<strong>viopp</strong>
</dt>
<dd>vi emulation - operator pending</dd>
<dt>
<strong>visual</strong>
</dt>
<dd>vi emulation - selection active</dd>
<dt>
<strong>isearch</strong>
</dt>
<dd>incremental search mode</dd>
<dt>
<strong>command</strong>
</dt>
<dd>read a command name</dd>
<dt>
<strong>.safe</strong>
</dt>
<dd>fallback keymap</dd>
</dl>
<p>The `*.safe*&#39; keymap is special. It can never be altered, and the name
can never be removed. However, it can be linked to other names, which
can be removed. In the future other special keymaps may be added; users
should avoid using names beginning with `*.*&#39; for their own keymaps.</p>
<p>
In addition to these names, either `*emacs*&#39; or `*viins*&#39; is also linked
to the name `*main*&#39;. If one of the <strong>VISUAL</strong> or <strong>EDITOR</strong> environment
variables contain the string `*vi*&#39; when the shell starts up then it
will be `*viins*&#39;, otherwise it will be `*emacs*&#39;. <strong>bindkey</strong>&#39;s <strong>-e</strong> and
<strong>-v</strong> options provide a convenient way to override this default choice.</p>
<p>
When the editor starts up, it will select the `*main*&#39; keymap. If that
keymap doesn&#39;t exist, it will use `*.safe*&#39; instead.</p>
<p>
In the `*.safe*&#39; keymap, each single key is bound to <strong>self-insert</strong>,
except for ^J (line feed) and ^M (return) which are bound to
<strong>accept-line</strong>. This is deliberately not pleasant to use; if you are
using it, it means you deleted the main keymap, and you should put it
back.</p>
<div id="outline-container-headline-4" class="outline-3">
<h3 id="headline-4">
Reading Commands
</h3>
<div id="outline-text-headline-4" class="outline-text-3">
<p>When ZLE is reading a command from the terminal, it may read a sequence
that is bound to some command and is also a prefix of a longer bound
string. In this case ZLE will wait a certain time to see if more
characters are typed, and if not (or they don&#39;t match any longer string)
it will execute the binding. This timeout is defined by the <strong>KEYTIMEOUT</strong>
parameter; its default is 0.4 sec. There is no timeout if the prefix
string is not itself bound to a command.</p>
<p>
The key timeout is also applied when ZLE is reading the bytes from a
multibyte character string when it is in the appropriate mode. (This
requires that the shell was compiled with multibyte mode enabled;
typically also the locale has characters with the UTF-8 encoding,
although any multibyte encoding known to the operating system is
supported.) If the second or a subsequent byte is not read within the
timeout period, the shell acts as if <strong>?</strong> were typed and resets the input
state.</p>
<p>
As well as ZLE commands, key sequences can be bound to other strings, by
using `*bindkey -s*&#39;. When such a sequence is read, the replacement
string is pushed back as input, and the command reading process starts
again using these fake keystrokes. This input can itself invoke further
replacement strings, but in order to detect loops the process will be
stopped if there are twenty such replacements without a real command
being read.</p>
<p>
A key sequence typed by the user can be turned into a command name for
use in user-defined widgets with the <strong>read-command</strong> widget, described in
the subsection `Miscellaneous&#39; of the section `Standard Widgets&#39; below.</p>
</div>
</div>
<div id="outline-container-headline-5" class="outline-3">
<h3 id="headline-5">
Local Keymaps
</h3>
<div id="outline-text-headline-5" class="outline-text-3">
<p>While for normal editing a single keymap is used exclusively, in many
modes a local keymap allows for some keys to be customised. For example,
in an incremental search mode, a binding in the <strong>isearch</strong> keymap will
override a binding in the <strong>main</strong> keymap but all keys that are not
overridden can still be used.</p>
<p>
If a key sequence is defined in a local keymap, it will hide a key
sequence in the global keymap that is a prefix of that sequence. An
example of this occurs with the binding of <strong>iw</strong> in <strong>viopp</strong> as this hides
the binding of <strong>i</strong> in <strong>vicmd</strong>. However, a longer sequence in the global
keymap that shares the same prefix can still apply so for example the
binding of <strong>^Xa</strong> in the global keymap will be unaffected by the binding
of <strong>^Xb</strong> in the local keymap.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-6" class="outline-2">
<h2 id="headline-6">
ZLE BUILTINS
</h2>
<div id="outline-text-headline-6" class="outline-text-2">
<p>The ZLE module contains three related builtin commands. The <strong>bindkey</strong>
command manipulates keymaps and key bindings; the <strong>vared</strong> command
invokes ZLE on the value of a shell parameter; and the <strong>zle</strong> command
manipulates editing widgets and allows command line access to ZLE
commands from within shell functions.</p>
<p>
<strong>bindkey</strong> [ <em>options</em> ] <strong>-l</strong> [ <strong>-L</strong> ] [ <em>keymap</em> … ]</p>
<p>
<strong>bindkey</strong> [ <em>options</em> ] <strong>-d</strong></p>
<p>
<strong>bindkey</strong> [ <em>options</em> ] <strong>-D</strong> <em>keymap</em> …</p>
<p>
<strong>bindkey</strong> [ <em>options</em> ] <strong>-A</strong> <em>old-keymap new-keymap</em></p>
<p>
<strong>bindkey</strong> [ <em>options</em> ] <strong>-N</strong> <em>new-keymap</em> [ <em>old-keymap</em> ]</p>
<p>
<strong>bindkey</strong> [ <em>options</em> ] <strong>-m</strong></p>
<p>
<strong>bindkey</strong> [ <em>options</em> ] <strong>-r</strong> <em>in-string</em> …</p>
<p>
<strong>bindkey</strong> [ <em>options</em> ] <strong>-s</strong> <em>in-string out-string</em> …</p>
<p>
<strong>bindkey</strong> [ <em>options</em> ] <em>in-string command</em> …</p>
<p>
<strong>bindkey</strong> [ <em>options</em> ] [ <em>in-string</em> ] <strong>bindkey</strong>&#39;s options can be
divided into three categories: keymap selection for the current command,
operation selection, and others. The keymap selection options are:</p>
<blockquote>
<p><strong>-e</strong> Selects keymap `*emacs*&#39; for any operations by the current command,
and also links `*emacs*&#39; to `*main*&#39; so that it is selected by default
the next time the editor starts.</p>
<dl>
<dt>
<strong>-v</strong>
</dt>
<dd>Selects keymap `*viins*&#39; for any operations by the current
command, and also links `*viins*&#39; to `*main*&#39; so that it is selected
by default the next time the editor starts.</dd>
<dt>
<strong>-a</strong>
</dt>
<dd>Selects keymap `*vicmd*&#39; for any operations by the current
command.</dd>
<dt>
<strong>-M</strong> <em>keymap</em>
</dt>
<dd>The <em>keymap</em> specifies a keymap name that is selected
for any operations by the current command.</dd>
</dl>
<p>If a keymap selection is required and none of the options above are
used, the `*main*&#39; keymap is used. Some operations do not permit a
keymap to be selected, namely:</p>
<p>
<strong>-l</strong> List all existing keymap names; if any arguments are given, list
just those keymaps.</p>
<blockquote>
<p>If the <strong>-L</strong> option is also used, list in the form of <strong>bindkey</strong> commands
to create or link the keymaps. `*bindkey -lL* main&#39; shows which keymap
is linked to `*main*&#39;, if any, and hence if the standard emacs or vi
emulation is in effect. This option does not show the <strong>.safe</strong> keymap
because it cannot be created in that fashion; however, neither is
`*bindkey -lL .safe*&#39; reported as an error, it simply outputs nothing.</p>
</blockquote>
<dl>
<dt>
<strong>-d</strong>
</dt>
<dd>Delete all existing keymaps and reset to the default state.</dd>
<dt>
<strong>-D</strong> <em>keymap</em> …
</dt>
<dd>Delete the named /keymap/s.</dd>
<dt>
<strong>-A</strong> <em>old-keymap new-keymap</em>
</dt>
<dd>Make the <em>new-keymap</em> name an alias
for <em>old-keymap</em>, so that both names refer to the same keymap. The
names have equal standing; if either is deleted, the other remains. If
there is already a keymap with the <em>new-keymap</em> name, it is deleted.</dd>
<dt>
<strong>-N</strong> <em>new-keymap</em> [ <em>old-keymap</em> ]
</dt>
<dd>Create a new keymap, named
<em>new-keymap</em>. If a keymap already has that name, it is deleted. If an
<em>old-keymap</em> name is given, the new keymap is initialized to be a
duplicate of it, otherwise the new keymap will be empty.</dd>
</dl>
<p>To use a newly created keymap, it should be linked to <strong>main</strong>. Hence the
sequence of commands to create and use a new keymap `*mymap*&#39;
initialized from the <strong>emacs</strong> keymap (which remains unchanged) is:</p>
<blockquote>
<pre class="example">
bindkey -N mymap emacs
bindkey -A mymap main
</pre>
</blockquote>
<p>
Note that while `*bindkey -A* <em>newmap</em> <strong>main</strong>&#39; will work when <em>newmap</em>
is <strong>emacs</strong> or <strong>viins</strong>, it will not work for <strong>vicmd</strong>, as switching from
vi insert to command mode becomes impossible.</p>
<p>
The following operations act on the `*main*&#39; keymap if no keymap
selection option was given:</p>
<p>
<strong>-m</strong> Add the built-in set of meta-key bindings to the selected keymap.
Only keys that are unbound or bound to <strong>self-insert</strong> are affected.</p>
<dl>
<dt>
<strong>-r</strong> <em>in-string</em> …
</dt>
<dd>
<p>Unbind the specified /in-string/s in the
selected keymap. This is exactly equivalent to binding the strings to
<strong>undefined-key</strong>.</p>
<p>
When <strong>-R</strong> is also used, interpret the /in-string/s as ranges.</p>
<p>
When <strong>-p</strong> is also used, the <em>in-string/s specify prefixes. Any binding
that has the given /in-string</em> as a prefix, not including the binding
for the <em>in-string</em> itself, if any, will be removed. For example,</p>
<blockquote>
<pre class="example">
bindkey -rpM viins &#39;^[&#39;
</pre>
</blockquote>
<p>
will remove all bindings in the vi-insert keymap beginning with an
escape character (probably cursor keys), but leave the binding for the
escape character itself (probably <strong>vi-cmd-mode</strong>). This is incompatible
with the option <strong>-R</strong>.</p>
</dd>
<dt>
<strong>-s</strong> <em>in-string out-string</em> …
</dt>
<dd>Bind each <em>in-string</em> to each
<em>out-string</em>. When <em>in-string</em> is typed, <em>out-string</em> will be pushed
back and treated as input to the line editor. When <strong>-R</strong> is also used,
interpret the /in-string/s as ranges.

Note that both <em>in-string</em> and <em>out-string</em> are subject to the same
form of interpretation, as described below.</dd>
<dt>
<em>in-string command</em> …
</dt>
<dd>Bind each <em>in-string</em> to each <em>command</em>.
When <strong>-R</strong> is used, interpret the /in-string/s as ranges.</dd>
<dt>
[ <em>in-string</em> ]
</dt>
<dd>List key bindings. If an <em>in-string</em> is specified,
the binding of that string in the selected keymap is displayed.
Otherwise, all key bindings in the selected keymap are displayed. (As
a special case, if the <strong>-e</strong> or <strong>-v</strong> option is used alone, the keymap
is <em>not</em> displayed - the implicit linking of keymaps is the only thing
that happens.)

When the option <strong>-p</strong> is used, the <em>in-string</em> must be present. The
listing shows all bindings which have the given key sequence as a
prefix, not including any bindings for the key sequence itself.

When the <strong>-L</strong> option is used, the list is in the form of <strong>bindkey</strong>
commands to create the key bindings.</dd>
</dl>
<p>When the <strong>-R</strong> option is used as noted above, a valid range consists of
two characters, with an optional `*-*&#39; between them. All characters
between the two specified, inclusive, are bound as specified.</p>
<p>
For either <em>in-string</em> or <em>out-string</em>, the following escape sequences
are recognised:</p>
<dl>
<dt>
<strong>\a</strong>
</dt>
<dd>bell character</dd>
<dt>
<strong>\b</strong>
</dt>
<dd>backspace</dd>
<dt>
<strong>\e</strong>, <strong>\E</strong>
</dt>
<dd>escape</dd>
<dt>
<strong>\f</strong>
</dt>
<dd>form feed</dd>
<dt>
<strong>\n</strong>
</dt>
<dd>linefeed (newline)</dd>
<dt>
<strong>\r</strong>
</dt>
<dd>carriage return</dd>
<dt>
<strong>\t</strong>
</dt>
<dd>horizontal tab</dd>
<dt>
<strong>\v</strong>
</dt>
<dd>vertical tab</dd>
<dt>
*\*/NNN/
</dt>
<dd>character code in octal</dd>
<dt>
*\x*/NN/
</dt>
<dd>character code in hexadecimal</dd>
<dt>
*\u*/NNNN/
</dt>
<dd>unicode character code in hexadecimal</dd>
<dt>
*\U*/NNNNNNNN/
</dt>
<dd>unicode character code in hexadecimal</dd>
<dt>
<strong>\M</strong>[*-*]/X/
</dt>
<dd>character with meta bit set</dd>
<dt>
<strong>\C</strong>[*-*]/X/
</dt>
<dd>control character</dd>
<dt>
*^*/X/
</dt>
<dd>control character</dd>
</dl>
<p>In all other cases, `*\*&#39; escapes the following character. Delete is
written as `*^?*&#39;. Note that `*\M^?*&#39; and `*^\M?*&#39; are not the same, and
that (unlike emacs), the bindings `*\M-<strong><em>X</em>&#39; and `</strong>\e*/X/&#39; are entirely
distinct, although they are initialized to the same bindings by
`*bindkey -m*&#39;.</p>
</blockquote>
<p>
<strong>vared *[ *-Aacghe</strong> ] [ <strong>-p</strong> <em>prompt</em> ] [ <strong>-r</strong> <em>rprompt</em> ]</p>
</div>
</div>
<div id="outline-container-headline-7" class="outline-2">
<h2 id="headline-7">
<strong>[ *-M</strong> <em>main-keymap</em> ] [ <strong>-m</strong> <em>vicmd-keymap</em> ]
</h2>
</div>
<div id="outline-container-headline-8" class="outline-2">
<h2 id="headline-8">
<strong>[ *-i</strong> <em>init-widget</em> ] [ <strong>-f</strong> <em>finish-widget</em> ]
</h2>
</div>
<div id="outline-container-headline-9" class="outline-2">
<h2 id="headline-9">
<strong>[ *-t</strong> <em>tty</em> ] <em>name</em> The value of the parameter <em>name</em> is loaded
</h2>
<div id="outline-text-headline-9" class="outline-text-2">
<p>into the edit buffer, and the line editor is invoked. When the editor
exits, <em>name</em> is set to the string value returned by the editor. When
the <strong>-c</strong> flag is given, the parameter is created if it doesn&#39;t already
exist. The <strong>-a</strong> flag may be given with <strong>-c</strong> to create an array
parameter, or the <strong>-A</strong> flag to create an associative array. If the type
of an existing parameter does not match the type to be created, the
parameter is unset and recreated. The <strong>-g</strong> flag may be given to suppress
warnings from the <strong>WARN_CREATE_GLOBAL</strong> and <strong>WARN_NESTED_VAR</strong> options.</p>
<blockquote>
<p>If an array or array slice is being edited, separator characters as
defined in <strong>$IFS</strong> will be shown quoted with a backslash, as will
backslashes themselves. Conversely, when the edited text is split into
an array, a backslash quotes an immediately following separator
character or backslash; no other special handling of backslashes, or any
handling of quotes, is performed.</p>
<p>
Individual elements of existing array or associative array parameters
may be edited by using subscript syntax on <em>name</em>. New elements are
created automatically, even without <strong>-c</strong>.</p>
<p>
If the <strong>-p</strong> flag is given, the following string will be taken as the
prompt to display at the left. If the <strong>-r</strong> flag is given, the following
string gives the prompt to display at the right. If the <strong>-h</strong> flag is
specified, the history can be accessed from ZLE. If the <strong>-e</strong> flag is
given, typing <strong>^D</strong> (Control-D) on an empty line causes <strong>vared</strong> to exit
immediately with a non-zero return value.</p>
<p>
The <strong>-M</strong> option gives a keymap to link to the <strong>main</strong> keymap during
editing, and the <strong>-m</strong> option gives a keymap to link to the <strong>vicmd</strong>
keymap during editing. For vi-style editing, this allows a pair of
keymaps to override <strong>viins</strong> and <strong>vicmd</strong>. For emacs-style editing, only
<strong>-M</strong> is normally needed but the <strong>-m</strong> option may still be used. On exit,
the previous keymaps will be restored.</p>
<p>
<strong>Vared</strong> calls the usual `*zle-line-init*&#39; and `*zle-line-finish*&#39; hooks
before and after it takes control. Using the <strong>-i</strong> and <strong>-f</strong> options, it
is possible to replace these with other custom widgets.</p>
<p>
If `*-t* <em>tty</em>&#39; is given, <em>tty</em> is the name of a terminal device to be
used instead of the default <strong>/dev/tty</strong>. If <em>tty</em> does not refer to a
terminal an error is reported.</p>
</blockquote>
<p>
<strong>zle</strong></p>
<p>
<strong>zle</strong> <strong>-l</strong> [ <strong>-L</strong> | <strong>-a</strong> ] [ <em>string</em> … ]</p>
<p>
<strong>zle</strong> <strong>-D</strong> <em>widget</em> …</p>
<p>
<strong>zle</strong> <strong>-A</strong> <em>old-widget</em> <em>new-widget</em></p>
<p>
<strong>zle</strong> <strong>-N</strong> <em>widget</em> [ <em>function</em> ]</p>
<p>
<strong>zle</strong> <strong>-f</strong> <em>flag</em> [ <em>flag</em>… ]</p>
<p>
<strong>zle</strong> <strong>-C</strong> <em>widget</em> <em>completion-widget</em> <em>function</em></p>
<p>
<strong>zle</strong> <strong>-R</strong> [ <strong>-c</strong> ] [ <em>display-string</em> ] [ <em>string</em> … ]</p>
<p>
<strong>zle</strong> <strong>-M</strong> <em>string</em></p>
<p>
<strong>zle</strong> <strong>-U</strong> <em>string</em></p>
<p>
<strong>zle</strong> <strong>-K</strong> <em>keymap</em></p>
<p>
<strong>zle</strong> <strong>-F</strong> [ <strong>-L</strong> | <strong>-w</strong> ] [ <em>fd</em> [ <em>handler</em> ] ]</p>
<p>
<strong>zle</strong> <strong>-I</strong></p>
<p>
<strong>zle</strong> <strong>-T</strong> [ <strong>tc</strong> <em>function</em> | <strong>-r</strong> <strong>tc</strong> | <strong>-L</strong> ]</p>
<p>
<strong>zle</strong> <em>widget</em> [ <strong>-n</strong> <em>num</em> ] [ <strong>-f</strong> <em>flag</em> ] [ <strong>-Nw</strong> ] [ <strong>-K</strong> <em>keymap</em>
] <em>args</em> … The <strong>zle</strong> builtin performs a number of different actions
concerning ZLE.</p>
<blockquote>
<p>With no options and no arguments, only the return status will be set. It
is zero if ZLE is currently active and widgets could be invoked using
this builtin command and non-zero otherwise. Note that even if non-zero
status is returned, zle may still be active as part of the completion
system; this does not allow direct calls to ZLE widgets.</p>
<p>
Otherwise, which operation it performs depends on its options:</p>
<p>
<strong>-l</strong> [ <strong>-L</strong> | <strong>-a</strong> ] [ <em>string</em> ] List all existing user-defined
widgets. If the <strong>-L</strong> option is used, list in the form of <strong>zle</strong> commands
to create the widgets.</p>
<blockquote>
<p>When combined with the <strong>-a</strong> option, all widget names are listed,
including the builtin ones. In this case the <strong>-L</strong> option is ignored.</p>
<p>
If at least one <em>string</em> is given, and <strong>-a</strong> is present or <strong>-L</strong> is not
used, nothing will be printed. The return status will be zero if all
<em>string/s are names of existing widgets and non-zero if at least one
/string</em> is not a name of a defined widget. If <strong>-a</strong> is also present, all
widget names are used for the comparison including builtin widgets, else
only user-defined widgets are used.</p>
<p>
If at least one <em>string</em> is present and the <strong>-L</strong> option is used,
user-defined widgets matching any <em>string</em> are listed in the form of
<strong>zle</strong> commands to create the widgets.</p>
</blockquote>
<dl>
<dt>
<strong>-D</strong> <em>widget</em> …
</dt>
<dd>Delete the named /widget/s.</dd>
<dt>
<strong>-A</strong> <em>old-widget</em> <em>new-widget</em>
</dt>
<dd>Make the <em>new-widget</em> name an alias
for <em>old-widget</em>, so that both names refer to the same widget. The
names have equal standing; if either is deleted, the other remains. If
there is already a widget with the <em>new-widget</em> name, it is deleted.</dd>
<dt>
<strong>-N</strong> <em>widget</em> [ <em>function</em> ]
</dt>
<dd>Create a user-defined widget. If there
is already a widget with the specified name, it is overwritten. When
the new widget is invoked from within the editor, the specified shell
<em>function</em> is called. If no function name is specified, it defaults to
the same name as the widget. For further information, see the section
`Widgets&#39; below.</dd>
<dt>
<strong>-f</strong> <em>flag</em> [ <em>flag</em>… ]
</dt>
<dd>Set various flags on the running widget.
Possible values for <em>flag</em> are:

<strong>yank</strong> for indicating that the widget has yanked text into the buffer.
If the widget is wrapping an existing internal widget, no further
action is necessary, but if it has inserted the text manually, then it
should also take care to set <strong>YANK_START</strong> and <strong>YANK_END</strong> correctly.
<strong>yankbefore</strong> does the same but is used when the yanked text appears
after the cursor.

<strong>kill</strong> for indicating that text has been killed into the cutbuffer.
When repeatedly invoking a kill widget, text is appended to the
cutbuffer instead of replacing it, but when wrapping such widgets, it
is necessary to call `*zle -f kill*&#39; to retain this effect.

<strong>vichange</strong> for indicating that the widget represents a vi change that
can be repeated as a whole with `*vi-repeat-change*&#39;. The flag should
be set early in the function before inspecting the value of <strong>NUMERIC</strong>
or invoking other widgets. This has no effect for a widget invoked
from insert mode. If insert mode is active when the widget finishes,
the change extends until next returning to command mode.</dd>
<dt>
<strong>-C</strong> <em>widget</em> <em>completion-widget</em> <em>function</em>
</dt>
<dd>Create a user-defined
completion widget named <em>widget</em>. The completion widget will behave
like the built-in completion-widget whose name is given as
<em>completion-widget</em>. To generate the completions, the shell function
<em>function</em> will be called. For further information, see
/zshcompwid/(1).</dd>
<dt>
<strong>-R</strong> [ <strong>-c</strong> ] [ <em>display-string</em> ] [ <em>string</em> … ]
</dt>
<dd>Redisplay the
command line. If a <em>display-string</em> is given and not empty, this is
shown in the status line (immediately below the line being edited).

If the optional /string/s are given they are listed below the prompt
in the same way as completion lists are printed. If no /string/s are
given but the <strong>-c</strong> option is used such a list is cleared.

Note that immediately after returning from running widgets, the
command line will be redisplayed and the strings displayed will be
erased. Therefore, this option is only useful for widgets that do not
exit immediately after using it.

This command can safely be called outside user defined widgets; if zle
is active, the display will be refreshed, while if zle is not active,
the command has no effect. In this case there will usually be no other
arguments.

The status is zero if zle was active, else one.</dd>
<dt>
<strong>-M</strong> <em>string</em>
</dt>
<dd>As with the <strong>-R</strong> option, the <em>string</em> will be
displayed below the command line; unlike the <strong>-R</strong> option, the string
will not be put into the status line but will instead be printed
normally below the prompt. This means that the <em>string</em> will still be
displayed after the widget returns (until it is overwritten by
subsequent commands).</dd>
<dt>
<strong>-U</strong> <em>string</em>
</dt>
<dd>This pushes the characters in the <em>string</em> onto the
input stack of ZLE. After the widget currently executed finishes ZLE
will behave as if the characters in the <em>string</em> were typed by the
user.

As ZLE uses a stack, if this option is used repeatedly the last string
pushed onto the stack will be processed first. However, the characters
in each <em>string</em> will be processed in the order in which they appear
in the string.</dd>
<dt>
<strong>-K</strong> <em>keymap</em>
</dt>
<dd>Selects the keymap named <em>keymap</em>. An error message
will be displayed if there is no such keymap.

This keymap selection affects the interpretation of following
keystrokes within this invocation of ZLE. Any following invocation
(e.g., the next command line) will start as usual with the `*main*&#39;
keymap selected.</dd>
<dt>
<strong>-F</strong> [ <strong>-L</strong> | <strong>-w</strong> ] [ <em>fd</em> [ <em>handler</em> ] ]
</dt>
<dd>
<p>Only available if your
system supports one of the `poll&#39; or `select&#39; system calls; most
modern systems do.</p>
<p>
Installs <em>handler</em> (the name of a shell function) to handle input from
file descriptor <em>fd</em>. Installing a handler for an <em>fd</em> which is
already handled causes the existing handler to be replaced. Any number
of handlers for any number of readable file descriptors may be
installed. Note that zle makes no attempt to check whether this <em>fd</em>
is actually readable when installing the handler. The user must make
their own arrangements for handling the file descriptor when zle is
not active.</p>
<p>
When zle is attempting to read data, it will examine both the terminal
and the list of handled <em>fd</em>&#39;s. If data becomes available on a handled
<em>fd</em>, zle calls <em>handler</em> with the fd which is ready for reading as
the first argument. Under normal circumstances this is the only
argument, but if an error was detected, a second argument provides
details: `*hup*&#39; for a disconnect, `*nval*&#39; for a closed or otherwise
invalid descriptor, or `*err*&#39; for any other condition. Systems that
support only the `select&#39; system call always use `*err*&#39;.</p>
<p>
If the option <strong>-w</strong> is also given, the <em>handler</em> is instead a line
editor widget, typically a shell function made into a widget using
`*zle -N*&#39;. In that case <em>handler</em> can use all the facilities of zle
to update the current editing line. Note, however, that as handling
<em>fd</em> takes place at a low level changes to the display will not
automatically appear; the widget should call `*zle -R*&#39; to force
redisplay. As of this writing, widget handlers only support a single
argument and thus are never passed a string for error state, so
widgets must be prepared to test the descriptor themselves.</p>
<p>
If either type of handler produces output to the terminal, it should
call `*zle -I*&#39; before doing so (see below). Handlers should not
attempt to read from the terminal.</p>
<p>
If no <em>handler</em> is given, but an <em>fd</em> is present, any handler for that
<em>fd</em> is removed. If there is none, an error message is printed and
status 1 is returned.</p>
<p>
If no arguments are given, or the <strong>-L</strong> option is supplied, a list of
handlers is printed in a form which can be stored for later execution.</p>
<p>
An <em>fd</em> (but not a <em>handler</em>) may optionally be given with the <strong>-L</strong>
option; in this case, the function will list the handler if any, else
silently return status 1.</p>
<p>
Note that this feature should be used with care. Activity on one of
the <em>fd</em>&#39;s which is not properly handled can cause the terminal to
become unusable. Removing an <em>fd</em> handler from within a signal trap
may cause unpredictable behavior.</p>
<p>
Here is a simple example of using this feature. A connection to a
remote TCP port is created using the ztcp command; see the description
of the <strong>zsh/net/tcp</strong> module in /zshmodules/(1). Then a handler is
installed which simply prints out any data which arrives on this
connection. Note that `select&#39; will indicate that the file descriptor
needs handling if the remote side has closed the connection; we handle
that by testing for a failed read.</p>
<blockquote>
<pre class="example">
if ztcp pwspc 2811; then
  tcpfd=$REPLY
  handler() {
    zle -I
    local line
    if ! read -r line &lt;&amp;$1; then
      # select marks this fd if we reach EOF,
      # so handle this specially.
      print &#34;[Read on fd $1 failed, removing.]&#34; &gt;&amp;2
      zle -F $1
      return 1
    fi
    print -r - $line
  }
  zle -F $tcpfd handler
fi
</pre>
</blockquote>
</dd>
<dt>
<strong>-I</strong>
</dt>
<dd>
<p>Unusually, this option is most useful outside ordinary widget
functions, though it may be used within if normal output to the
terminal is required. It invalidates the current zle display in
preparation for output; typically this will be from a trap function.
It has no effect if zle is not active. When a trap exits, the shell
checks to see if the display needs restoring, hence the following will
print output in such a way as not to disturb the line being edited:</p>
<blockquote>
<pre class="example">
TRAPUSR1() {
  # Invalidate zle display
  [[ -o zle ]] &amp;&amp; zle -I
  # Show output
  print Hello
}
</pre>
</blockquote>
<p>
In general, the trap function may need to test whether zle is active
before using this method (as shown in the example), since the
<strong>zsh/zle</strong> module may not even be loaded; if it is not, the command can
be skipped.</p>
<p>
It is possible to call `*zle -I*&#39; several times before control is
returned to the editor; the display will only be invalidated the first
time to minimise disruption.</p>
<p>
Note that there are normally better ways of manipulating the display
from within zle widgets; see, for example, `*zle -R*&#39; above.</p>
<p>
The returned status is zero if zle was invalidated, even though this
may have been by a previous call to `*zle -I*&#39; or by a system
notification. To test if a zle widget may be called at this point,
execute <strong>zle</strong> with no arguments and examine the return status.</p>
</dd>
<dt>
<strong>-T</strong>
</dt>
<dd>This is used to add, list or remove internal transformations
on the processing performed by the line editor. It is typically used
only for debugging or testing and is therefore of little interest to
the general user.

`*zle -T* <em>transformation</em> <em>func</em>&#39; specifies that the given
<em>transformation</em> (see below) is effected by shell function <em>func</em>.

`*zle -Tr* <em>transformation</em>&#39; removes the given <em>transformation</em> if it
was present (it is not an error if none was).

`*zle -TL*&#39; can be used to list all transformations currently in
operation.

Currently the only transformation is <strong>tc</strong>. This is used instead of
outputting termcap codes to the terminal. When the transformation is
in operation the shell function is passed the termcap code that would
be output as its first argument; if the operation required a numeric
argument, that is passed as a second argument. The function should set
the shell variable <strong>REPLY</strong> to the transformed termcap code. Typically
this is used to produce some simply formatted version of the code and
optional argument for debugging or testing. Note that this
transformation is not applied to other non-printing characters such as
carriage returns and newlines.</dd>
<dt>
?
</dt>
<dd><em>widget</em> [ <strong>-n</strong> <em>num</em> ] [ <strong>-f</strong> <em>flag</em> ] [ <strong>-Nw</strong> ] [ <strong>-K</strong> <em>keymap</em> ]
<em>args</em> … :: Invoke the specified <em>widget</em>. This can only be done
when ZLE is active; normally this will be within a user-defined
widget.

With the options <strong>-n</strong> and <strong>-N</strong>, the current numeric argument will be
saved and then restored after the call to <em>widget</em>; `*-n* <em>num</em>&#39; sets
the numeric argument temporarily to <em>num</em>, while `*-N*&#39; sets it to the
default, i.e. as if there were none.

With the option <strong>-K</strong>, <em>keymap</em> will be used as the current keymap
during the execution of the widget. The previous keymap will be
restored when the widget exits.

Normally, calling a widget in this way does not set the special
parameter <strong>WIDGET</strong> and related parameters, so that the environment
appears as if the top-level widget called by the user were still
active. With the option <strong>-w</strong>, <strong>WIDGET</strong> and related parameters are set
to reflect the widget being executed by the <strong>zle</strong> call.

Normally, when <em>widget</em> returns the special parameter <strong>LASTWIDGET</strong>
will point to it. This can be inhibited by passing the option <strong>-f
nolast</strong>.

Any further arguments will be passed to the widget; note that as
standard argument handling is performed, any general argument list
should be preceded by <strong>–</strong>. If it is a shell function, these are
passed down as positional parameters; for builtin widgets it is up to
the widget in question what it does with them. Currently arguments are
only handled by the incremental-search commands, the
<strong>history-search-forward</strong> and <strong>-backward</strong> and the corresponding
functions prefixed by <strong>vi-</strong>, and by <strong>universal-argument</strong>. No error is
flagged if the command does not use the arguments, or only uses some
of them.

The return status reflects the success or failure of the operation
carried out by the widget, or if it is a user-defined widget the
return status of the shell function.

A non-zero return status causes the shell to beep when the widget
exits, unless the <strong>BEEP</strong> options was unset or the widget was called
via the <strong>zle</strong> command. Thus if a user defined widget requires an
immediate beep, it should call the <strong>beep</strong> widget directly.</dd>
</dl>
</blockquote>
</div>
</div>
<div id="outline-container-headline-10" class="outline-2">
<h2 id="headline-10">
ZLE WIDGETS
</h2>
<div id="outline-text-headline-10" class="outline-text-2">
<p>All actions in the editor are performed by `widgets&#39;. A widget&#39;s job is
simply to perform some small action. The ZLE commands that key sequences
in keymaps are bound to are in fact widgets. Widgets can be user-defined
or built in.</p>
<p>
The standard widgets built into ZLE are listed in the section `Standard
Widgets&#39; below. Other built-in widgets can be defined by other modules
(see /zshmodules/(1)). Each built-in widget has two names: its normal
canonical name, and the same name preceded by a `*.*&#39;. The `*.*&#39; name is
special: it can&#39;t be rebound to a different widget. This makes the
widget available even when its usual name has been redefined.</p>
<p>
User-defined widgets are defined using `*zle -N*&#39;, and implemented as
shell functions. When the widget is executed, the corresponding shell
function is executed, and can perform editing (or other) actions. It is
recommended that user-defined widgets should not have names starting
with `*.*&#39;.</p>
</div>
</div>
<div id="outline-container-headline-11" class="outline-2">
<h2 id="headline-11">
USER-DEFINED WIDGETS
</h2>
<div id="outline-text-headline-11" class="outline-text-2">
<p>User-defined widgets, being implemented as shell functions, can execute
any normal shell command. They can also run other widgets (whether
built-in or user-defined) using the <strong>zle</strong> builtin command. The standard
input of the function is redirected from /dev/null to prevent external
commands from unintentionally blocking ZLE by reading from the terminal,
but <strong>read -k</strong> or <strong>read -q</strong> can be used to read characters. Finally, they
can examine and edit the ZLE buffer being edited by reading and setting
the special parameters described below.</p>
<p>
These special parameters are always available in widget functions, but
are not in any way special outside ZLE. If they have some normal value
outside ZLE, that value is temporarily inaccessible, but will return
when the widget function exits. These special parameters in fact have
local scope, like parameters created in a function using <strong>local</strong>.</p>
<p>
Inside completion widgets and traps called while ZLE is active, these
parameters are available read-only.</p>
<p>
Note that the parameters appear as local to any ZLE widget in which they
appear. Hence if it is desired to override them this needs to be done
within a nested function:</p>
<blockquote>
<pre class="example">
widget-function() {
  # $WIDGET here refers to the special variable
  # that is local inside widget-function
  () {
     # This anonymous nested function allows WIDGET
     # to be used as a local variable.  The -h
     # removes the special status of the variable.
     local -h WIDGET
  }
}
</pre>
</blockquote>
<p>
<strong>BUFFER</strong> (scalar) The entire contents of the edit buffer. If it is
written to, the cursor remains at the same offset, unless that would put
it outside the buffer.</p>
<dl>
<dt>
<strong>BUFFERLINES</strong> (integer)
</dt>
<dd>The number of screen lines needed for the
edit buffer currently displayed on screen (i.e. without any changes to
the preceding parameters done after the last redisplay); read-only.</dd>
<dt>
<strong>CONTEXT</strong> (scalar)
</dt>
<dd>
<p>The context in which zle was called to read a
line; read-only. One of the values:</p>
<p>
<strong>start</strong> The start of a command line (at prompt <strong>PS1</strong>).</p>
<dl>
<dt>
<strong>cont</strong>
</dt>
<dd>A continuation to a command line (at prompt <strong>PS2</strong>).</dd>
<dt>
<strong>select</strong>
</dt>
<dd>In a <strong>select</strong> loop (at prompt <strong>PS3</strong>).</dd>
<dt>
<strong>vared</strong>
</dt>
<dd>Editing a variable in <strong>vared</strong>.</dd>
</dl>
</dd>
<dt>
<strong>CURSOR</strong> (integer)
</dt>
<dd>The offset of the cursor, within the edit
buffer. This is in the range 0 to <strong>$#BUFFER</strong>, and is by definition
equal to <strong>$#LBUFFER</strong>. Attempts to move the cursor outside the buffer
will result in the cursor being moved to the appropriate end of the
buffer.</dd>
<dt>
<strong>CUTBUFFER</strong> (scalar)
</dt>
<dd>The last item cut using one of the `*kill-*&#39;
commands; the string which the next yank would insert in the line.
Later entries in the kill ring are in the array <strong>killring</strong>. Note that
the command `*zle copy-region-as-kill* <em>string</em>&#39; can be used to set
the text of the cut buffer from a shell function and cycle the kill
ring in the same way as interactively killing text.</dd>
<dt>
<strong>HISTNO</strong> (integer)
</dt>
<dd>The current history number. Setting this has the
same effect as moving up or down in the history to the corresponding
history line. An attempt to set it is ignored if the line is not
stored in the history. Note this is not the same as the parameter
<strong>HISTCMD</strong>, which always gives the number of the history line being
added to the main shell&#39;s history. <strong>HISTNO</strong> refers to the line being
retrieved within zle.</dd>
</dl>
<p><strong>ISEARCHMATCH_ACTIVE</strong> (integer)</p>
<p>
<strong>ISEARCHMATCH_START</strong> (integer)</p>
<p>
<strong>ISEARCHMATCH_END</strong> (integer) <strong>ISEARCHMATCH_ACTIVE</strong> indicates whether a
part of the <strong>BUFFER</strong> is currently matched by an incremental search
pattern. <strong>ISEARCHMATCH_START</strong> and <strong>ISEARCHMATCH_END</strong> give the location
of the matched part and are in the same units as <strong>CURSOR</strong>. They are only
valid for reading when <strong>ISEARCHMATCH_ACTIVE</strong> is non-zero.</p>
<blockquote>
<p>All parameters are read-only.</p>
</blockquote>
<dl>
<dt>
<strong>KEYMAP</strong> (scalar)
</dt>
<dd>The name of the currently selected keymap;
read-only.</dd>
<dt>
<strong>KEYS</strong> (scalar)
</dt>
<dd>The keys typed to invoke this widget, as a literal
string; read-only.</dd>
<dt>
<strong>KEYS_QUEUED_COUNT</strong> (integer)
</dt>
<dd>The number of bytes pushed back to
the input queue and therefore available for reading immediately before
any I/O is done; read-only. See also <strong>PENDING</strong>; the two values are
distinct.</dd>
<dt>
<strong>killring</strong> (array)
</dt>
<dd>The array of previously killed items, with the
most recently killed first. This gives the items that would be
retrieved by a <strong>yank-pop</strong> in the same order. Note, however, that the
most recently killed item is in <strong>$CUTBUFFER</strong>; <strong>$killring</strong> shows the
array of previous entries.

The default size for the kill ring is eight, however the length may be
changed by normal array operations. Any empty string in the kill ring
is ignored by the <strong>yank-pop</strong> command, hence the size of the array
effectively sets the maximum length of the kill ring, while the number
of non-zero strings gives the current length, both as seen by the user
at the command line.</dd>
<dt>
<strong>LASTABORTEDSEARCH</strong> (scalar)
</dt>
<dd>The last search string used by an
interactive search that was aborted by the user (status 3 returned by
the search widget).</dd>
<dt>
<strong>LASTSEARCH</strong> (scalar)
</dt>
<dd>The last search string used by an interactive
search; read-only. This is set even if the search failed (status 0, 1
or 2 returned by the search widget), but not if it was aborted by the
user.</dd>
<dt>
<strong>LASTWIDGET</strong> (scalar)
</dt>
<dd>The name of the last widget that was
executed; read-only.</dd>
<dt>
<strong>LBUFFER</strong> (scalar)
</dt>
<dd>The part of the buffer that lies to the left of
the cursor position. If it is assigned to, only that part of the
buffer is replaced, and the cursor remains between the new <strong>$LBUFFER</strong>
and the old <strong>$RBUFFER</strong>.</dd>
<dt>
<strong>MARK</strong> (integer)
</dt>
<dd>Like <strong>CURSOR</strong>, but for the mark. With vi-mode
operators that wait for a movement command to select a region of text,
setting <strong>MARK</strong> allows the selection to extend in both directions from
the initial cursor position.</dd>
<dt>
<strong>NUMERIC</strong> (integer)
</dt>
<dd>The numeric argument. If no numeric argument
was given, this parameter is unset. When this is set inside a widget
function, builtin widgets called with the <strong>zle</strong> builtin command will
use the value assigned. If it is unset inside a widget function,
builtin widgets called behave as if no numeric argument was given.</dd>
<dt>
<strong>PENDING</strong> (integer)
</dt>
<dd>The number of bytes pending for input, i.e. the
number of bytes which have already been typed and can immediately be
read. On systems where the shell is not able to get this information,
this parameter will always have a value of zero. Read-only. See also
<strong>KEYS_QUEUED_COUNT</strong>; the two values are distinct.</dd>
<dt>
<strong>PREBUFFER</strong> (scalar)
</dt>
<dd>In a multi-line input at the secondary prompt,
this read-only parameter contains the contents of the lines before the
one the cursor is currently in.</dd>
<dt>
<strong>PREDISPLAY</strong> (scalar)
</dt>
<dd>Text to be displayed before the start of the
editable text buffer. This does not have to be a complete line; to
display a complete line, a newline must be appended explicitly. The
text is reset on each new invocation (but not recursive invocation) of
zle.</dd>
<dt>
<strong>POSTDISPLAY</strong> (scalar)
</dt>
<dd>Text to be displayed after the end of the
editable text buffer. This does not have to be a complete line; to
display a complete line, a newline must be prepended explicitly. The
text is reset on each new invocation (but not recursive invocation) of
zle.</dd>
<dt>
<strong>RBUFFER</strong> (scalar)
</dt>
<dd>The part of the buffer that lies to the right of
the cursor position. If it is assigned to, only that part of the
buffer is replaced, and the cursor remains between the old <strong>$LBUFFER</strong>
and the new <strong>$RBUFFER</strong>.</dd>
<dt>
<strong>REGION_ACTIVE</strong> (integer)
</dt>
<dd>Indicates if the region is currently
active. It can be assigned 0 or 1 to deactivate and activate the
region respectively. A value of 2 activates the region in line-wise
mode with the highlighted text extending for whole lines only; see
<em>Character Highlighting</em> below.</dd>
<dt>
<strong>region_highlight</strong> (array)
</dt>
<dd>
<p>Each element of this array may be set to
a string that describes highlighting for an arbitrary region of the
command line that will take effect the next time the command line is
redisplayed. Highlighting of the non-editable parts of the command
line in <strong>PREDISPLAY</strong> and <strong>POSTDISPLAY</strong> are possible, but note that the
<strong>P</strong> flag is needed for character indexing to include <strong>PREDISPLAY</strong>.</p>
<p>
Each string consists of the following whitespace-separated parts:</p>
<p>
· Optionally, a `*P*&#39; to signify that the start and end offset that
follow include any string set by the <strong>PREDISPLAY</strong> special parameter;
this is needed if the predisplay string itself is to be highlighted.
Whitespace between the `*P*&#39; and the start offset is optional.</p>
<dl>
<dt>
·
</dt>
<dd>A start offset in the same units as <strong>CURSOR</strong>.</dd>
<dt>
·
</dt>
<dd>An end offset in the same units as <strong>CURSOR</strong>.</dd>
<dt>
·
</dt>
<dd>A highlight specification in the same format as used for
contexts in the parameter <strong>zle_highlight</strong>, see the section
`Character Highlighting&#39; below; for example, <strong>standout</strong> or
<strong>fg=red,bold</strong>.</dd>
<dt>
·
</dt>
<dd>Optionally, a string of the form `*memo=*/token/&#39;. The <em>token</em>
consists of everything between the `*=*&#39; and the next whitespace,
comma, NUL, or the end of the string. The <em>token</em> is preserved
verbatim but not parsed in any way.

Plugins may use this to identify array elements they have added: for
example, a plugin might set <em>token</em> to its (the plugin&#39;s) name and
then use `*region_highlight=(
${region_highlight:#*memo=*/token/*} )*&#39; in order to remove array
elements it have added.

(This example uses the `*${<strong><em>name</em></strong>:#*/pattern/*}*&#39; array-grepping
syntax described in the section `Parameter Expansion&#39; in
/zshexpn/(1).)</dd>
</dl>
<p>For example,</p>
<blockquote>
<pre class="example">
region_highlight=(&#34;P0 20 bold memo=foobar&#34;)
</pre>
</blockquote>
<p>
specifies that the first twenty characters of the text including any
predisplay string should be highlighted in bold.</p>
<p>
Note that the effect of <strong>region_highlight</strong> is not saved and disappears
as soon as the line is accepted.</p>
<p>
Note that zsh 5.8 and older do not support the `*memo=*/token/&#39; field
and may misparse the third (highlight specification) field when a memo
is given.</p>
<p>
The final highlighting on the command line depends on both
<strong>region_highlight</strong> and <strong>zle_highlight</strong>; see the section CHARACTER
HIGHLIGHTING below for details.</p>
</dd>
<dt>
<strong>registers</strong> (associative array)
</dt>
<dd>The contents of each of the vi
register buffers. These are typically set using <strong>vi-set-buffer</strong>
followed by a delete, change or yank command.</dd>
</dl>
<p><strong>SUFFIX_ACTIVE</strong> (integer)</p>
<p>
<strong>SUFFIX_START</strong> (integer)</p>
<p>
<strong>SUFFIX_END</strong> (integer) <strong>SUFFIX_ACTIVE</strong> indicates whether an
auto-removable completion suffix is currently active. <strong>SUFFIX_START</strong> and
<strong>SUFFIX_END</strong> give the location of the suffix and are in the same units
as <strong>CURSOR</strong>. They are only valid for reading when <strong>SUFFIX_ACTIVE</strong> is
non-zero.</p>
<blockquote>
<p>All parameters are read-only.</p>
</blockquote>
<dl>
<dt>
<strong>UNDO_CHANGE_NO</strong> (integer)
</dt>
<dd>A number representing the state of the
undo history. The only use of this is passing as an argument to the
<strong>undo</strong> widget in order to undo back to the recorded point. Read-only.</dd>
<dt>
<strong>UNDO_LIMIT_NO</strong> (integer)
</dt>
<dd>
<p>A number corresponding to an existing
change in the undo history; compare <strong>UNDO_CHANGE_NO</strong>. If this is set
to a value greater than zero, the <strong>undo</strong> command will not allow the
line to be undone beyond the given change number. It is still possible
to use `*zle undo* <em>change</em>&#39; in a widget to undo beyond that point; in
that case, it will not be possible to undo at all until
<strong>UNDO_LIMIT_NO</strong> is reduced. Set to 0 to disable the limit.</p>
<p>
A typical use of this variable in a widget function is as follows
(note the additional function scope is required):</p>
<blockquote>
<pre class="example">
() {
  local UNDO_LIMIT_NO=$UNDO_CHANGE_NO
  # Perform some form of recursive edit.
}
</pre>
</blockquote>
</dd>
<dt>
<strong>WIDGET</strong> (scalar)
</dt>
<dd>The name of the widget currently being executed;
read-only.</dd>
<dt>
<strong>WIDGETFUNC</strong> (scalar)
</dt>
<dd>The name of the shell function that
implements a widget defined with either <strong>zle -N</strong> or <strong>zle -C</strong>. In the
former case, this is the second argument to the <strong>zle -N</strong> command that
defined the widget, or the first argument if there was no second
argument. In the latter case this is the third argument to the <strong>zle
-C</strong> command that defined the widget. Read-only.</dd>
<dt>
<strong>WIDGETSTYLE</strong> (scalar)
</dt>
<dd>Describes the implementation behind the
completion widget currently being executed; the second argument that
followed <strong>zle -C</strong> when the widget was defined. This is the name of a
builtin completion widget. For widgets defined with <strong>zle -N</strong> this is
set to the empty string. Read-only.</dd>
</dl>
<p><strong>YANK_ACTIVE</strong> (integer)</p>
<p>
<strong>YANK_START</strong> (integer)</p>
<p>
<strong>YANK_END</strong> (integer) <strong>YANK_ACTIVE</strong> indicates whether text has just been
yanked (pasted) into the buffer. <strong>YANK_START</strong> and <strong>YANK_END</strong> give the
location of the pasted text and are in the same units as <strong>CURSOR</strong>. They
are only valid for reading when <strong>YANK_ACTIVE</strong> is non-zero. They can also
be assigned by widgets that insert text in a yank-like fashion, for
example wrappers of <strong>bracketed-paste</strong>. See also <strong>zle -f</strong>.</p>
<blockquote>
<p><strong>YANK_ACTIVE</strong> is read-only.</p>
</blockquote>
<dl>
<dt>
<strong>ZLE_RECURSIVE</strong> (integer)
</dt>
<dd>Usually zero, but incremented inside any
instance of <strong>recursive-edit</strong>. Hence indicates the current recursion
level.

<strong>ZLE_RECURSIVE</strong> is read-only.</dd>
<dt>
<strong>ZLE_STATE</strong> (scalar)
</dt>
<dd>
<p>Contains a set of space-separated words that
describe the current <strong>zle</strong> state.</p>
<p>
Currently, the states shown are the insert mode as set by the
<strong>overwrite-mode</strong> or <strong>vi-replace</strong> widgets and whether history commands
will visit imported entries as controlled by the set-local-history
widget. The string contains `*insert*&#39; if characters to be inserted on
the command line move existing characters to the right or
`*overwrite*&#39; if characters to be inserted overwrite existing
characters. It contains `*localhistory*&#39; if only local history
commands will be visited or `*globalhistory*&#39; if imported history
commands will also be visited.</p>
<p>
The substrings are sorted in alphabetical order so that if you want to
test for two specific substrings in a future-proof way, you can do
match by doing:</p>
<blockquote>
<pre class="example">
if [[ $ZLE_STATE == *globalhistory*insert* ]]; then ...; fi
</pre>
</blockquote>
</dd>
</dl>
<div id="outline-container-headline-12" class="outline-3">
<h3 id="headline-12">
Special Widgets
</h3>
<div id="outline-text-headline-12" class="outline-text-3">
<p>There are a few user-defined widgets which are special to the shell. If
they do not exist, no special action is taken. The environment provided
is identical to that for any other editing widget.</p>
<p>
<strong>zle-isearch-exit</strong> Executed at the end of incremental search at the
point where the isearch prompt is removed from the display. See
<strong>zle-isearch-update</strong> for an example.</p>
<dl>
<dt>
<strong>zle-isearch-update</strong>
</dt>
<dd>
<p>Executed within incremental search when the
display is about to be redrawn. Additional output below the
incremental search prompt can be generated by using `*zle -M*&#39; within
the widget. For example,</p>
<blockquote>
<pre class="example">
zle-isearch-update() { zle -M &#34;Line $HISTNO&#34;; }
zle -N zle-isearch-update
</pre>
</blockquote>
<p>
Note the line output by `*zle -M*&#39; is not deleted on exit from
incremental search. This can be done from a <strong>zle-isearch-exit</strong> widget:</p>
<blockquote>
<pre class="example">
zle-isearch-exit() { zle -M &#34;&#34;; }
zle -N zle-isearch-exit
</pre>
</blockquote>
</dd>
<dt>
<strong>zle-line-pre-redraw</strong>
</dt>
<dd>Executed whenever the input line is about to
be redrawn, providing an opportunity to update the region_highlight
array.</dd>
<dt>
<strong>zle-line-init</strong>
</dt>
<dd>
<p>Executed every time the line editor is started to
read a new line of input. The following example puts the line editor
into vi command mode when it starts up.</p>
<blockquote>
<pre class="example">
zle-line-init() { zle -K vicmd; }
zle -N zle-line-init
</pre>
</blockquote>
<p>
(The command inside the function sets the keymap directly; it is
equivalent to <strong>zle vi-cmd-mode</strong>.)</p>
</dd>
<dt>
<strong>zle-line-finish</strong>
</dt>
<dd>This is similar to <strong>zle-line-init</strong> but is
executed every time the line editor has finished reading a line of
input.</dd>
<dt>
<strong>zle-history-line-set</strong>
</dt>
<dd>Executed when the history line changes.</dd>
<dt>
<strong>zle-keymap-select</strong>
</dt>
<dd>Executed every time the keymap changes, i.e.
the special parameter <strong>KEYMAP</strong> is set to a different value, while the
line editor is active. Initialising the keymap when the line editor
starts does not cause the widget to be called.

The value <strong>$KEYMAP</strong> within the function reflects the new keymap. The
old keymap is passed as the sole argument.

This can be used for detecting switches between the vi command
(<strong>vicmd</strong>) and insert (usually <strong>main</strong>) keymaps.</dd>
</dl>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-13" class="outline-2">
<h2 id="headline-13">
STANDARD WIDGETS
</h2>
<div id="outline-text-headline-13" class="outline-text-2">
<p>The following is a list of all the standard widgets, and their default
bindings in emacs mode, vi command mode and vi insert mode (the
`*emacs*&#39;, `*vicmd*&#39; and `*viins*&#39; keymaps, respectively).</p>
<p>
Note that cursor keys are bound to movement keys in all three keymaps;
the shell assumes that the cursor keys send the key sequences reported
by the terminal-handling library (termcap or terminfo). The key
sequences shown in the list are those based on the VT100, common on many
modern terminals, but in fact these are not necessarily bound. In the
case of the <strong>viins</strong> keymap, the initial escape character of the
sequences serves also to return to the <strong>vicmd</strong> keymap: whether this
happens is determined by the <strong>KEYTIMEOUT</strong> parameter, see /zshparam/(1).</p>
<div id="outline-container-headline-14" class="outline-3">
<h3 id="headline-14">
Movement
</h3>
<div id="outline-text-headline-14" class="outline-text-3">
<p><strong>vi-backward-blank-word</strong> (unbound) (<strong>B</strong>) (unbound) Move backward one
word, where a word is defined as a series of non-blank characters.</p>
<dl>
<dt>
<strong>vi-backward-blank-word-end</strong> (unbound) (<strong>gE</strong>) (unbound)
</dt>
<dd>Move to the
end of the previous word, where a word is defined as a series of
non-blank characters.</dd>
<dt>
<strong>backward-char</strong> (<strong>^B ESC-[D</strong>) (unbound) (unbound)
</dt>
<dd>Move backward one
character.</dd>
<dt>
<strong>vi-backward-char</strong> (unbound) (<strong>^H h ^?</strong>) (<strong>ESC-[D</strong>)
</dt>
<dd>Move backward
one character, without changing lines.</dd>
<dt>
<strong>backward-word</strong> (<strong>ESC-B ESC-b</strong>) (unbound) (unbound)
</dt>
<dd>Move to the
beginning of the previous word.</dd>
<dt>
<strong>emacs-backward-word</strong>
</dt>
<dd>Move to the beginning of the previous word.</dd>
<dt>
<strong>vi-backward-word</strong> (unbound) (<strong>b</strong>) (unbound)
</dt>
<dd>Move to the beginning
of the previous word, vi-style.</dd>
<dt>
<strong>vi-backward-word-end</strong> (unbound) (<strong>ge</strong>) (unbound)
</dt>
<dd>Move to the end
of the previous word, vi-style.</dd>
<dt>
<strong>beginning-of-line</strong> (<strong>^A</strong>) (unbound) (unbound)
</dt>
<dd>Move to the
beginning of the line. If already at the beginning of the line, move
to the beginning of the previous line, if any.</dd>
<dt>
<strong>vi-beginning-of-line</strong>
</dt>
<dd>Move to the beginning of the line, without
changing lines.</dd>
<dt>
<strong>down-line</strong> (unbound) (unbound) (unbound)
</dt>
<dd>Move down a line in the
buffer.</dd>
<dt>
<strong>end-of-line</strong> (<strong>^E</strong>) (unbound) (unbound)
</dt>
<dd>Move to the end of the
line. If already at the end of the line, move to the end of the next
line, if any.</dd>
<dt>
<strong>vi-end-of-line</strong> (unbound) (<strong>$</strong>) (unbound)
</dt>
<dd>Move to the end of the
line. If an argument is given to this command, the cursor will be
moved to the end of the line (argument - 1) lines down.</dd>
<dt>
<strong>vi-forward-blank-word</strong> (unbound) (<strong>W</strong>) (unbound)
</dt>
<dd>Move forward one
word, where a word is defined as a series of non-blank characters.</dd>
<dt>
<strong>vi-forward-blank-word-end</strong> (unbound) (<strong>E</strong>) (unbound)
</dt>
<dd>Move to the
end of the current word, or, if at the end of the current word, to the
end of the next word, where a word is defined as a series of non-blank
characters.</dd>
<dt>
<strong>forward-char</strong> (<strong>^F ESC-[C</strong>) (unbound) (unbound)
</dt>
<dd>Move forward one
character.</dd>
<dt>
<strong>vi-forward-char</strong> (unbound) (<strong>space l</strong>) (<strong>ESC-[C</strong>)
</dt>
<dd>Move forward one
character.</dd>
<dt>
<strong>vi-find-next-char</strong> (<strong>^X^F</strong>) (<strong>f</strong>) (unbound)
</dt>
<dd>Read a character from
the keyboard, and move to the next occurrence of it in the line.</dd>
<dt>
<strong>vi-find-next-char-skip</strong> (unbound) (<strong>t</strong>) (unbound)
</dt>
<dd>Read a character
from the keyboard, and move to the position just before the next
occurrence of it in the line.</dd>
<dt>
<strong>vi-find-prev-char</strong> (unbound) (<strong>F</strong>) (unbound)
</dt>
<dd>Read a character from
the keyboard, and move to the previous occurrence of it in the line.</dd>
<dt>
<strong>vi-find-prev-char-skip</strong> (unbound) (<strong>T</strong>) (unbound)
</dt>
<dd>Read a character
from the keyboard, and move to the position just after the previous
occurrence of it in the line.</dd>
<dt>
<strong>vi-first-non-blank</strong> (unbound) (<strong>^</strong>) (unbound)
</dt>
<dd>Move to the first
non-blank character in the line.</dd>
<dt>
<strong>vi-forward-word</strong> (unbound) (<strong>w</strong>) (unbound)
</dt>
<dd>Move forward one word,
vi-style.</dd>
<dt>
<strong>forward-word</strong> (<strong>ESC-F ESC-f</strong>) (unbound) (unbound)
</dt>
<dd>Move to the
beginning of the next word. The editor&#39;s idea of a word is specified
with the <strong>WORDCHARS</strong> parameter.</dd>
<dt>
<strong>emacs-forward-word</strong>
</dt>
<dd>Move to the end of the next word.</dd>
<dt>
<strong>vi-forward-word-end</strong> (unbound) (<strong>e</strong>) (unbound)
</dt>
<dd>Move to the end of
the next word.</dd>
<dt>
<strong>vi-goto-column</strong> (<strong>ESC-|</strong>) (<strong>|</strong>) (unbound)
</dt>
<dd>Move to the column
specified by the numeric argument.</dd>
<dt>
<strong>vi-goto-mark</strong> (unbound) (<strong>`</strong>) (unbound)
</dt>
<dd>Move to the specified
mark.</dd>
<dt>
<strong>vi-goto-mark-line</strong> (unbound) (<strong>&#39;</strong>) (unbound)
</dt>
<dd>Move to beginning of
the line containing the specified mark.</dd>
<dt>
<strong>vi-repeat-find</strong> (unbound) (<strong>;</strong>) (unbound)
</dt>
<dd>Repeat the last
<strong>vi-find</strong> command.</dd>
<dt>
<strong>vi-rev-repeat-find</strong> (unbound) (<strong>,</strong>) (unbound)
</dt>
<dd>Repeat the last
<strong>vi-find</strong> command in the opposite direction.</dd>
<dt>
<strong>up-line</strong> (unbound) (unbound) (unbound)
</dt>
<dd>Move up a line in the
buffer.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-15" class="outline-3">
<h3 id="headline-15">
History Control
</h3>
<div id="outline-text-headline-15" class="outline-text-3">
<p><strong>beginning-of-buffer-or-history</strong> (<strong>ESC-&lt;</strong>) (<strong>gg</strong>) (unbound) Move to the
beginning of the buffer, or if already there, move to the first event in
the history list.</p>
<dl>
<dt>
<strong>beginning-of-line-hist</strong>
</dt>
<dd>Move to the beginning of the line. If
already at the beginning of the buffer, move to the previous history
line.</dd>
<dt>
<strong>beginning-of-history</strong>
</dt>
<dd>Move to the first event in the history list.</dd>
<dt>
<strong>down-line-or-history</strong> (<strong>^N ESC-[B</strong>) (<strong>j</strong>) (<strong>ESC-[B</strong>)
</dt>
<dd>Move down a
line in the buffer, or if already at the bottom line, move to the next
event in the history list.</dd>
<dt>
<strong>vi-down-line-or-history</strong> (unbound) (<strong>+</strong>) (unbound)
</dt>
<dd>Move down a
line in the buffer, or if already at the bottom line, move to the next
event in the history list. Then move to the first non-blank character
on the line.</dd>
<dt>
<strong>down-line-or-search</strong>
</dt>
<dd>Move down a line in the buffer, or if already
at the bottom line, search forward in the history for a line beginning
with the first word in the buffer.

If called from a function by the <strong>zle</strong> command with arguments, the
first argument is taken as the string for which to search, rather than
the first word in the buffer.</dd>
<dt>
<strong>down-history</strong> (unbound) (<strong>^N</strong>) (unbound)
</dt>
<dd>Move to the next event in
the history list.</dd>
<dt>
<strong>history-beginning-search-backward</strong>
</dt>
<dd>Search backward in the history
for a line beginning with the current line up to the cursor. This
leaves the cursor in its original position.</dd>
<dt>
<strong>end-of-buffer-or-history</strong> (<strong>ESC-&gt;</strong>) (unbound) (unbound)
</dt>
<dd>Move to
the end of the buffer, or if already there, move to the last event in
the history list.</dd>
<dt>
<strong>end-of-line-hist</strong>
</dt>
<dd>Move to the end of the line. If already at the
end of the buffer, move to the next history line.</dd>
<dt>
<strong>end-of-history</strong>
</dt>
<dd>Move to the last event in the history list.</dd>
<dt>
<strong>vi-fetch-history</strong> (unbound) (<strong>G</strong>) (unbound)
</dt>
<dd>Fetch the history line
specified by the numeric argument. This defaults to the current
history line (i.e. the one that isn&#39;t history yet).</dd>
<dt>
?
</dt>
<dd>
<p><strong>history-incremental-search-backward</strong> (<strong>^R ^Xr</strong>) (unbound)
(unbound) :: Search backward incrementally for a specified string. The
search is case-insensitive if the search string does not have
uppercase letters and no numeric argument was given. The string may
begin with `*^*&#39; to anchor the search to the beginning of the line.
When called from a user-defined function returns the following
statuses: 0, if the search succeeded; 1, if the search failed; 2, if
the search term was a bad pattern; 3, if the search was aborted by the
<strong>send-break</strong> command.</p>
<p>
A restricted set of editing functions is available in the mini-buffer.
Keys are looked up in the special <strong>isearch</strong> keymap, and if not found
there in the main keymap (note that by default the <strong>isearch</strong> keymap is
empty). An interrupt signal, as defined by the stty setting, will stop
the search and go back to the original line. An undefined key will
have the same effect. Note that the following always perform the same
task within incremental searches and cannot be replaced by user
defined widgets, nor can the set of functions be extended. The
supported functions are:</p>
<p>
<strong>accept-and-hold</strong></p>
<p>
<strong>accept-and-infer-next-history</strong></p>
<p>
<strong>accept-line</strong></p>
<p>
<strong>accept-line-and-down-history</strong> Perform the usual function after
exiting incremental search. The command line displayed is executed.</p>
<p>
<strong>backward-delete-char</strong></p>
<p>
<strong>vi-backward-delete-char</strong> Back up one place in the search history. If
the search has been repeated this does not immediately erase a
character in the minibuffer.</p>
<dl>
<dt>
<strong>accept-search</strong>
</dt>
<dd>Exit incremental search, retaining the command
line but performing no further action. Note that this function is
not bound by default and has no effect outside incremental search.</dd>
</dl>
<p><strong>backward-delete-word</strong></p>
<p>
<strong>backward-kill-word</strong></p>
<p>
<strong>vi-backward-kill-word</strong> Back up one character in the minibuffer; if
multiple searches have been performed since the character was inserted
the search history is rewound to the point just before the character
was entered. Hence this has the effect of repeating
<strong>backward-delete-char</strong>.</p>
<dl>
<dt>
<strong>clear-screen</strong>
</dt>
<dd>Clear the screen, remaining in incremental search
mode.</dd>
<dt>
<strong>history-incremental-search-backward</strong>
</dt>
<dd>Find the next occurrence of
the contents of the mini-buffer. If the mini-buffer is empty, the
most recent previously used search string is reinstated.</dd>
<dt>
<strong>history-incremental-search-forward</strong>
</dt>
<dd>Invert the sense of the
search.</dd>
<dt>
<strong>magic-space</strong>
</dt>
<dd>Inserts a non-magical space.</dd>
</dl>
<p><strong>quoted-insert</strong></p>
<p>
<strong>vi-quoted-insert</strong> Quote the character to insert into the minibuffer.</p>
<dl>
<dt>
<strong>redisplay</strong>
</dt>
<dd>Redisplay the command line, remaining in incremental
search mode.</dd>
<dt>
<strong>vi-cmd-mode</strong>
</dt>
<dd>Select the `*vicmd*&#39; keymap; the `*main*&#39; keymap
(insert mode) will be selected initially.

In addition, the modifications that were made while in vi insert
mode are merged to form a single undo event.</dd>
</dl>
<p><strong>vi-repeat-search</strong></p>
<p>
<strong>vi-rev-repeat-search</strong> Repeat the search. The direction of the search
is indicated in the mini-buffer.</p>
<p>
Any character that is not bound to one of the above functions, or
<strong>self-insert</strong> or <strong>self-insert-unmeta</strong>, will cause the mode to be
exited. The character is then looked up and executed in the keymap in
effect at that point.</p>
<p>
When called from a widget function by the <strong>zle</strong> command, the
incremental search commands can take a string argument. This will be
treated as a string of keys, as for arguments to the <strong>bindkey</strong>
command, and used as initial input for the command. Any characters in
the string which are unused by the incremental search will be silently
ignored. For example,</p>
<blockquote>
<pre class="example">
zle history-incremental-search-backward forceps
</pre>
</blockquote>
<p>
will search backwards for <strong>forceps</strong>, leaving the minibuffer containing
the string `*forceps*&#39;.</p>
</dd>
<dt>
?
</dt>
<dd><strong>history-incremental-search-forward</strong> (<strong>^S ^Xs</strong>) (unbound)
(unbound) :: Search forward incrementally for a specified string. The
search is case-insensitive if the search string does not have
uppercase letters and no numeric argument was given. The string may
begin with `*^*&#39; to anchor the search to the beginning of the line.
The functions available in the mini-buffer are the same as for
<strong>history-incremental-search-backward</strong>.</dd>
</dl>
<p><strong>history-incremental-pattern-search-backward</strong></p>
<p>
<strong>history-incremental-pattern-search-forward</strong> These widgets behave
similarly to the corresponding widgets with no <strong>-pattern</strong>, but the
search string typed by the user is treated as a pattern, respecting the
current settings of the various options affecting pattern matching. See
FILENAME GENERATION in /zshexpn/(1) for a description of patterns. If no
numeric argument was given lowercase letters in the search string may
match uppercase letters in the history. The string may begin with `*^*&#39;
to anchor the search to the beginning of the line.</p>
<blockquote>
<p>The prompt changes to indicate an invalid pattern; this may simply
indicate the pattern is not yet complete.</p>
<p>
Note that only non-overlapping matches are reported, so an expression
with wildcards may return fewer matches on a line than are visible by
inspection.</p>
</blockquote>
<ul>
<li><strong>history-search-backward</strong> (<strong>ESC-P ESC-p</strong>) (unbound)
(unbound) :: Search backward in the history for a line beginning with
the first word in the buffer.

If called from a function by the <strong>zle</strong> command with arguments, the
first argument is taken as the string for which to search, rather than
the first word in the buffer.</li>
<li><strong>vi-history-search-backward</strong> (unbound) (<strong>/</strong>) (unbound) :: Search
backward in the history for a specified string. The string may begin
with `*^*&#39; to anchor the search to the beginning of the line.

A restricted set of editing functions is available in the mini-buffer.
An interrupt signal, as defined by the stty setting, will stop the
search. The functions available in the mini-buffer are: <strong>accept-line</strong>,
<strong>backward-delete-char</strong>, <strong>vi-backward-delete-char</strong>,
<strong>backward-kill-word</strong>, <strong>vi-backward-kill-word</strong>, <strong>clear-screen</strong>,
<strong>redisplay</strong>, <strong>quoted-insert</strong> and <strong>vi-quoted-insert</strong>.

<strong>vi-cmd-mode</strong> is treated the same as accept-line, and <strong>magic-space</strong> is
treated as a space. Any other character that is not bound to
self-insert or self-insert-unmeta will beep and be ignored. If the
function is called from vi command mode, the bindings of the current
insert mode will be used.

If called from a function by the <strong>zle</strong> command with arguments, the
first argument is taken as the string for which to search, rather than
the first word in the buffer.</li>
<li><strong>history-search-forward</strong> (<strong>ESC-N ESC-n</strong>) (unbound) (unbound) :: Search
forward in the history for a line beginning with the first word in the
buffer.

If called from a function by the <strong>zle</strong> command with arguments, the
first argument is taken as the string for which to search, rather than
the first word in the buffer.</li>
<li><strong>vi-history-search-forward</strong> (unbound) (<strong>?</strong>) (unbound) :: Search
forward in the history for a specified string. The string may begin
with `*^*&#39; to anchor the search to the beginning of the line. The
functions available in the mini-buffer are the same as for
<strong>vi-history-search-backward</strong>. Argument handling is also the same as
for that command.</li>
<li><strong>infer-next-history</strong> (<strong>^X^N</strong>) (unbound) (unbound) :: Search in the
history list for a line matching the current one and fetch the event
following it.</li>
<li>
<p><strong>insert-last-word</strong> (<strong>ESC-_ ESC-.</strong>) (unbound) (unbound) :: Insert the
last word from the previous history event at the cursor position. If a
positive numeric argument is given, insert that word from the end of
the previous history event. If the argument is zero or negative insert
that word from the left (zero inserts the previous command word).
Repeating this command replaces the word just inserted with the last
word from the history event prior to the one just used; numeric
arguments can be used in the same way to pick a word from that event.</p>
<p>
When called from a shell function invoked from a user-defined widget,
the command can take one to three arguments. The first argument
specifies a history offset which applies to successive calls to this
widget: if it is -1, the default behaviour is used, while if it is 1,
successive calls will move forwards through the history. The value 0
can be used to indicate that the history line examined by the previous
execution of the command will be reexamined. Note that negative
numbers should be preceded by a `*–*&#39; argument to avoid confusing
them with options.</p>
<p>
If two arguments are given, the second specifies the word on the
command line in normal array index notation (as a more natural
alternative to the numeric argument). Hence 1 is the first word, and
-1 (the default) is the last word.</p>
<p>
If a third argument is given, its value is ignored, but it is used to
signify that the history offset is relative to the current history
line, rather than the one remembered after the previous invocations of
<strong>insert-last-word</strong>.</p>
<p>
For example, the default behaviour of the command corresponds to</p>
<blockquote>
<pre class="example">
zle insert-last-word -- -1 -1
</pre>
</blockquote>
<p>
while the command</p>
<blockquote>
<pre class="example">
zle insert-last-word -- -1 1 -
</pre>
</blockquote>
<p>
always copies the first word of the line in the history immediately
before the line being edited. This has the side effect that later
invocations of the widget will be relative to that line.</p>
</li>
<li><strong>vi-repeat-search</strong> (unbound) (<strong>n</strong>) (unbound) :: Repeat the last vi
history search.</li>
<li><strong>vi-rev-repeat-search</strong> (unbound) (<strong>N</strong>) (unbound) :: Repeat the last vi
history search, but in reverse.</li>
<li><strong>up-line-or-history</strong> (<strong>^P ESC-[A</strong>) (<strong>k</strong>) (<strong>ESC-[A</strong>) :: Move up a line
in the buffer, or if already at the top line, move to the previous
event in the history list.</li>
<li><strong>vi-up-line-or-history</strong> (unbound) (<strong>-</strong>) (unbound) :: Move up a line in
the buffer, or if already at the top line, move to the previous event
in the history list. Then move to the first non-blank character on the
line.</li>
<li><strong>up-line-or-search</strong> :: Move up a line in the buffer, or if already at
the top line, search backward in the history for a line beginning with
the first word in the buffer.

If called from a function by the <strong>zle</strong> command with arguments, the
first argument is taken as the string for which to search, rather than
the first word in the buffer.</li>
<li><strong>up-history</strong> (unbound) (<strong>^P</strong>) (unbound) :: Move to the previous event
in the history list.</li>
<li><strong>history-beginning-search-forward</strong> :: Search forward in the history
for a line beginning with the current line up to the cursor. This
leaves the cursor in its original position.</li>
<li><strong>set-local-history</strong> :: By default, history movement commands visit the
imported lines as well as the local lines. This widget lets you toggle
this on and off, or set it with the numeric argument. Zero for both
local and imported lines and nonzero for only local lines.</li>
</ul>
</div>
</div>
<div id="outline-container-headline-16" class="outline-3">
<h3 id="headline-16">
Modifying Text
</h3>
<div id="outline-text-headline-16" class="outline-text-3">
<p><strong>vi-add-eol</strong> (unbound) (<strong>A</strong>) (unbound) Move to the end of the line and
enter insert mode.</p>
<dl>
<dt>
<strong>vi-add-next</strong> (unbound) (<strong>a</strong>) (unbound)
</dt>
<dd>Enter insert mode after the
current cursor position, without changing lines.</dd>
<dt>
<strong>backward-delete-char</strong> (<strong>^H ^?</strong>) (unbound) (unbound)
</dt>
<dd>Delete the
character behind the cursor.</dd>
<dt>
<strong>vi-backward-delete-char</strong> (unbound) (<strong>X</strong>) (<strong>^H</strong>)
</dt>
<dd>Delete the
character behind the cursor, without changing lines. If in insert
mode, this won&#39;t delete past the point where insert mode was last
entered.</dd>
<dt>
<strong>backward-delete-word</strong>
</dt>
<dd>Delete the word behind the cursor.</dd>
<dt>
<strong>backward-kill-line</strong>
</dt>
<dd>Kill from the beginning of the line to the
cursor position.</dd>
<dt>
<strong>backward-kill-word</strong> (<strong>^W ESC-^H ESC-^?</strong>) (unbound) (unbound)
</dt>
<dd>Kill
the word behind the cursor.</dd>
<dt>
<strong>vi-backward-kill-word</strong> (unbound) (unbound) (<strong>^W</strong>)
</dt>
<dd>Kill the word
behind the cursor, without going past the point where insert mode was
last entered.</dd>
<dt>
<strong>capitalize-word</strong> (<strong>ESC-C ESC-c</strong>) (unbound) (unbound)
</dt>
<dd>Capitalize
the current word and move past it.</dd>
<dt>
<strong>vi-change</strong> (unbound) (<strong>c</strong>) (unbound)
</dt>
<dd>
<p>Read a movement command from
the keyboard, and kill from the cursor position to the endpoint of the
movement. Then enter insert mode. If the command is <strong>vi-change</strong>,
change the current line.</p>
<p>
For compatibility with vi, if the command is <strong>vi-forward-word</strong> or
<strong>vi-forward-blank-word</strong>, the whitespace after the word is not
included. If you prefer the more consistent behaviour with the
whitespace included use the following key binding:</p>
<blockquote>
<pre class="example">
bindkey -a -s cw dwi
</pre>
</blockquote>
</dd>
<dt>
<strong>vi-change-eol</strong> (unbound) (<strong>C</strong>) (unbound)
</dt>
<dd>Kill to the end of the
line and enter insert mode.</dd>
<dt>
<strong>vi-change-whole-line</strong> (unbound) (<strong>S</strong>) (unbound)
</dt>
<dd>Kill the current
line and enter insert mode.</dd>
<dt>
<strong>copy-region-as-kill</strong> (<strong>ESC-W ESC-w</strong>) (unbound) (unbound)
</dt>
<dd>Copy the
area from the cursor to the mark to the kill buffer.

If called from a ZLE widget function in the form `*zle*
copy-region-as-kill <em>string</em>&#39; then <em>string</em> will be taken as the text
to copy to the kill buffer. The cursor, the mark and the text on the
command line are not used in this case.</dd>
<dt>
<strong>copy-prev-word</strong> (<strong>ESC-^_</strong>) (unbound) (unbound)
</dt>
<dd>Duplicate the word
to the left of the cursor.</dd>
<dt>
<strong>copy-prev-shell-word</strong>
</dt>
<dd>Like <strong>copy-prev-word</strong>, but the word is found
by using shell parsing, whereas <strong>copy-prev-word</strong> looks for blanks.
This makes a difference when the word is quoted and contains spaces.</dd>
<dt>
<strong>vi-delete</strong> (unbound) (<strong>d</strong>) (unbound)
</dt>
<dd>Read a movement command from
the keyboard, and kill from the cursor position to the endpoint of the
movement. If the command is <strong>vi-delete</strong>, kill the current line.</dd>
<dt>
<strong>delete-char</strong>
</dt>
<dd>Delete the character under the cursor.</dd>
<dt>
<strong>vi-delete-char</strong> (unbound) (<strong>x</strong>) (unbound)
</dt>
<dd>Delete the character
under the cursor, without going past the end of the line.</dd>
<dt>
<strong>delete-word</strong>
</dt>
<dd>Delete the current word.</dd>
<dt>
<strong>down-case-word</strong> (<strong>ESC-L ESC-l</strong>) (unbound) (unbound)
</dt>
<dd>Convert the
current word to all lowercase and move past it.</dd>
<dt>
<strong>vi-down-case</strong> (unbound) (<strong>gu</strong>) (unbound)
</dt>
<dd>Read a movement command
from the keyboard, and convert all characters from the cursor position
to the endpoint of the movement to lowercase. If the movement command
is <strong>vi-down-case</strong>, swap the case of all characters on the current
line.</dd>
<dt>
<strong>kill-word</strong> (<strong>ESC-D ESC-d</strong>) (unbound) (unbound)
</dt>
<dd>Kill the current
word.</dd>
<dt>
<strong>gosmacs-transpose-chars</strong>
</dt>
<dd>Exchange the two characters behind the
cursor.</dd>
<dt>
<strong>vi-indent</strong> (unbound) (<strong>&gt;</strong>) (unbound)
</dt>
<dd>Indent a number of lines.</dd>
<dt>
<strong>vi-insert</strong> (unbound) (<strong>i</strong>) (unbound)
</dt>
<dd>Enter insert mode.</dd>
<dt>
<strong>vi-insert-bol</strong> (unbound) (<strong>I</strong>) (unbound)
</dt>
<dd>Move to the first
non-blank character on the line and enter insert mode.</dd>
<dt>
<strong>vi-join</strong> (<strong>^X^J</strong>) (<strong>J</strong>) (unbound)
</dt>
<dd>Join the current line with the
next one.</dd>
<dt>
<strong>kill-line</strong> (<strong>^K</strong>) (unbound) (unbound)
</dt>
<dd>Kill from the cursor to the
end of the line. If already on the end of the line, kill the newline
character.</dd>
<dt>
<strong>vi-kill-line</strong> (unbound) (unbound) (<strong>^U</strong>)
</dt>
<dd>Kill from the cursor back
to wherever insert mode was last entered.</dd>
<dt>
<strong>vi-kill-eol</strong> (unbound) (<strong>D</strong>) (unbound)
</dt>
<dd>Kill from the cursor to the
end of the line.</dd>
<dt>
<strong>kill-region</strong>
</dt>
<dd>Kill from the cursor to the mark.</dd>
<dt>
<strong>kill-buffer</strong> (<strong>^X^K</strong>) (unbound) (unbound)
</dt>
<dd>Kill the entire buffer.</dd>
<dt>
<strong>kill-whole-line</strong> (<strong>^U</strong>) (unbound) (unbound)
</dt>
<dd>Kill the current line.</dd>
<dt>
<strong>vi-match-bracket</strong> (<strong>^X^B</strong>) (<strong>%</strong>) (unbound)
</dt>
<dd>Move to the bracket
character (one of <strong>{}</strong>, <strong>()</strong> or <strong>[]</strong>) that matches the one under the
cursor. If the cursor is not on a bracket character, move forward
without going past the end of the line to find one, and then go to the
matching bracket.</dd>
<dt>
<strong>vi-open-line-above</strong> (unbound) (<strong>O</strong>) (unbound)
</dt>
<dd>Open a line above
the cursor and enter insert mode.</dd>
<dt>
<strong>vi-open-line-below</strong> (unbound) (<strong>o</strong>) (unbound)
</dt>
<dd>Open a line below
the cursor and enter insert mode.</dd>
<dt>
<strong>vi-oper-swap-case</strong> (unbound) (<strong>g~</strong>) (unbound)
</dt>
<dd>Read a movement
command from the keyboard, and swap the case of all characters from
the cursor position to the endpoint of the movement. If the movement
command is <strong>vi-oper-swap-case</strong>, swap the case of all characters on the
current line.</dd>
<dt>
<strong>overwrite-mode</strong> (<strong>^X^O</strong>) (unbound) (unbound)
</dt>
<dd>Toggle between
overwrite mode and insert mode.</dd>
<dt>
<strong>vi-put-before</strong> (unbound) (<strong>P</strong>) (unbound)
</dt>
<dd>Insert the contents of
the kill buffer before the cursor. If the kill buffer contains a
sequence of lines (as opposed to characters), paste it above the
current line.</dd>
<dt>
<strong>vi-put-after</strong> (unbound) (<strong>p</strong>) (unbound)
</dt>
<dd>Insert the contents of the
kill buffer after the cursor. If the kill buffer contains a sequence
of lines (as opposed to characters), paste it below the current line.</dd>
<dt>
<strong>put-replace-selection</strong> (unbound) (unbound) (unbound)
</dt>
<dd>Replace the
contents of the current region or selection with the contents of the
kill buffer. If the kill buffer contains a sequence of lines (as
opposed to characters), the current line will be split by the pasted
lines.</dd>
<dt>
<strong>quoted-insert</strong> (<strong>^V</strong>) (unbound) (unbound)
</dt>
<dd>Insert the next
character typed into the buffer literally. An interrupt character will
not be inserted.</dd>
<dt>
<strong>vi-quoted-insert</strong> (unbound) (unbound) (<strong>^Q ^V</strong>)
</dt>
<dd>Display a `*^*&#39; at
the cursor position, and insert the next character typed into the
buffer literally. An interrupt character will not be inserted.</dd>
<dt>
<strong>quote-line</strong> (<strong>ESC-&#39;</strong>) (unbound) (unbound)
</dt>
<dd>Quote the current line;
that is, put a `*&#39;<strong>&#39; character at the beginning and the end, and
convert all `</strong>&#39;<strong>&#39; characters to `</strong>&#39;\&#39;&#39;*&#39;.</dd>
<dt>
<strong>quote-region</strong> (<strong>ESC-&#34;</strong>) (unbound) (unbound)
</dt>
<dd>Quote the region from
the cursor to the mark.</dd>
<dt>
<strong>vi-replace</strong> (unbound) (<strong>R</strong>) (unbound)
</dt>
<dd>Enter overwrite mode.</dd>
<dt>
<strong>vi-repeat-change</strong> (unbound) (<strong>.</strong>) (unbound)
</dt>
<dd>Repeat the last vi
mode text modification. If a count was used with the modification, it
is remembered. If a count is given to this command, it overrides the
remembered count, and is remembered for future uses of this command.
The cut buffer specification is similarly remembered.</dd>
<dt>
<strong>vi-replace-chars</strong> (unbound) (<strong>r</strong>) (unbound)
</dt>
<dd>Replace the character
under the cursor with a character read from the keyboard.</dd>
<dt>
?
</dt>
<dd><strong>self-insert</strong> (printable characters) (unbound) (printable characters
and some control characters) :: Insert a character into the buffer at
the cursor position.</dd>
<dt>
?
</dt>
<dd><strong>self-insert-unmeta</strong> (<strong>ESC-^I ESC-^J ESC-^M</strong>) (unbound)
(unbound) :: Insert a character into the buffer after stripping the
meta bit and converting ^M to ^J.</dd>
<dt>
<strong>vi-substitute</strong> (unbound) (<strong>s</strong>) (unbound)
</dt>
<dd>Substitute the next
character(s).</dd>
<dt>
<strong>vi-swap-case</strong> (unbound) (<strong>~</strong>) (unbound)
</dt>
<dd>Swap the case of the
character under the cursor and move past it.</dd>
<dt>
<strong>transpose-chars</strong> (<strong>^T</strong>) (unbound) (unbound)
</dt>
<dd>Exchange the two
characters to the left of the cursor if at end of line, else exchange
the character under the cursor with the character to the left.</dd>
<dt>
<strong>transpose-words</strong> (<strong>ESC-T ESC-t</strong>) (unbound) (unbound)
</dt>
<dd>Exchange the
current word with the one before it.

With a positive numeric argument <em>N</em>, the word around the cursor, or
following it if the cursor is between words, is transposed with the
preceding <em>N</em> words. The cursor is put at the end of the resulting
group of words.

With a negative numeric argument <em>-N</em>, the effect is the same as using
a positive argument <em>N</em> except that the original cursor position is
retained, regardless of how the words are rearranged.</dd>
<dt>
<strong>vi-unindent</strong> (unbound) (<strong>&lt;</strong>) (unbound)
</dt>
<dd>Unindent a number of lines.</dd>
<dt>
<strong>vi-up-case</strong> (unbound) (<strong>gU</strong>) (unbound)
</dt>
<dd>Read a movement command
from the keyboard, and convert all characters from the cursor position
to the endpoint of the movement to lowercase. If the movement command
is <strong>vi-up-case</strong>, swap the case of all characters on the current line.</dd>
<dt>
<strong>up-case-word</strong> (<strong>ESC-U ESC-u</strong>) (unbound) (unbound)
</dt>
<dd>Convert the
current word to all caps and move past it.</dd>
<dt>
<strong>yank</strong> (<strong>^Y</strong>) (unbound) (unbound)
</dt>
<dd>Insert the contents of the kill
buffer at the cursor position.</dd>
<dt>
<strong>yank-pop</strong> (<strong>ESC-y</strong>) (unbound) (unbound)
</dt>
<dd>Remove the text just
yanked, rotate the kill-ring (the history of previously killed text)
and yank the new top. Only works following <strong>yank</strong>, <strong>vi-put-before</strong>,
<strong>vi-put-after</strong> or <strong>yank-pop</strong>.</dd>
<dt>
<strong>vi-yank</strong> (unbound) (<strong>y</strong>) (unbound)
</dt>
<dd>Read a movement command from
the keyboard, and copy the region from the cursor position to the
endpoint of the movement into the kill buffer. If the command is
<strong>vi-yank</strong>, copy the current line.</dd>
<dt>
<strong>vi-yank-whole-line</strong> (unbound) (<strong>Y</strong>) (unbound)
</dt>
<dd>Copy the current
line into the kill buffer.</dd>
<dt>
<strong>vi-yank-eol</strong>
</dt>
<dd>Copy the region from the cursor position to the end
of the line into the kill buffer. Arguably, this is what Y should do
in vi, but it isn&#39;t what it actually does.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-17" class="outline-3">
<h3 id="headline-17">
Arguments
</h3>
<div id="outline-text-headline-17" class="outline-text-3">
<p><strong>digit-argument</strong> (<strong>ESC-0</strong>..*ESC-9*) (<strong>1</strong>-<strong>9</strong>) (unbound) Start a new
numeric argument, or add to the current one. See also
<strong>vi-digit-or-beginning-of-line</strong>. This only works if bound to a key
sequence ending in a decimal digit.</p>
<blockquote>
<p>Inside a widget function, a call to this function treats the last key of
the key sequence which called the widget as the digit.</p>
</blockquote>
<dl>
<dt>
<strong>neg-argument</strong> (<strong>ESC–</strong>) (unbound) (unbound)
</dt>
<dd>Changes the sign of
the following argument.</dd>
<dt>
<strong>universal-argument</strong>
</dt>
<dd>Multiply the argument of the next command
by 4. Alternatively, if this command is followed by an integer
(positive or negative), use that as the argument for the next command.
Thus digits cannot be repeated using this command. For example, if
this command occurs twice, followed immediately by <strong>forward-char</strong>,
move forward sixteen spaces; if instead it is followed by <strong>-2</strong>, then
<strong>forward-char</strong>, move backward two spaces.

Inside a widget function, if passed an argument, i.e. `*zle*
universal-argument <em>num</em>&#39;, the numeric argument will be set to <em>num</em>;
this is equivalent to `*NUMERIC=*/num/&#39;.</dd>
<dt>
<strong>argument-base</strong>
</dt>
<dd>
<p>Use the existing numeric argument as a numeric
base, which must be in the range 2 to 36 inclusive. Subsequent use of
<strong>digit-argument</strong> and <strong>universal-argument</strong> will input a new numeric
argument in the given base. The usual hexadecimal convention is used:
the letter <strong>a</strong> or <strong>A</strong> corresponds to 10, and so on. Arguments in bases
requiring digits from 10 upwards are more conveniently input with
<strong>universal-argument</strong>, since <strong>ESC-a</strong> etc. are not usually bound to
<strong>digit-argument</strong>.</p>
<p>
The function can be used with a command argument inside a user-defined
widget. The following code sets the base to 16 and lets the user input
a hexadecimal argument until a key out of the digit range is typed:</p>
<blockquote>
<pre class="example">
zle argument-base 16
zle universal-argument
</pre>
</blockquote>
</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-18" class="outline-3">
<h3 id="headline-18">
Completion
</h3>
<div id="outline-text-headline-18" class="outline-text-3">
<p><strong>accept-and-menu-complete</strong> In a menu completion, insert the current
completion into the buffer, and advance to the next possible completion.</p>
<dl>
<dt>
<strong>complete-word</strong>
</dt>
<dd>Attempt completion on the current word.</dd>
<dt>
<strong>delete-char-or-list</strong> (<strong>^D</strong>) (unbound) (unbound)
</dt>
<dd>Delete the
character under the cursor. If the cursor is at the end of the line,
list possible completions for the current word.</dd>
<dt>
<strong>expand-cmd-path</strong>
</dt>
<dd>Expand the current command to its full pathname.</dd>
<dt>
<strong>expand-or-complete</strong> (<strong>TAB</strong>) (unbound) (<strong>TAB</strong>)
</dt>
<dd>Attempt shell
expansion on the current word. If that fails, attempt completion.</dd>
<dt>
<strong>expand-or-complete-prefix</strong>
</dt>
<dd>Attempt shell expansion on the current
word up to cursor.</dd>
<dt>
<strong>expand-history</strong> (<strong>ESC-space ESC-!</strong>) (unbound) (unbound)
</dt>
<dd>Perform
history expansion on the edit buffer.</dd>
<dt>
<strong>expand-word</strong> (<strong>^X*</strong>) (unbound) (unbound)
</dt>
<dd>Attempt shell expansion
on the current word.</dd>
<dt>
<strong>list-choices</strong> (<strong>ESC-^D</strong>) (<strong>^D =</strong>) (<strong>^D</strong>)
</dt>
<dd>List possible completions
for the current word.</dd>
<dt>
<strong>list-expand</strong> (<strong>^Xg ^XG</strong>) (<strong>^G</strong>) (<strong>^G</strong>)
</dt>
<dd>List the expansion of the
current word.</dd>
<dt>
<strong>magic-space</strong>
</dt>
<dd>Perform history expansion and insert a space into the
buffer. This is intended to be bound to space.</dd>
<dt>
<strong>menu-complete</strong>
</dt>
<dd>Like <strong>complete-word</strong>, except that menu completion
is used. See the <strong>MENU_COMPLETE</strong> option.</dd>
<dt>
<strong>menu-expand-or-complete</strong>
</dt>
<dd>Like <strong>expand-or-complete</strong>, except that
menu completion is used.</dd>
<dt>
<strong>reverse-menu-complete</strong>
</dt>
<dd>Perform menu completion, like
<strong>menu-complete</strong>, except that if a menu completion is already in
progress, move to the <em>previous</em> completion rather than the next.</dd>
<dt>
<strong>end-of-list</strong>
</dt>
<dd>When a previous completion displayed a list below the
prompt, this widget can be used to move the prompt below the list.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-19" class="outline-3">
<h3 id="headline-19">
Miscellaneous
</h3>
<div id="outline-text-headline-19" class="outline-text-3">
<p><strong>accept-and-hold</strong> (<strong>ESC-A ESC-a</strong>) (unbound) (unbound) Push the contents
of the buffer on the buffer stack and execute it.</p>
<dl>
<dt>
<strong>accept-and-infer-next-history</strong>
</dt>
<dd>Execute the contents of the buffer.
Then search the history list for a line matching the current one and
push the event following onto the buffer stack.</dd>
<dt>
<strong>accept-line</strong> (<strong>^J ^M</strong>) (<strong>^J ^M</strong>) (<strong>^J ^M</strong>)
</dt>
<dd>Finish editing the
buffer. Normally this causes the buffer to be executed as a shell
command.</dd>
<dt>
<strong>accept-line-and-down-history</strong> (<strong>^O</strong>) (unbound) (unbound)
</dt>
<dd>Execute
the current line, and push the next history event on the buffer stack.</dd>
<dt>
<strong>auto-suffix-remove</strong>
</dt>
<dd>If the previous action added a suffix (space,
slash, etc.) to the word on the command line, remove it. Otherwise do
nothing. Removing the suffix ends any active menu completion or menu
selection.

This widget is intended to be called from user-defined widgets to
enforce a desired suffix-removal behavior.</dd>
<dt>
<strong>auto-suffix-retain</strong>
</dt>
<dd>If the previous action added a suffix (space,
slash, etc.) to the word on the command line, force it to be
preserved. Otherwise do nothing. Retaining the suffix ends any active
menu completion or menu selection.

This widget is intended to be called from user-defined widgets to
enforce a desired suffix-preservation behavior.</dd>
<dt>
<strong>beep</strong>
</dt>
<dd>Beep, unless the <strong>BEEP</strong> option is unset.</dd>
<dt>
<strong>bracketed-paste</strong> (<strong>^[[200~</strong>) (<strong>^[[200~</strong>) (<strong>^[[200~</strong>)
</dt>
<dd>This widget
is invoked when text is pasted to the terminal emulator. It is not
intended to be bound to actual keys but instead to the special
sequence generated by the terminal emulator when text is pasted.

When invoked interactively, the pasted text is inserted to the buffer
and placed in the cutbuffer. If a numeric argument is given, shell
quoting will be applied to the pasted text before it is inserted.

When a named buffer is specified with <strong>vi-set-buffer</strong> (<strong>&#34;x</strong>), the
pasted text is stored in that named buffer but not inserted.

When called from a widget function as `*bracketed-paste* <em>name/`, the
pasted text is assigned to the variable /name</em> and no other processing
is done.

See also the <strong>zle_bracketed_paste</strong> parameter.</dd>
<dt>
<strong>vi-cmd-mode</strong> (<strong>^X^V</strong>) (unbound) (<strong>^[</strong>)
</dt>
<dd>Enter command mode; that
is, select the `*vicmd*&#39; keymap. Yes, this is bound by default in
emacs mode.</dd>
<dt>
<strong>vi-caps-lock-panic</strong>
</dt>
<dd>Hang until any lowercase key is pressed. This
is for vi users without the mental capacity to keep track of their
caps lock key (like the author).</dd>
<dt>
<strong>clear-screen</strong> (<strong>^L ESC-^L</strong>) (<strong>^L</strong>) (<strong>^L</strong>)
</dt>
<dd>Clear the screen and
redraw the prompt.</dd>
<dt>
<strong>deactivate-region</strong>
</dt>
<dd>Make the current region inactive. This disables
vim-style visual selection mode if it is active.</dd>
<dt>
<strong>describe-key-briefly</strong>
</dt>
<dd>Reads a key sequence, then prints the
function bound to that sequence.</dd>
<dt>
<strong>exchange-point-and-mark</strong> (<strong>^X^X</strong>) (unbound) (unbound)
</dt>
<dd>Exchange the
cursor position (point) with the position of the mark. Unless a
negative numeric argument is given, the region between point and mark
is activated so that it can be highlighted. If a zero numeric argument
is given, the region is activated but point and mark are not swapped.</dd>
<dt>
<strong>execute-named-cmd</strong> (<strong>ESC-x</strong>) (<strong>:</strong>) (unbound)
</dt>
<dd>Read the name of an
editor command and execute it. Aliasing this widget with `*zle -A*&#39; or
replacing it with `*zle -N*&#39; has no effect when interpreting key
bindings, but `*zle execute-named-cmd*&#39; will invoke such an alias or
replacement.

A restricted set of editing functions is available in the mini-buffer.
Keys are looked up in the special <strong>command</strong> keymap, and if not found
there in the main keymap. An interrupt signal, as defined by the stty
setting, will abort the function. Note that the following always
perform the same task within the <strong>executed-named-cmd</strong> environment and
cannot be replaced by user defined widgets, nor can the set of
functions be extended. The allowed functions are:
<strong>backward-delete-char</strong>, <strong>vi-backward-delete-char</strong>, <strong>clear-screen</strong>,
<strong>redisplay</strong>, <strong>quoted-insert</strong>, <strong>vi-quoted-insert</strong>,
<strong>backward-kill-word</strong>, <strong>vi-backward-kill-word</strong>, <strong>kill-whole-line</strong>,
<strong>vi-kill-line</strong>, <strong>backward-kill-line</strong>, <strong>list-choices</strong>,
<strong>delete-char-or-list</strong>, <strong>complete-word</strong>, <strong>accept-line</strong>,
<strong>expand-or-complete</strong> and <strong>expand-or-complete-prefix</strong>.

<strong>kill-region</strong> kills the last word, and vi-cmd-mode is treated the same
as accept-line. The space and tab characters, if not bound to one of
these functions, will complete the name and then list the
possibilities if the <strong>AUTO_LIST</strong> option is set. Any other character
that is not bound to <strong>self-insert</strong> or <strong>self-insert-unmeta</strong> will beep
and be ignored. The bindings of the current insert mode will be used.

Currently this command may not be redefined or called by name.</dd>
<dt>
<strong>execute-last-named-cmd</strong> (<strong>ESC-z</strong>) (unbound) (unbound)
</dt>
<dd>Redo the
last function executed with <strong>execute-named-cmd</strong>.

Like <strong>execute-named-cmd</strong>, this command may not be redefined, but it
may be called by name.</dd>
<dt>
<strong>get-line</strong> (<strong>ESC-G ESC-g</strong>) (unbound) (unbound)
</dt>
<dd>Pop the top line off
the buffer stack and insert it at the cursor position.</dd>
<dt>
<strong>pound-insert</strong> (unbound) (<strong>#</strong>) (unbound)
</dt>
<dd>If there is no # character
at the beginning of the buffer, add one to the beginning of each line.
If there is one, remove a # from each line that has one. In either
case, accept the current line. The <strong>INTERACTIVE_COMMENTS</strong> option must
be set for this to have any usefulness.</dd>
<dt>
<strong>vi-pound-insert</strong>
</dt>
<dd>If there is no # character at the beginning of
the current line, add one. If there is one, remove it. The
<strong>INTERACTIVE_COMMENTS</strong> option must be set for this to have any
usefulness.</dd>
<dt>
<strong>push-input</strong>
</dt>
<dd>Push the entire current multiline construct onto the
buffer stack and return to the top-level (<strong>PS1</strong>) prompt. If the
current parser construct is only a single line, this is exactly like
<strong>push-line</strong>. Next time the editor starts up or is popped with
<strong>get-line</strong>, the construct will be popped off the top of the buffer
stack and loaded into the editing buffer.</dd>
<dt>
<strong>push-line</strong> (<strong>^Q ESC-Q ESC-q</strong>) (unbound) (unbound)
</dt>
<dd>Push the current
buffer onto the buffer stack and clear the buffer. Next time the
editor starts up, the buffer will be popped off the top of the buffer
stack and loaded into the editing buffer.</dd>
<dt>
<strong>push-line-or-edit</strong>
</dt>
<dd>At the top-level (<strong>PS1</strong>) prompt, equivalent to
<strong>push-line</strong>. At a secondary (<strong>PS2</strong>) prompt, move the entire current
multiline construct into the editor buffer. The latter is equivalent
to <strong>push-input</strong> followed by <strong>get-line</strong>.</dd>
<dt>
<strong>read-command</strong>
</dt>
<dd>Only useful from a user-defined widget. A keystroke
is read just as in normal operation, but instead of the command being
executed the name of the command that would be executed is stored in
the shell parameter <strong>REPLY</strong>. This can be used as the argument of a
future <strong>zle</strong> command. If the key sequence is not bound, status 1 is
returned; typically, however, <strong>REPLY</strong> is set to <strong>undefined-key</strong> to
indicate a useless key sequence.</dd>
<dt>
<strong>recursive-edit</strong>
</dt>
<dd>
<p>Only useful from a user-defined widget. At this
point in the function, the editor regains control until one of the
standard widgets which would normally cause zle to exit (typically an
<strong>accept-line</strong> caused by hitting the return key) is executed. Instead,
control returns to the user-defined widget. The status returned is
non-zero if the return was caused by an error, but the function still
continues executing and hence may tidy up. This makes it safe for the
user-defined widget to alter the command line or key bindings
temporarily.</p>
<p>
The following widget, <strong>caps-lock</strong>, serves as an example.</p>
<blockquote>
<pre class="example">
self-insert-ucase() {
  LBUFFER+=${(U)KEYS[-1]}
}

integer stat

zle -N self-insert self-insert-ucase
zle -A caps-lock save-caps-lock
zle -A accept-line caps-lock

zle recursive-edit
stat=$?

zle -A .self-insert self-insert
zle -A save-caps-lock caps-lock
zle -D save-caps-lock

(( stat )) &amp;&amp; zle send-break

return $stat
</pre>
</blockquote>
<p>
This causes typed letters to be inserted capitalised until either
<strong>accept-line</strong> (i.e. typically the return key) is typed or the
<strong>caps-lock</strong> widget is invoked again; the later is handled by saving
the old definition of <strong>caps-lock</strong> as <strong>save-caps-lock</strong> and then
rebinding it to invoke <strong>accept-line</strong>. Note that an error from the
recursive edit is detected as a non-zero return status and propagated
by using the <strong>send-break</strong> widget.</p>
</dd>
<dt>
<strong>redisplay</strong> (unbound) (<strong>^R</strong>) (<strong>^R</strong>)
</dt>
<dd>Redisplays the edit buffer.</dd>
<dt>
<strong>reset-prompt</strong> (unbound) (unbound) (unbound)
</dt>
<dd>Force the prompts on
both the left and right of the screen to be re-expanded, then
redisplay the edit buffer. This reflects changes both to the prompt
variables themselves and changes in the expansion of the values (for
example, changes in time or directory, or changes to the value of
variables referred to by the prompt).

Otherwise, the prompt is only expanded each time zle starts, and when
the display has been interrupted by output from another part of the
shell (such as a job notification) which causes the command line to be
reprinted.

<strong>reset-prompt</strong> doesn&#39;t alter the special parameter <strong>LASTWIDGET</strong>.</dd>
<dt>
<strong>send-break</strong> (<strong>^G ESC-^G</strong>) (unbound) (unbound)
</dt>
<dd>Abort the current
editor function, e.g. <strong>execute-named-command</strong>, or the editor itself,
e.g. if you are in <strong>vared</strong>. Otherwise abort the parsing of the current
line; in this case the aborted line is available in the shell variable
<strong>ZLE_LINE_ABORTED</strong>. If the editor is aborted from within <strong>vared</strong>, the
variable <strong>ZLE_VARED_ABORTED</strong> is set.</dd>
<dt>
<strong>run-help</strong> (<strong>ESC-H ESC-h</strong>) (unbound) (unbound)
</dt>
<dd>Push the buffer onto
the buffer stack, and execute the command `*run-help* <em>cmd</em>&#39;, where
<em>cmd</em> is the current command. <strong>run-help</strong> is normally aliased to <strong>man</strong>.</dd>
<dt>
<strong>vi-set-buffer</strong> (unbound) (<strong>&#34;</strong>) (unbound)
</dt>
<dd>
<p>Specify a buffer to be
used in the following command. There are 37 buffers that can be
specified: the 26 `named&#39; buffers <strong>&#34;a</strong> to <strong>&#34;z</strong>, the `yank&#39; buffer
<strong>&#34;0</strong>, the nine `queued&#39; buffers <strong>&#34;1</strong> to <strong>&#34;9</strong> and the `black hole&#39;
buffer <strong>&#34;_</strong>. The named buffers can also be specified as <strong>&#34;A</strong> to <strong>&#34;Z</strong>.</p>
<p>
When a buffer is specified for a cut, change or yank command, the text
concerned replaces the previous contents of the specified buffer. If a
named buffer is specified using a capital, the newly cut text is
appended to the buffer instead of overwriting it. When using the <strong>&#34;_</strong>
buffer, nothing happens. This can be useful for deleting text without
affecting any buffers.</p>
<p>
If no buffer is specified for a cut or change command, <strong>&#34;1</strong> is used,
and the contents of <strong>&#34;1</strong> to <strong>&#34;8</strong> are each shifted along one buffer;
the contents of <strong>&#34;9</strong> is lost. If no buffer is specified for a yank
command, <strong>&#34;0</strong> is used. Finally, a paste command without a specified
buffer will paste the text from the most recent command regardless of
any buffer that might have been used with that command.</p>
<p>
When called from a widget function by the <strong>zle</strong> command, the buffer
can optionally be specified with an argument. For example,</p>
<blockquote>
<pre class="example">
zle vi-set-buffer A
</pre>
</blockquote>
</dd>
<dt>
<strong>vi-set-mark</strong> (unbound) (<strong>m</strong>) (unbound)
</dt>
<dd>Set the specified mark at
the cursor position.</dd>
<dt>
<strong>set-mark-command</strong> (<strong>^@</strong>) (unbound) (unbound)
</dt>
<dd>Set the mark at the
cursor position. If called with a negative numeric argument, do not
set the mark but deactivate the region so that it is no longer
highlighted (it is still usable for other purposes). Otherwise the
region is marked as active.</dd>
<dt>
<strong>spell-word</strong> (<strong>ESC-$ ESC-S ESC-s</strong>) (unbound) (unbound)
</dt>
<dd>Attempt
spelling correction on the current word.</dd>
<dt>
<strong>split-undo</strong>
</dt>
<dd>Breaks the undo sequence at the current change. This
is useful in vi mode as changes made in insert mode are coalesced on
entering command mode. Similarly, <strong>undo</strong> will normally revert as one
all the changes made by a user-defined widget.</dd>
<dt>
<strong>undefined-key</strong>
</dt>
<dd>This command is executed when a key sequence that
is not bound to any command is typed. By default it beeps.</dd>
<dt>
<strong>undo</strong> (<strong>^_ ^Xu ^X^U</strong>) (<strong>u</strong>) (unbound)
</dt>
<dd>Incrementally undo the last
text modification. When called from a user-defined widget, takes an
optional argument indicating a previous state of the undo history as
returned by the <strong>UNDO_CHANGE_NO</strong> variable; modifications are undone
until that state is reached, subject to any limit imposed by the
<strong>UNDO_LIMIT_NO</strong> variable.

Note that when invoked from vi command mode, the full prior change
made in insert mode is reverted, the changes having been merged when
command mode was selected.</dd>
<dt>
<strong>redo</strong> (unbound) (<strong>^R</strong>) (unbound)
</dt>
<dd>Incrementally redo undone text
modifications.</dd>
<dt>
<strong>vi-undo-change</strong> (unbound) (unbound) (unbound)
</dt>
<dd>Undo the last text
modification. If repeated, redo the modification.</dd>
<dt>
<strong>visual-mode</strong> (unbound) (<strong>v</strong>) (unbound)
</dt>
<dd>Toggle vim-style visual
selection mode. If line-wise visual mode is currently enabled then it
is changed to being character-wise. If used following an operator, it
forces the subsequent movement command to be treated as a
character-wise movement.</dd>
<dt>
<strong>visual-line-mode</strong> (unbound) (<strong>V</strong>) (unbound)
</dt>
<dd>Toggle vim-style
line-wise visual selection mode. If character-wise visual mode is
currently enabled then it is changed to being line-wise. If used
following an operator, it forces the subsequent movement command to be
treated as a line-wise movement.</dd>
<dt>
<strong>what-cursor-position</strong> (<strong>^X=</strong>) (<strong>ga</strong>) (unbound)
</dt>
<dd>Print the character
under the cursor, its code as an octal, decimal and hexadecimal
number, the current cursor position within the buffer and the column
of the cursor in the current line.</dd>
<dt>
<strong>where-is</strong>
</dt>
<dd>Read the name of an editor command and print the listing
of key sequences that invoke the specified command. A restricted set
of editing functions is available in the mini-buffer. Keys are looked
up in the special <strong>command</strong> keymap, and if not found there in the main
keymap.</dd>
<dt>
<strong>which-command</strong> (<strong>ESC-?</strong>) (unbound) (unbound)
</dt>
<dd>Push the buffer onto
the buffer stack, and execute the command `*which-command* <em>cmd</em>&#39;.
where <em>cmd</em> is the current command. <strong>which-command</strong> is normally
aliased to <strong>whence</strong>.</dd>
<dt>
<strong>vi-digit-or-beginning-of-line</strong> (unbound) (<strong>0</strong>) (unbound)
</dt>
<dd>If the
last command executed was a digit as part of an argument, continue the
argument. Otherwise, execute vi-beginning-of-line.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-20" class="outline-3">
<h3 id="headline-20">
Text Objects
</h3>
<div id="outline-text-headline-20" class="outline-text-3">
<p>Text objects are commands that can be used to select a block of text
according to some criteria. They are a feature of the vim text editor
and so are primarily intended for use with vi operators or from visual
selection mode. However, they can also be used from vi-insert or emacs
mode. Key bindings listed below apply to the <strong>viopp</strong> and <strong>visual</strong>
keymaps.</p>
<p>
<strong>select-a-blank-word</strong> (<strong>aW</strong>) Select a word including adjacent blanks,
where a word is defined as a series of non-blank characters. With a
numeric argument, multiple words will be selected.</p>
<dl>
<dt>
<strong>select-a-shell-word</strong> (<strong>aa</strong>)
</dt>
<dd>Select the current command argument
applying the normal rules for quoting.</dd>
<dt>
<strong>select-a-word</strong> (<strong>aw</strong>)
</dt>
<dd>Select a word including adjacent blanks,
using the normal vi-style word definition. With a numeric argument,
multiple words will be selected.</dd>
<dt>
<strong>select-in-blank-word</strong> (<strong>iW</strong>)
</dt>
<dd>Select a word, where a word is
defined as a series of non-blank characters. With a numeric argument,
multiple words will be selected.</dd>
<dt>
<strong>select-in-shell-word</strong> (<strong>ia</strong>)
</dt>
<dd>Select the current command argument
applying the normal rules for quoting. If the argument begins and ends
with matching quote characters, these are not included in the
selection.</dd>
<dt>
<strong>select-in-word</strong> (<strong>iw</strong>)
</dt>
<dd>Select a word, using the normal vi-style
word definition. With a numeric argument, multiple words will be
selected.</dd>
</dl>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-21" class="outline-2">
<h2 id="headline-21">
CHARACTER HIGHLIGHTING
</h2>
<div id="outline-text-headline-21" class="outline-text-2">
<p>The line editor has the ability to highlight characters or regions of
the line that have a particular significance. This is controlled by the
array parameter <strong>zle_highlight</strong>, if it has been set by the user.</p>
<p>
If the parameter contains the single entry <strong>none</strong> all highlighting is
turned off. Note the parameter is still expected to be an array.</p>
<p>
Otherwise each entry of the array should consist of a word indicating a
context for highlighting, then a colon, then a comma-separated list of
the types of highlighting to apply in that context.</p>
<p>
The contexts available for highlighting are the following:</p>
<p>
<strong>default</strong> Any text within the command line not affected by any other
highlighting. Text outside the editable area of the command line is not
affected.</p>
<dl>
<dt>
<strong>isearch</strong>
</dt>
<dd>When one of the incremental history search widgets is
active, the area of the command line matched by the search string or
pattern.</dd>
<dt>
<strong>region</strong>
</dt>
<dd>The currently selected text. In emacs terminology, this is
referred to as the region and is bounded by the cursor (point) and the
mark. The region is only highlighted if it is active, which is the
case after the mark is modified with <strong>set-mark-command</strong> or
<strong>exchange-point-and-mark</strong>. Note that whether or not the region is
active has no effect on its use within emacs style widgets, it simply
determines whether it is highlighted. In vi mode, the region
corresponds to selected text in visual mode.</dd>
<dt>
<strong>special</strong>
</dt>
<dd>Individual characters that have no direct printable
representation but are shown in a special manner by the line editor.
These characters are described below.</dd>
<dt>
<strong>suffix</strong>
</dt>
<dd>This context is used in completion for characters that are
marked as suffixes that will be removed if the completion ends at that
point, the most obvious example being a slash (<strong>/</strong>) after a directory
name. Note that suffix removal is configurable; the circumstances
under which the suffix will be removed may differ for different
completions.</dd>
<dt>
<strong>paste</strong>
</dt>
<dd>Following a command to paste text, the characters that were
inserted.</dd>
</dl>
<p>When <strong>region_highlight</strong> is set, the contexts that describe a region –
<strong>isearch</strong>, <strong>region</strong>, <strong>suffix</strong>, and <strong>paste</strong> – are applied first, then
<strong>region_highlight</strong> is applied, then the remaining <strong>zle_highlight</strong>
contexts are applied. If a particular character is affected by multiple
specifications, the last specification wins.</p>
<p>
<strong>zle_highlight</strong> may contain additional fields for controlling how
terminal sequences to change colours are output. Each of the following
is followed by a colon and a string in the same form as for key
bindings. This will not be necessary for the vast majority of terminals
as the defaults shown in parentheses are widely used.</p>
<p>
<strong>fg_start_code</strong> (<strong>\e[3</strong>) The start of the escape sequence for the
foreground colour. This is followed by one to three ASCII digits
representing the colour. Only used for palette colors, i.e. not 24-bit
colors specified via a color triplet.</p>
<dl>
<dt>
<strong>fg_default_code</strong> (<strong>9</strong>)
</dt>
<dd>The number to use instead of the colour to
reset the default foreground colour.</dd>
<dt>
<strong>fg_end_code</strong> (<strong>m</strong>)
</dt>
<dd>The end of the escape sequence for the
foreground colour.</dd>
<dt>
<strong>bg_start_code</strong> (<strong>\e[4</strong>)
</dt>
<dd>The start of the escape sequence for the
background colour. See <strong>fg_start_code</strong> above.</dd>
<dt>
<strong>bg_default_code</strong> (<strong>9</strong>)
</dt>
<dd>The number to use instead of the colour to
reset the default background colour.</dd>
<dt>
<strong>bg_end_code</strong> (<strong>m</strong>)
</dt>
<dd>The end of the escape sequence for the
background colour.</dd>
</dl>
<p>The available types of highlighting are the following. Note that not all
types of highlighting are available on all terminals:</p>
<p>
<strong>none</strong> No highlighting is applied to the given context. It is not useful
for this to appear with other types of highlighting; it is used to
override a default.</p>
<dl>
<dt>
*fg=*/colour/
</dt>
<dd>The foreground colour should be set to <em>colour</em>, a
decimal integer, the name of one of the eight most widely-supported
colours or as a `*#*&#39; followed by an RGB triplet in hexadecimal
format.

Not all terminals support this and, of those that do, not all provide
facilities to test the support, hence the user should decide based on
the terminal type. Most terminals support the colours <strong>black</strong>, <strong>red</strong>,
<strong>green</strong>, <strong>yellow</strong>, <strong>blue</strong>, <strong>magenta</strong>, <strong>cyan</strong> and <strong>white</strong>, which can be
set by name. In addition. <strong>default</strong> may be used to set the terminal&#39;s
default foreground colour. Abbreviations are allowed; <strong>b</strong> or <strong>bl</strong>
selects black. Some terminals may generate additional colours if the
<strong>bold</strong> attribute is also present.

On recent terminals and on systems with an up-to-date terminal
database the number of colours supported may be tested by the command
`*echotc* Co&#39;; if this succeeds, it indicates a limit on the number of
colours which will be enforced by the line editor. The number of
colours is in any case limited to 256 (i.e. the range 0 to 255).

Some modern terminal emulators have support for 24-bit true colour (16
million colours). In this case, the hex triplet format can be used.
This consists of a `*#*&#39; followed by either a three or six digit
hexadecimal number describing the red, green and blue components of
the colour. Hex triplets can also be used with 88 and 256 colour
terminals via the <strong>zsh/nearcolor</strong> module (see /zshmodules/(1)).

Colour is also known as color.</dd>
<dt>
*bg=*/colour/
</dt>
<dd>The background colour should be set to <em>colour</em>. This
works similarly to the foreground colour, except the background is not
usually affected by the bold attribute.</dd>
<dt>
<strong>bold</strong>
</dt>
<dd>The characters in the given context are shown in a bold
font. Not all terminals distinguish bold fonts.</dd>
<dt>
<strong>standout</strong>
</dt>
<dd>The characters in the given context are shown in the
terminal&#39;s standout mode. The actual effect is specific to the
terminal; on many terminals it is inverse video. On some such
terminals, where the cursor does not blink it appears with standout
mode negated, making it less than clear where the cursor actually is.
On such terminals one of the other effects may be preferable for
highlighting the region and matched search string.</dd>
<dt>
<strong>underline</strong>
</dt>
<dd>The characters in the given context are shown
underlined. Some terminals show the foreground in a different colour
instead; in this case whitespace will not be highlighted.</dd>
</dl>
<p>The characters described above as `special&#39; are as follows. The
formatting described here is used irrespective of whether the characters
are highlighted:</p>
<p>
ASCII control characters Control characters in the ASCII range are shown
as `*^*&#39; followed by the base character.</p>
<dl>
<dt>
Unprintable multibyte characters
</dt>
<dd>This item applies to control
characters not in the ASCII range, plus other characters as follows.
If the <strong>MULTIBYTE</strong> option is in effect, multibyte characters not in
the ASCII character set that are reported as having zero width are
treated as combining characters when the option <strong>COMBINING_CHARS</strong> is
on. If the option is off, or if a character appears where a combining
character is not valid, the character is treated as unprintable.

Unprintable multibyte characters are shown as a hexadecimal number
between angle brackets. The number is the code point of the character
in the wide character set; this may or may not be Unicode, depending
on the operating system.</dd>
<dt>
Invalid multibyte characters
</dt>
<dd>If the <strong>MULTIBYTE</strong> option is in
effect, any sequence of one or more bytes that does not form a valid
character in the current character set is treated as a series of bytes
each shown as a special character. This case can be distinguished from
other unprintable characters as the bytes are represented as two
hexadecimal digits between angle brackets, as distinct from the four
or eight digits that are used for unprintable characters that are
nonetheless valid in the current character set.

Not all systems support this: for it to work, the system&#39;s
representation of wide characters must be code values from the
Universal Character Set, as defined by IS0 10646 (also known as
Unicode).</dd>
<dt>
Wrapped double-width characters
</dt>
<dd>When a double-width character
appears in the final column of a line, it is instead shown on the next
line. The empty space left in the original position is highlighted as
a special character.</dd>
</dl>
<p>If <strong>zle_highlight</strong> is not set or no value applies to a particular
context, the defaults applied are equivalent to</p>
<blockquote>
<pre class="example">
zle_highlight=(region:standout special:standout
suffix:bold isearch:underline paste:standout)
</pre>
</blockquote>
<p>
i.e. both the region and special characters are shown in standout mode.</p>
<p>
Within widgets, arbitrary regions may be highlighted by setting the
special array parameter <strong>region_highlight</strong>; see above.</p>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.95916b5b8c09add4922ea47e674b5da7fc4b6347a3e8c4e25e98b4b7d236080b.js" integrity="sha256-lZFrW4wJrdSSLqR&#43;Z0tdp/xLY0ej6MTiXpi0t9I2CAs=" crossorigin="anonymous"></script>
    </body>
</html>
