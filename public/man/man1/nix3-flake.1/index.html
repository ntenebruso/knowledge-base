<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - nix3-flake.1 | Technical Notes</title>

    <link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - nix3-flake.1</h1>
    
<p><strong>Warning</strong><br>
This program is <strong>experimental</strong> and its interface is subject to change.</p>
<p>#+end_quote</p>
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
Name
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p><code class="verbatim">nix flake</code> - manage Nix flakes</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
Synopsis
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p><code class="verbatim">nix flake</code> [/option/…] <em>subcommand</em></p>
<p>
where <em>subcommand</em> is one of the following:</p>
<ul>
<li><code class="verbatim">nix flake archive</code> - copy a flake and all its inputs to a store</li>
<li><code class="verbatim">nix flake check</code> - check whether the flake evaluates and run its
tests</li>
<li><code class="verbatim">nix flake clone</code> - clone flake repository</li>
<li><code class="verbatim">nix flake info</code> - show flake metadata</li>
<li><code class="verbatim">nix flake init</code> - create a flake in the current directory from a
template</li>
<li><code class="verbatim">nix flake lock</code> - create missing lock file entries</li>
<li><code class="verbatim">nix flake metadata</code> - show flake metadata</li>
<li><code class="verbatim">nix flake new</code> - create a flake in the specified directory from a
template</li>
<li><code class="verbatim">nix flake prefetch</code> - download the source tree denoted by a flake
reference into the Nix store</li>
<li><code class="verbatim">nix flake show</code> - show the outputs provided by a flake</li>
<li><code class="verbatim">nix flake update</code> - update flake lock file</li>
</ul>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
Description
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p><code class="verbatim">nix flake</code> provides subcommands for creating, modifying and querying
<em>Nix flakes</em>. Flakes are the unit for packaging Nix code in a
reproducible and discoverable way. They can have dependencies on other
flakes, making it possible to have multi-repository Nix projects.</p>
<p>
A flake is a filesystem tree (typically fetched from a Git repository or
a tarball) that contains a file named <code class="verbatim">flake.nix</code> in the root directory.
<code class="verbatim">flake.nix</code> specifies some metadata about the flake such as dependencies
(called <em>inputs</em>), as well as its <em>outputs</em> (the Nix values such as
packages or NixOS modules provided by the flake).</p>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
Flake references
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<p>Flake references (<em>flakerefs</em>) are a way to specify the location of a
flake. These have two different forms:</p>
<div id="outline-container-headline-5" class="outline-3">
<h3 id="headline-5">
Attribute set representation
</h3>
<div id="outline-text-headline-5" class="outline-text-3">
<p>Example:</p>
<pre class="example">
{
  type = &#34;github&#34;;
  owner = &#34;NixOS&#34;;
  repo = &#34;nixpkgs&#34;;
}
</pre>
<p>
The only required attribute is <code class="verbatim">type</code>. The supported types are listed
below.</p>
</div>
</div>
<div id="outline-container-headline-6" class="outline-3">
<h3 id="headline-6">
URL-like syntax
</h3>
<div id="outline-text-headline-6" class="outline-text-3">
<p>Example:</p>
<pre class="example">
github:NixOS/nixpkgs
</pre>
<p>
These are used on the command line as a more convenient alternative to
the attribute set representation. For instance, in the command</p>
<pre class="example">
# nix build github:NixOS/nixpkgs#hello
</pre>
<p>
<code class="verbatim">github:NixOS/nixpkgs</code> is a flake reference (while <code class="verbatim">hello</code> is an output
attribute). They are also allowed in the <code class="verbatim">inputs</code> attribute of a flake,
e.g.</p>
<pre class="example">
inputs.nixpkgs.url = &#34;github:NixOS/nixpkgs&#34;;
</pre>
<p>
is equivalent to</p>
<pre class="example">
inputs.nixpkgs = {
  type = &#34;github&#34;;
  owner = &#34;NixOS&#34;;
  repo = &#34;nixpkgs&#34;;
};
</pre>
<p>
Following <strong>RFC 3986</strong>, characters outside of the allowed range (i.e.
neither <strong>reserved characters</strong> nor <strong>unreserved characters</strong>) must be
percent-encoded.</p>
</div>
</div>
<div id="outline-container-headline-7" class="outline-3">
<h3 id="headline-7">
Examples
</h3>
<div id="outline-text-headline-7" class="outline-text-3">
<p>Here are some examples of flake references in their URL-like
representation:</p>
<ul>
<li><code class="verbatim">nixpkgs</code>: The <code class="verbatim">nixpkgs</code> entry in the flake registry.</li>
<li><code class="verbatim">nixpkgs/a3a3dda3bacf61e8a39258a0ed9c924eeca8e293</code>: The <code class="verbatim">nixpkgs</code>
entry in the flake registry, with its Git revision overridden to a
specific value.</li>
<li><code class="verbatim">github:NixOS/nixpkgs</code>: The <code class="verbatim">master</code> branch of the <code class="verbatim">NixOS/nixpkgs</code>
repository on GitHub.</li>
<li><code class="verbatim">github:NixOS/nixpkgs/nixos-20.09</code>: The <code class="verbatim">nixos-20.09</code> branch of the
<code class="verbatim">nixpkgs</code> repository.</li>
<li><code class="verbatim">github:NixOS/nixpkgs/a3a3dda3bacf61e8a39258a0ed9c924eeca8e293</code>: A
specific revision of the <code class="verbatim">nixpkgs</code> repository.</li>
<li><code class="verbatim">github:edolstra/nix-warez?dir=blender</code>: A flake in a subdirectory of
a GitHub repository.</li>
<li><code class="verbatim">git+https://github.com/NixOS/patchelf</code>: A Git repository.</li>
<li><code class="verbatim">git+https://github.com/NixOS/patchelf?ref=master</code>: A specific branch
of a Git repository.</li>
<li><code class="verbatim">git+https://github.com/NixOS/patchelf?ref=master&amp;rev=f34751b88bd07d7f44f5cd3200fb4122bf916c7e</code>:
A specific branch <em>and</em> revision of a Git repository.</li>
<li><code class="verbatim">https://github.com/NixOS/patchelf/archive/master.tar.gz</code>: A tarball
flake.</li>
</ul>
</div>
</div>
<div id="outline-container-headline-8" class="outline-3">
<h3 id="headline-8">
Path-like syntax
</h3>
<div id="outline-text-headline-8" class="outline-text-3">
<p>Flakes corresponding to a local path can also be referred to by a direct
path reference, either <code class="verbatim">/absolute/path/to/the/flake</code>
or=./relative/path/to/the/flake=. Note that the leading <code class="verbatim">./</code> is
mandatory for relative paths. If it is omitted, the path will be
interpreted as <strong>URL-like syntax</strong>, which will cause error messages like
this:</p>
<pre class="example">
error: cannot find flake &#39;flake:relative/path/to/the/flake&#39; in the flake registries
</pre>
<p>
The semantic of such a path is as follows:</p>
<ul>
<li>If the directory is part of a Git repository, then the input will be
treated as a <code class="verbatim">git+file:</code> URL, otherwise it will be treated as a
<code class="verbatim">path:</code> url;</li>
<li>
<p>If the directory doesn&#39;t contain a <code class="verbatim">flake.nix</code> file, then Nix will
search for such a file upwards in the file system hierarchy until it
finds any of:</p>
<ol>
<li>The Git repository root, or</li>
<li>The filesystem root (/), or</li>
<li>A folder on a different mount point.</li>
</ol>
</li>
</ul>
<p>Contrary to URL-like references, path-like flake references can contain
arbitrary unicode characters (except <code class="verbatim">#</code> and <code class="verbatim">?</code>).</p>
</div>
</div>
<div id="outline-container-headline-9" class="outline-3">
<h3 id="headline-9">
Examples
</h3>
<div id="outline-text-headline-9" class="outline-text-3">
<ul>
<li><code class="verbatim">.</code>: The flake to which the current directory belongs to.</li>
<li><code class="verbatim">/home/alice/src/patchelf</code>: A flake in some other directory.</li>
<li><code class="verbatim">./../sub directory/with Ûñî©ôδ€</code>: A flake in another relative
directory that has Unicode characters in its name.</li>
</ul>
</div>
</div>
<div id="outline-container-headline-10" class="outline-3">
<h3 id="headline-10">
Flake reference attributes
</h3>
<div id="outline-text-headline-10" class="outline-text-3">
<p>The following generic flake reference attributes are supported:</p>
<ul>
<li><code class="verbatim">dir</code>: The subdirectory of the flake in which <code class="verbatim">flake.nix</code> is located.
This parameter enables having multiple flakes in a repository or
tarball. The default is the root directory of the flake.</li>
<li><code class="verbatim">narHash</code>: The hash of the <strong>Nix Archive (NAR) serialisation</strong> (in SRI
format) of the contents of the flake. This is useful for flake types
such as tarballs that lack a unique content identifier such as a Git
commit hash.</li>
</ul>
<p>In addition, the following attributes are common to several flake
reference types:</p>
<ul>
<li><code class="verbatim">rev</code>: A Git or Mercurial commit hash.</li>
<li><code class="verbatim">ref</code>: A Git or Mercurial branch or tag name.</li>
</ul>
<p>Finally, some attribute are typically not specified by the user, but can
occur in <em>locked</em> flake references and are available to Nix code:</p>
<ul>
<li><code class="verbatim">revCount</code>: The number of ancestors of the commit <code class="verbatim">rev</code>.</li>
<li><code class="verbatim">lastModified</code>: The timestamp (in seconds since the Unix epoch) of the
last modification of this version of the flake. For Git/Mercurial
flakes, this is the commit time of commit <em>rev</em>, while for tarball
flakes, it&#39;s the most recent timestamp of any file inside the tarball.</li>
</ul>
</div>
</div>
<div id="outline-container-headline-11" class="outline-3">
<h3 id="headline-11">
Types
</h3>
<div id="outline-text-headline-11" class="outline-text-3">
<p>Currently the <code class="verbatim">type</code> attribute can be one of the following:</p>
<ul>
<li><code class="verbatim">indirect</code>: <em>The default</em>. Indirection through the flake registry.
These have the form</li>
</ul>
<pre class="example">
[flake:]&lt;flake-id&gt;(/&lt;rev-or-ref&gt;(/rev)?)?
</pre>
<blockquote>
<p>These perform a lookup of <code class="verbatim">&lt;flake-id&gt;</code> in the flake registry. For
example, <code class="verbatim">nixpkgs</code> and <code class="verbatim">nixpkgs/release-20.09</code> are indirect flake
references. The specified <code class="verbatim">rev</code> and/or <code class="verbatim">ref</code> are merged with the entry
in the registry; see <strong>nix registry</strong> for details.</p>
</blockquote>
<blockquote>
<p>For example, these are valid indirect flake references:</p>
</blockquote>
<blockquote>
<ul>
<li><code class="verbatim">nixpkgs</code></li>
<li><code class="verbatim">nixpkgs/nixos-unstable</code></li>
<li><code class="verbatim">nixpkgs/a3a3dda3bacf61e8a39258a0ed9c924eeca8e293</code></li>
<li><code class="verbatim">nixpkgs/nixos-unstable/a3a3dda3bacf61e8a39258a0ed9c924eeca8e293</code></li>
<li><code class="verbatim">sub/dir</code> (if a flake named <code class="verbatim">sub</code> is in the registry)</li>
</ul>
</blockquote>
<ul>
<li><code class="verbatim">path</code>: arbitrary local directories. The required attribute <code class="verbatim">path</code>
specifies the path of the flake. The URL form is</li>
</ul>
<pre class="example">
path:&lt;path&gt;(\?&lt;params&gt;)?
</pre>
<blockquote>
<p>where <em>path</em> is an absolute path to a directory in the file system
containing a file named <code class="verbatim">flake.nix</code>.</p>
</blockquote>
<blockquote>
<p>If the flake at <em>path</em> is not inside a git repository, the <code class="verbatim">path:</code>
prefix is implied and can be omitted.</p>
</blockquote>
<blockquote>
<p><em>path</em> generally must be an absolute path. However, on the command line,
it can be a relative path (e.g. <code class="verbatim">.</code> or <code class="verbatim">./foo</code>) which is interpreted as
relative to the current directory. In this case, it must start with <code class="verbatim">.</code>
to avoid ambiguity with registry lookups (e.g. <code class="verbatim">nixpkgs</code> is a registry
lookup; <code class="verbatim">./nixpkgs</code> is a relative path).</p>
</blockquote>
<blockquote>
<p>For example, these are valid path flake references:</p>
</blockquote>
<blockquote>
<ul>
<li><code class="verbatim">path:/home/user/sub/dir</code></li>
<li><code class="verbatim">/home/user/sub/dir</code> (if <code class="verbatim">dir/flake.nix</code> is <em>not</em> in a git repository)</li>
<li><code class="verbatim">./sub/dir</code> (when used on the command line and <code class="verbatim">dir/flake.nix</code> is
<em>not</em> in a git repository)</li>
</ul>
</blockquote>
<ul>
<li><code class="verbatim">git</code>: Git repositories. The location of the repository is specified
by the attribute <code class="verbatim">url</code>.

They have the URL form</li>
</ul>
<pre class="example">
git(+http|+https|+ssh|+git|+file):(//&lt;server&gt;)?&lt;path&gt;(\?&lt;params&gt;)?
</pre>
<blockquote>
<p>If <em>path</em> starts with <code class="verbatim">/</code> (or <code class="verbatim">./</code> when used as an argument on the
command line) and is a local path to a git repository, the leading
<code class="verbatim">git:</code> or <code class="verbatim">+file</code> prefixes are implied and can be omitted.</p>
</blockquote>
<blockquote>
<p>The <code class="verbatim">ref</code> attribute defaults to resolving the <code class="verbatim">HEAD</code> reference.</p>
</blockquote>
<blockquote>
<p>The <code class="verbatim">rev</code> attribute must denote a commit that exists in the branch or
tag specified by the <code class="verbatim">ref</code> attribute, since Nix doesn&#39;t do a full clone
of the remote repository by default (and the Git protocol doesn&#39;t allow
fetching a <code class="verbatim">rev</code> without a known <code class="verbatim">ref</code>). The default is the commit
currently pointed to by <code class="verbatim">ref</code>.</p>
</blockquote>
<blockquote>
<p>When <code class="verbatim">git+file</code> is used without specifying <code class="verbatim">ref</code> or <code class="verbatim">rev</code>, files are
fetched directly from the local <code class="verbatim">path</code> as long as they have been added
to the Git repository. If there are uncommitted changes, the reference
is treated as dirty and a warning is printed.</p>
</blockquote>
<blockquote>
<p>For example, the following are valid Git flake references:</p>
</blockquote>
<blockquote>
<ul>
<li><code class="verbatim">git:/home/user/sub/dir</code></li>
<li><code class="verbatim">/home/user/sub/dir</code> (if <code class="verbatim">dir/flake.nix</code> is in a git repository)</li>
<li><code class="verbatim">./sub/dir</code> (when used on the command line and <code class="verbatim">dir/flake.nix</code> is in a
git repository)</li>
<li><code class="verbatim">git+https://example.org/my/repo</code></li>
<li><code class="verbatim">git+https://example.org/my/repo?dir=flake1</code></li>
<li><code class="verbatim">git+ssh://git@github.com/NixOS/nix?ref=v1.2.3</code></li>
<li><code class="verbatim">git://github.com/edolstra/dwarffs?ref=unstable&amp;rev=e486d8d40e626a20e06d792db8cc5ac5aba9a5b4</code></li>
<li><code class="verbatim">git+file:///home/my-user/some-repo/some-repo</code></li>
</ul>
</blockquote>
<ul>
<li><code class="verbatim">mercurial</code>: Mercurial repositories. The URL form is similar to the
<code class="verbatim">git</code> type, except that the URL schema must be one of <code class="verbatim">hg+http</code>,
<code class="verbatim">hg+https</code>, <code class="verbatim">hg+ssh</code> or <code class="verbatim">hg+file</code>.</li>
<li><code class="verbatim">tarball</code>: Tarballs. The location of the tarball is specified by the
attribute <code class="verbatim">url</code>.

In URL form, the schema must be <code class="verbatim">tarball+http://</code>, <code class="verbatim">tarball+https://</code>
or <code class="verbatim">tarball+file://</code>. If the extension corresponds to a known archive
format (<code class="verbatim">.zip</code>, <code class="verbatim">.tar</code>, <code class="verbatim">.tgz</code>, <code class="verbatim">.tar.gz</code>, <code class="verbatim">.tar.xz</code>, <code class="verbatim">.tar.bz2</code> or
<code class="verbatim">.tar.zst</code>), then the <code class="verbatim">tarball+</code> can be dropped.

This can also be used to set the location of gitea/forgejo branches.
<strong>See here</strong></li>
<li><code class="verbatim">file</code>: Plain files or directory tarballs, either over http(s) or from
the local disk.

In URL form, the schema must be <code class="verbatim">file+http://</code>, <code class="verbatim">file+https://</code> or
<code class="verbatim">file+file://</code>. If the extension doesn&#39;t correspond to a known archive
format (as defined by the <code class="verbatim">tarball</code> fetcher), then the <code class="verbatim">file+</code> prefix
can be dropped.</li>
<li>
<p><code class="verbatim">github</code>: A more efficient way to fetch repositories from GitHub. The
following attributes are required:</p>
<ul>
<li><code class="verbatim">owner</code>: The owner of the repository.</li>
<li><code class="verbatim">repo</code>: The name of the repository.</li>
</ul>
<p>These are downloaded as tarball archives, rather than through Git.
This is often much faster and uses less disk space since it doesn&#39;t
require fetching the entire history of the repository. On the other
hand, it doesn&#39;t allow incremental fetching (but full downloads are
often faster than incremental fetches!).</p>
<p>
The URL syntax for <code class="verbatim">github</code> flakes is:</p>
</li>
</ul>
<pre class="example">
github:&lt;owner&gt;/&lt;repo&gt;(/&lt;rev-or-ref&gt;)?(\?&lt;params&gt;)?
</pre>
<blockquote>
<p><code class="verbatim">&lt;rev-or-ref&gt;</code> specifies the name of a branch or tag (<code class="verbatim">ref</code>), or a
commit hash (<code class="verbatim">rev</code>). Note that unlike Git, GitHub allows fetching by
commit hash without specifying a branch or tag.</p>
</blockquote>
<blockquote>
<p>You can also specify <code class="verbatim">host</code> as a parameter, to point to a custom GitHub
Enterprise server.</p>
</blockquote>
<blockquote>
<p>Some examples:</p>
</blockquote>
<blockquote>
<ul>
<li><code class="verbatim">github:edolstra/dwarffs</code></li>
<li><code class="verbatim">github:edolstra/dwarffs/unstable</code></li>
<li><code class="verbatim">github:edolstra/dwarffs/d3f2baba8f425779026c6ec04021b2e927f61e31</code></li>
<li><code class="verbatim">github:internal/project?host=company-github.example.org</code></li>
</ul>
</blockquote>
<ul>
<li>
<p><code class="verbatim">gitlab</code>: Similar to <code class="verbatim">github</code>, is a more efficient way to fetch GitLab
repositories. The following attributes are required:</p>
<ul>
<li><code class="verbatim">owner</code>: The owner of the repository.</li>
<li><code class="verbatim">repo</code>: The name of the repository.</li>
</ul>
<p>Like <code class="verbatim">github</code>, these are downloaded as tarball archives.</p>
<p>
The URL syntax for <code class="verbatim">gitlab</code> flakes is:</p>
<p>
<code class="verbatim">gitlab:&lt;owner&gt;/&lt;repo&gt;(/&lt;rev-or-ref&gt;)?(\?&lt;params&gt;)?</code></p>
<p>
<code class="verbatim">&lt;rev-or-ref&gt;</code> works the same as <code class="verbatim">github</code>. Either a branch or tag name
(<code class="verbatim">ref</code>), or a commit hash (<code class="verbatim">rev</code>) can be specified.</p>
<p>
Since GitLab allows for self-hosting, you can specify <code class="verbatim">host</code> as a
parameter, to point to any instances other than <code class="verbatim">gitlab.com</code>.</p>
<p>
Some examples:</p>
<ul>
<li><code class="verbatim">gitlab:veloren/veloren</code></li>
<li><code class="verbatim">gitlab:veloren/veloren/master</code></li>
<li><code class="verbatim">gitlab:veloren/veloren/80a4d7f13492d916e47d6195be23acae8001985a</code></li>
<li><code class="verbatim">gitlab:openldap/openldap?host=git.openldap.org</code></li>
</ul>
<p>When accessing a project in a (nested) subgroup, make sure to
URL-encode any slashes, i.e. replace <code class="verbatim">/</code> with <code class="verbatim">%2F</code>:</p>
<ul>
<li><code class="verbatim">gitlab:veloren%2Fdev/rfcs</code></li>
</ul>
</li>
<li>
<p><code class="verbatim">sourcehut</code>: Similar to <code class="verbatim">github</code>, is a more efficient way to fetch
SourceHut repositories. The following attributes are required:</p>
<ul>
<li><code class="verbatim">owner</code>: The owner of the repository (including leading <code class="verbatim">~</code>).</li>
<li><code class="verbatim">repo</code>: The name of the repository.</li>
</ul>
<p>Like <code class="verbatim">github</code>, these are downloaded as tarball archives.</p>
<p>
The URL syntax for <code class="verbatim">sourcehut</code> flakes is:</p>
<p>
<code class="verbatim">sourcehut:&lt;owner&gt;/&lt;repo&gt;(/&lt;rev-or-ref&gt;)?(\?&lt;params&gt;)?</code></p>
<p>
<code class="verbatim">&lt;rev-or-ref&gt;</code> works the same as <code class="verbatim">github</code>. Either a branch or tag name
(<code class="verbatim">ref</code>), or a commit hash (<code class="verbatim">rev</code>) can be specified.</p>
<p>
Since SourceHut allows for self-hosting, you can specify <code class="verbatim">host</code> as a
parameter, to point to any instances other than <code class="verbatim">git.sr.ht</code>.</p>
<p>
Currently, <code class="verbatim">ref</code> name resolution only works for Git repositories. You
can refer to Mercurial repositories by simply changing <code class="verbatim">host</code> to
<code class="verbatim">hg.sr.ht</code> (or any other Mercurial instance). With the caveat that you
must explicitly specify a commit hash (<code class="verbatim">rev</code>).</p>
<p>
Some examples:</p>
<ul>
<li><code class="verbatim">sourcehut:~misterio/nix-colors</code></li>
<li><code class="verbatim">sourcehut:~misterio/nix-colors/main</code></li>
<li><code class="verbatim">sourcehut:~misterio/nix-colors?host=git.example.org</code></li>
<li><code class="verbatim">sourcehut:~misterio/nix-colors/182b4b8709b8ffe4e9774a4c5d6877bf6bb9a21c</code></li>
<li><code class="verbatim">sourcehut:~misterio/nix-colors/21c1a380a6915d890d408e9f22203436a35bb2de?host=hg.sr.ht</code></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-12" class="outline-2">
<h2 id="headline-12">
Flake format
</h2>
<div id="outline-text-headline-12" class="outline-text-2">
<p>As an example, here is a simple <code class="verbatim">flake.nix</code> that depends on the Nixpkgs
flake and provides a single package (i.e. an <strong>installable</strong> derivation):</p>
<pre class="example">
{
  description = &#34;A flake for building Hello World&#34;;

  inputs.nixpkgs.url = &#34;github:NixOS/nixpkgs/nixos-20.03&#34;;

  outputs = { self, nixpkgs }: {

    packages.x86_64-linux.default =
      # Notice the reference to nixpkgs here.
      with import nixpkgs { system = &#34;x86_64-linux&#34;; };
      stdenv.mkDerivation {
        name = &#34;hello&#34;;
        src = self;
        buildPhase = &#34;gcc -o hello ./hello.c&#34;;
        installPhase = &#34;mkdir -p $out/bin; install -t $out/bin hello&#34;;
      };

  };
}
</pre>
<p>
The following attributes are supported in <code class="verbatim">flake.nix</code>:</p>
<ul>
<li><code class="verbatim">description</code>: A short, one-line description of the flake.</li>
<li><code class="verbatim">inputs</code>: An attrset specifying the dependencies of the flake
(described below).</li>
<li>
<p><code class="verbatim">outputs</code>: A function that, given an attribute set containing the
outputs of each of the input flakes keyed by their identifier, yields
the Nix values provided by this flake. Thus, in the example above,
<code class="verbatim">inputs.nixpkgs</code> contains the result of the call to the <code class="verbatim">outputs</code>
function of the <code class="verbatim">nixpkgs</code> flake.</p>
<p>
In addition to the outputs of each input, each input in <code class="verbatim">inputs</code> also
contains some metadata about the inputs. These are:</p>
<ul>
<li><code class="verbatim">outPath</code>: The path in the Nix store of the flake&#39;s source tree.
This way, the attribute set can be passed to <code class="verbatim">import</code> as if it was a
path, as in the example above (<code class="verbatim">import nixpkgs</code>).</li>
<li><code class="verbatim">rev</code>: The commit hash of the flake&#39;s repository, if applicable.</li>
<li><code class="verbatim">revCount</code>: The number of ancestors of the revision <code class="verbatim">rev</code>. This is
not available for <code class="verbatim">github</code> repositories, since they&#39;re fetched as
tarballs rather than as Git repositories.</li>
<li><code class="verbatim">lastModifiedDate</code>: The commit time of the revision <code class="verbatim">rev</code>, in the
format <code class="verbatim">%Y%m%d%H%M%S</code> (e.g. <code class="verbatim">20181231100934</code>). Unlike <code class="verbatim">revCount</code>,
this is available for both Git and GitHub repositories, so it&#39;s
useful for generating (hopefully) monotonically increasing version
strings.</li>
<li><code class="verbatim">lastModified</code>: The commit time of the revision <code class="verbatim">rev</code> as an integer
denoting the number of seconds since 1970.</li>
<li><code class="verbatim">narHash</code>: The SHA-256 (in SRI format) of the <strong>Nix Archive (NAR)
serialisation</strong> NAR serialization of the flake&#39;s source tree.</li>
</ul>
<p>The value returned by the <code class="verbatim">outputs</code> function must be an attribute set.
The attributes can have arbitrary values; however, various <code class="verbatim">nix</code>
subcommands require specific attributes to have a specific value (e.g.
<code class="verbatim">packages.x86_64-linux</code> must be an attribute set of derivations built
for the <code class="verbatim">x86_64-linux</code> platform).</p>
</li>
<li>
<p><code class="verbatim">nixConfig</code>: a set of <code class="verbatim">nix.conf</code> options to be set when evaluating any
part of a flake. In the interests of security, only a small set of set
of options is allowed to be set without confirmation so long as
<code class="verbatim">accept-flake-config</code> is not enabled in the global configuration:</p>
<ul>
<li><code class="verbatim">bash-prompt</code></li>
<li><code class="verbatim">bash-prompt-prefix</code></li>
<li><code class="verbatim">bash-prompt-suffix</code></li>
<li><code class="verbatim">flake-registry</code></li>
<li><code class="verbatim">commit-lock-file-summary</code></li>
</ul>
</li>
</ul>
<div id="outline-container-headline-13" class="outline-3">
<h3 id="headline-13">
Flake inputs
</h3>
<div id="outline-text-headline-13" class="outline-text-3">
<p>The attribute <code class="verbatim">inputs</code> specifies the dependencies of a flake, as an
attrset mapping input names to flake references. For example, the
following specifies a dependency on the <code class="verbatim">nixpkgs</code> and <code class="verbatim">import-cargo</code>
repositories:</p>
<pre class="example">
# A GitHub repository.
inputs.import-cargo = {
  type = &#34;github&#34;;
  owner = &#34;edolstra&#34;;
  repo = &#34;import-cargo&#34;;
};

# An indirection through the flake registry.
inputs.nixpkgs = {
  type = &#34;indirect&#34;;
  id = &#34;nixpkgs&#34;;
};
</pre>
<p>
Alternatively, you can use the URL-like syntax:</p>
<pre class="example">
inputs.import-cargo.url = &#34;github:edolstra/import-cargo&#34;;
inputs.nixpkgs.url = &#34;nixpkgs&#34;;
</pre>
<p>
Each input is fetched, evaluated and passed to the <code class="verbatim">outputs</code> function as
a set of attributes with the same name as the corresponding input. The
special input named <code class="verbatim">self</code> refers to the outputs and source tree of
<em>this</em> flake. Thus, a typical <code class="verbatim">outputs</code> function looks like this:</p>
<pre class="example">
outputs = { self, nixpkgs, import-cargo }: {
  ... outputs ...
};
</pre>
<p>
It is also possible to omit an input entirely and <em>only</em> list it as
expected function argument to <code class="verbatim">outputs</code>. Thus,</p>
<pre class="example">
outputs = { self, nixpkgs }: ...;
</pre>
<p>
without an <code class="verbatim">inputs.nixpkgs</code> attribute is equivalent to</p>
<pre class="example">
inputs.nixpkgs = {
  type = &#34;indirect&#34;;
  id = &#34;nixpkgs&#34;;
};
</pre>
<p>
Repositories that don&#39;t contain a <code class="verbatim">flake.nix</code> can also be used as
inputs, by setting the input&#39;s <code class="verbatim">flake</code> attribute to <code class="verbatim">false</code>:</p>
<pre class="example">
inputs.grcov = {
  type = &#34;github&#34;;
  owner = &#34;mozilla&#34;;
  repo = &#34;grcov&#34;;
  flake = false;
};

outputs = { self, nixpkgs, grcov }: {
  packages.x86_64-linux.grcov = stdenv.mkDerivation {
    src = grcov;
    ...
  };
};
</pre>
<p>
Transitive inputs can be overridden from a <code class="verbatim">flake.nix</code> file. For
example, the following overrides the <code class="verbatim">nixpkgs</code> input of the <code class="verbatim">nixops</code>
input:</p>
<pre class="example">
inputs.nixops.inputs.nixpkgs = {
  type = &#34;github&#34;;
  owner = &#34;my-org&#34;;
  repo = &#34;nixpkgs&#34;;
};
</pre>
<p>
It is also possible to “inherit” an input from another input. This is
useful to minimize flake dependencies. For example, the following sets
the <code class="verbatim">nixpkgs</code> input of the top-level flake to be equal to the <code class="verbatim">nixpkgs</code>
input of the <code class="verbatim">dwarffs</code> input of the top-level flake:</p>
<pre class="example">
inputs.nixpkgs.follows = &#34;dwarffs/nixpkgs&#34;;
</pre>
<p>
The value of the <code class="verbatim">follows</code> attribute is a <code class="verbatim">/</code>-separated sequence of
input names denoting the path of inputs to be followed from the root
flake.</p>
<p>
Overrides and <code class="verbatim">follows</code> can be combined, e.g.</p>
<pre class="example">
inputs.nixops.inputs.nixpkgs.follows = &#34;dwarffs/nixpkgs&#34;;
</pre>
<p>
sets the <code class="verbatim">nixpkgs</code> input of <code class="verbatim">nixops</code> to be the same as the <code class="verbatim">nixpkgs</code>
input of <code class="verbatim">dwarffs</code>. It is worth noting, however, that it is generally
not useful to eliminate transitive <code class="verbatim">nixpkgs</code> flake inputs in this way.
Most flakes provide their functionality through Nixpkgs overlays or
NixOS modules, which are composed into the top-level flake&#39;s <code class="verbatim">nixpkgs</code>
input; so their own <code class="verbatim">nixpkgs</code> input is usually irrelevant.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-14" class="outline-2">
<h2 id="headline-14">
Lock files
</h2>
<div id="outline-text-headline-14" class="outline-text-2">
<p>Inputs specified in <code class="verbatim">flake.nix</code> are typically “unlocked” in the sense
that they don&#39;t specify an exact revision. To ensure reproducibility,
Nix will automatically generate and use a <em>lock file</em> called
<code class="verbatim">flake.lock</code> in the flake&#39;s directory. The lock file contains a graph
structure isomorphic to the graph of dependencies of the root flake.
Each node in the graph (except the root node) maps the (usually)
unlocked input specifications in <code class="verbatim">flake.nix</code> to locked input
specifications. Each node also contains some metadata, such as the
dependencies (outgoing edges) of the node.</p>
<p>
For example, if <code class="verbatim">flake.nix</code> has the inputs in the example above, then
the resulting lock file might be:</p>
<pre class="example">
{
  &#34;version&#34;: 7,
  &#34;root&#34;: &#34;n1&#34;,
  &#34;nodes&#34;: {
    &#34;n1&#34;: {
      &#34;inputs&#34;: {
        &#34;nixpkgs&#34;: &#34;n2&#34;,
        &#34;import-cargo&#34;: &#34;n3&#34;,
        &#34;grcov&#34;: &#34;n4&#34;
      }
    },
    &#34;n2&#34;: {
      &#34;inputs&#34;: {},
      &#34;locked&#34;: {
        &#34;owner&#34;: &#34;edolstra&#34;,
        &#34;repo&#34;: &#34;nixpkgs&#34;,
        &#34;rev&#34;: &#34;7f8d4b088e2df7fdb6b513bc2d6941f1d422a013&#34;,
        &#34;type&#34;: &#34;github&#34;,
        &#34;lastModified&#34;: 1580555482,
        &#34;narHash&#34;: &#34;sha256-OnpEWzNxF/AU4KlqBXM2s5PWvfI5/BS6xQrPvkF5tO8=&#34;
      },
      &#34;original&#34;: {
        &#34;id&#34;: &#34;nixpkgs&#34;,
        &#34;type&#34;: &#34;indirect&#34;
      }
    },
    &#34;n3&#34;: {
      &#34;inputs&#34;: {},
      &#34;locked&#34;: {
        &#34;owner&#34;: &#34;edolstra&#34;,
        &#34;repo&#34;: &#34;import-cargo&#34;,
        &#34;rev&#34;: &#34;8abf7b3a8cbe1c8a885391f826357a74d382a422&#34;,
        &#34;type&#34;: &#34;github&#34;,
        &#34;lastModified&#34;: 1567183309,
        &#34;narHash&#34;: &#34;sha256-wIXWOpX9rRjK5NDsL6WzuuBJl2R0kUCnlpZUrASykSc=&#34;
      },
      &#34;original&#34;: {
        &#34;owner&#34;: &#34;edolstra&#34;,
        &#34;repo&#34;: &#34;import-cargo&#34;,
        &#34;type&#34;: &#34;github&#34;
      }
    },
    &#34;n4&#34;: {
      &#34;inputs&#34;: {},
      &#34;locked&#34;: {
        &#34;owner&#34;: &#34;mozilla&#34;,
        &#34;repo&#34;: &#34;grcov&#34;,
        &#34;rev&#34;: &#34;989a84bb29e95e392589c4e73c29189fd69a1d4e&#34;,
        &#34;type&#34;: &#34;github&#34;,
        &#34;lastModified&#34;: 1580729070,
        &#34;narHash&#34;: &#34;sha256-235uMxYlHxJ5y92EXZWAYEsEb6mm+b069GAd+BOIOxI=&#34;
      },
      &#34;original&#34;: {
        &#34;owner&#34;: &#34;mozilla&#34;,
        &#34;repo&#34;: &#34;grcov&#34;,
        &#34;type&#34;: &#34;github&#34;
      },
      &#34;flake&#34;: false
    }
  }
}
</pre>
<p>
This graph has 4 nodes: the root flake, and its 3 dependencies. The
nodes have arbitrary labels (e.g. <code class="verbatim">n1</code>). The label of the root node of
the graph is specified by the <code class="verbatim">root</code> attribute. Nodes contain the
following fields:</p>
<ul>
<li><code class="verbatim">inputs</code>: The dependencies of this node, as a mapping from input names
(e.g. <code class="verbatim">nixpkgs</code>) to node labels (e.g. <code class="verbatim">n2</code>).</li>
<li><code class="verbatim">original</code>: The original input specification from <code class="verbatim">flake.lock</code>, as a
set of <code class="verbatim">builtins.fetchTree</code> arguments.</li>
<li><code class="verbatim">locked</code>: The locked input specification, as a set of
<code class="verbatim">builtins.fetchTree</code> arguments. Thus, in the example above, when we
build this flake, the input <code class="verbatim">nixpkgs</code> is mapped to revision
<code class="verbatim">7f8d4b088e2df7fdb6b513bc2d6941f1d422a013</code> of the <code class="verbatim">edolstra/nixpkgs</code>
repository on GitHub.

It also includes the attribute <code class="verbatim">narHash</code>, specifying the expected
contents of the tree in the Nix store (as computed by <code class="verbatim">nix</code>
hash-path), and may include input-type-specific attributes such as the
<code class="verbatim">lastModified</code> or <code class="verbatim">revCount</code>. The main reason for these attributes is
to allow flake inputs to be substituted from a binary cache: <code class="verbatim">narHash</code>
allows the store path to be computed, while the other attributes are
necessary because they provide information not stored in the store
path.</li>
<li><code class="verbatim">flake</code>: A Boolean denoting whether this is a flake or non-flake
dependency. Corresponds to the <code class="verbatim">flake</code> attribute in the <code class="verbatim">inputs</code>
attribute in <code class="verbatim">flake.nix</code>.</li>
</ul>
<p>The <code class="verbatim">original</code> and <code class="verbatim">locked</code> attributes are omitted for the root node.
This is because we cannot record the commit hash or content hash of the
root flake, since modifying <code class="verbatim">flake.lock</code> will invalidate these.</p>
<p>
The graph representation of lock files allows circular dependencies
between flakes. For example, here are two flakes that reference each
other:</p>
<pre class="example">
{
  inputs.b = ... location of flake B ...;
  # Tell the &#39;b&#39; flake not to fetch &#39;a&#39; again, to ensure its &#39;a&#39; is
  # *this* &#39;a&#39;.
  inputs.b.inputs.a.follows = &#34;&#34;;
  outputs = { self, b }: {
    foo = 123 + b.bar;
    xyzzy = 1000;
  };
}
</pre>
<p>
and</p>
<pre class="example">
{
  inputs.a = ... location of flake A ...;
  inputs.a.inputs.b.follows = &#34;&#34;;
  outputs = { self, a }: {
    bar = 456 + a.xyzzy;
  };
}
</pre>
<p>
Lock files transitively lock direct as well as indirect dependencies.
That is, if a lock file exists and is up to date, Nix will not look at
the lock files of dependencies. However, lock file generation itself
<em>does</em> use the lock files of dependencies by default.</p>
</div>
</div>
<div id="outline-container-headline-15" class="outline-2">
<h2 id="headline-15">
Options
</h2>
<div id="outline-text-headline-15" class="outline-text-2">
<div id="outline-container-headline-16" class="outline-3">
<h3 id="headline-16">
Logging-related options
</h3>
<div id="outline-text-headline-16" class="outline-text-3">
<ul>
<li><code class="verbatim">--debug</code>

Set the logging verbosity level to ‘debug&#39;.</li>
<li><code class="verbatim">--log-format</code> <em>format</em>

Set the format of log output; one of <code class="verbatim">raw</code>, <code class="verbatim">internal-json</code>, <code class="verbatim">bar</code> or
<code class="verbatim">bar-with-logs</code>.</li>
<li><code class="verbatim">--print-build-logs</code> / <code class="verbatim">-L</code>

Print full build logs on standard error.</li>
<li><code class="verbatim">--quiet</code>

Decrease the logging verbosity level.</li>
<li><code class="verbatim">--verbose</code> / <code class="verbatim">-v</code>

Increase the logging verbosity level.</li>
</ul>
</div>
</div>
<div id="outline-container-headline-17" class="outline-3">
<h3 id="headline-17">
Miscellaneous global options
</h3>
<div id="outline-text-headline-17" class="outline-text-3">
<ul>
<li><code class="verbatim">--help</code>

Show usage information.</li>
<li><code class="verbatim">--offline</code>

Disable substituters and consider all previously downloaded files
up-to-date.</li>
<li><code class="verbatim">--option</code> <em>name</em> <em>value</em>

Set the Nix configuration setting <em>name</em> to <em>value</em> (overriding
<code class="verbatim">nix.conf</code>).</li>
<li><code class="verbatim">--refresh</code>

Consider all previously downloaded files out-of-date.</li>
<li><code class="verbatim">--version</code>

Show version information.

<strong>Note</strong>

See <code class="verbatim">man nix.conf</code> for overriding configuration settings with command
line flags.</li>
</ul>
</div>
</div>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.js"></script>
    </body>
</html>
