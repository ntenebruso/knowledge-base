<!DOCTYPE html>
<html
    lang="en-us"
    dir="ltr"
>
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Manpages - bzip2.1 | Technical Notes</title>

    <link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/css/syntax.css">
        
        
    </head>
    <body>
        <header class="container header">
            <span class="header__title">Technical Notes</span>
<button id="menuOpenBtn" class="header__menu-open-btn"><i data-lucide="menu"></i></button>

  <nav id="siteNav">
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/notes/">Notes</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/man/">Manpages</a>
    </li>
    <li>
      <a href="/search/">Search</a>
    </li>
    </ul>
    <button id="menuCloseBtn" class="header__menu-close-btn"><i data-lucide="x"></i></button>
  </nav>


        </header>
        <main class="container">
            
    <h1>Manpages - bzip2.1</h1>
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
NAME
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>bzip2, bunzip2 - a block-sorting file compressor, v1.0.8<br>
bzcat - decompresses files to stdout<br>
bzip2recover - recovers data from damaged bzip2 files</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
SYNOPSIS
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p><strong>bzip2</strong> [* -cdfkqstvzVL123456789 *] [ <em>filenames …</em> ]</p>
<p>
\\
<strong>bunzip2</strong> [* -fkvsVL <strong>] [ <em>filenames …</em> ]<br>
*bzcat</strong> [* -s <strong>] [ <em>filenames …</em> ]<br>
*bzip2recover</strong> <em>filename</em></p>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
DESCRIPTION
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p><em>bzip2</em> compresses files using the Burrows-Wheeler block sorting text
compression algorithm, and Huffman coding. Compression is generally
considerably better than that achieved by more conventional
LZ77/LZ78-based compressors, and approaches the performance of the PPM
family of statistical compressors.</p>
<p>
The command-line options are deliberately very similar to those of <em>GNU
gzip,</em> but they are not identical.</p>
<p>
<em>bzip2</em> expects a list of file names to accompany the command-line
flags. Each file is replaced by a compressed version of itself, with the
name &#34;original_name.bz2&#34;. Each compressed file has the same modification
date, permissions, and, when possible, ownership as the corresponding
original, so that these properties can be correctly restored at
decompression time. File name handling is naive in the sense that there
is no mechanism for preserving original file names, permissions,
ownerships or dates in filesystems which lack these concepts, or have
serious file name length restrictions, such as MS-DOS.</p>
<p>
<em>bzip2</em> and <em>bunzip2</em> will by default not overwrite existing files. If
you want this to happen, specify the -f flag.</p>
<p>
If no file names are specified, <em>bzip2</em> compresses from standard input
to standard output. In this case, <em>bzip2</em> will decline to write
compressed output to a terminal, as this would be entirely
incomprehensible and therefore pointless.</p>
<p>
<em>bunzip2</em> (or <em>bzip2 -d)</em> decompresses all specified files. Files which
were not created by <em>bzip2</em> will be detected and ignored, and a warning
issued. <em>bzip2</em> attempts to guess the filename for the decompressed file
from that of the compressed file as follows:</p>
<p>
filename.bz2 becomes filename filename.bz becomes filename filename.tbz2
becomes filename.tar filename.tbz becomes filename.tar anyothername
becomes anyothername.out</p>
<p>
If the file does not end in one of the recognised endings, <em>.bz2,</em>
<em>.bz,</em> <em>.tbz2</em> or <em>.tbz,</em> <em>bzip2</em> complains that it cannot guess the
name of the original file, and uses the original name with <em>.out</em>
appended.</p>
<p>
As with compression, supplying no filenames causes decompression from
standard input to standard output.</p>
<p>
<em>bunzip2</em> will correctly decompress a file which is the concatenation of
two or more compressed files. The result is the concatenation of the
corresponding uncompressed files. Integrity testing (-t) of concatenated
compressed files is also supported.</p>
<p>
You can also compress or decompress files to the standard output by
giving the -c flag. Multiple files may be compressed and decompressed
like this. The resulting outputs are fed sequentially to stdout.
Compression of multiple files in this manner generates a stream
containing multiple compressed file representations. Such a stream can
be decompressed correctly only by <em>bzip2</em> version 0.9.0 or later.
Earlier versions of <em>bzip2</em> will stop after decompressing the first file
in the stream.</p>
<p>
<em>bzcat</em> (or <em>bzip2 -dc)</em> decompresses all specified files to the
standard output.</p>
<p>
<em>bzip2</em> will read arguments from the environment variables <em>BZIP2</em> and
<em>BZIP,</em> in that order, and will process them before any arguments read
from the command line. This gives a convenient way to supply default
arguments.</p>
<p>
Compression is always performed, even if the compressed file is slightly
larger than the original. Files of less than about one hundred bytes
tend to get larger, since the compression mechanism has a constant
overhead in the region of 50 bytes. Random data (including the output of
most file compressors) is coded at about 8.05 bits per byte, giving an
expansion of around 0.5%.</p>
<p>
As a self-check for your protection, <em>bzip2</em> uses 32-bit CRCs to make
sure that the decompressed version of a file is identical to the
original. This guards against corruption of the compressed data, and
against undetected bugs in <em>bzip2</em> (hopefully very unlikely). The
chances of data corruption going undetected is microscopic, about one
chance in four billion for each file processed. Be aware, though, that
the check occurs upon decompression, so it can only tell you that
something is wrong. It can&#39;t help you recover the original uncompressed
data. You can use <em>bzip2recover</em> to try to recover data from damaged
files.</p>
<p>
Return values: 0 for a normal exit, 1 for environmental problems (file
not found, invalid flags, I/O errors, &amp;c), 2 to indicate a corrupt
compressed file, 3 for an internal consistency error (eg, bug) which
caused <em>bzip2</em> to panic.</p>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
OPTIONS
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<dl>
<dt>
<strong>-c –stdout</strong>
</dt>
<dd>Compress or decompress to standard output.</dd>
<dt>
<strong>-d –decompress</strong>
</dt>
<dd>Force decompression. <em>bzip2,</em> <em>bunzip2</em> and
<em>bzcat</em> are really the same program, and the decision about what
actions to take is done on the basis of which name is used. This flag
overrides that mechanism, and forces <em>bzip2</em> to decompress.</dd>
<dt>
<strong>-z –compress</strong>
</dt>
<dd>The complement to -d: forces compression,
regardless of the invocation name.</dd>
<dt>
<strong>-t –test</strong>
</dt>
<dd>Check integrity of the specified file(s), but don&#39;t
decompress them. This really performs a trial decompression and throws
away the result.</dd>
<dt>
<strong>-f –force</strong>
</dt>
<dd>Force overwrite of output files. Normally, <em>bzip2</em>
will not overwrite existing output files. Also forces <em>bzip2</em> to break
hard links to files, which it otherwise wouldn&#39;t do.

bzip2 normally declines to decompress files which don&#39;t have the
correct magic header bytes. If forced (-f), however, it will pass such
files through unmodified. This is how GNU gzip behaves.</dd>
<dt>
<strong>-k –keep</strong>
</dt>
<dd>Keep (don&#39;t delete) input files during compression or
decompression.</dd>
<dt>
<strong>-s –small</strong>
</dt>
<dd>Reduce memory usage, for compression, decompression
and testing. Files are decompressed and tested using a modified
algorithm which only requires 2.5 bytes per block byte. This means any
file can be decompressed in 2300k of memory, albeit at about half the
normal speed.

During compression, -s selects a block size of 200k, which limits
memory use to around the same figure, at the expense of your
compression ratio. In short, if your machine is low on memory (8
megabytes or less), use -s for everything. See MEMORY MANAGEMENT
below.</dd>
<dt>
<strong>-q –quiet</strong>
</dt>
<dd>Suppress non-essential warning messages. Messages
pertaining to I/O errors and other critical events will not be
suppressed.</dd>
<dt>
<strong>-v –verbose</strong>
</dt>
<dd>Verbose mode – show the compression ratio for each
file processed. Further -v&#39;s increase the verbosity level, spewing out
lots of information which is primarily of interest for diagnostic
purposes.</dd>
<dt>
<strong>-L –license -V –version</strong>
</dt>
<dd>Display the software version, license
terms and conditions.</dd>
<dt>
<strong>-1 (or –fast) to -9 (or –best)</strong>
</dt>
<dd>Set the block size to 100 k, 200
k .. 900 k when compressing. Has no effect when decompressing. See
MEMORY MANAGEMENT below. The –fast and –best aliases are primarily
for GNU gzip compatibility. In particular, –fast doesn&#39;t make things
significantly faster. And –best merely selects the default behaviour.</dd>
<dt>
<strong>–</strong>
</dt>
<dd>Treats all subsequent arguments as file names, even if they
start with a dash. This is so you can handle files with names
beginning with a dash, for example: bzip2 – -myfilename.</dd>
<dt>
<strong>–repetitive-fast –repetitive-best</strong>
</dt>
<dd>These flags are redundant in
versions 0.9.5 and above. They provided some coarse control over the
behaviour of the sorting algorithm in earlier versions, which was
sometimes useful. 0.9.5 and above have an improved algorithm which
renders these flags irrelevant.</dd>
</dl>
</div>
</div>
<div id="outline-container-headline-5" class="outline-2">
<h2 id="headline-5">
MEMORY MANAGEMENT
</h2>
<div id="outline-text-headline-5" class="outline-text-2">
<p><em>bzip2</em> compresses large files in blocks. The block size affects both
the compression ratio achieved, and the amount of memory needed for
compression and decompression. The flags -1 through -9 specify the block
size to be 100,000 bytes through 900,000 bytes (the default)
respectively. At decompression time, the block size used for compression
is read from the header of the compressed file, and <em>bunzip2</em> then
allocates itself just enough memory to decompress the file. Since block
sizes are stored in compressed files, it follows that the flags -1 to -9
are irrelevant to and so ignored during decompression.</p>
<p>
Compression and decompression requirements, in bytes, can be estimated
as:</p>
<p>
Compression: 400k + ( 8 x block size )</p>
<p>
Decompression: 100k + ( 4 x block size ), or 100k + ( 2.5 x block size )</p>
<p>
Larger block sizes give rapidly diminishing marginal returns. Most of
the compression comes from the first two or three hundred k of block
size, a fact worth bearing in mind when using <em>bzip2</em> on small machines.
It is also important to appreciate that the decompression memory
requirement is set at compression time by the choice of block size.</p>
<p>
For files compressed with the default 900k block size, <em>bunzip2</em> will
require about 3700 kbytes to decompress. To support decompression of any
file on a 4 megabyte machine, <em>bunzip2</em> has an option to decompress
using approximately half this amount of memory, about 2300 kbytes.
Decompression speed is also halved, so you should use this option only
where necessary. The relevant flag is -s.</p>
<p>
In general, try and use the largest block size memory constraints allow,
since that maximises the compression achieved. Compression and
decompression speed are virtually unaffected by block size.</p>
<p>
Another significant point applies to files which fit in a single block
– that means most files you&#39;d encounter using a large block size. The
amount of real memory touched is proportional to the size of the file,
since the file is smaller than a block. For example, compressing a file
20,000 bytes long with the flag -9 will cause the compressor to allocate
around 7600k of memory, but only touch 400k + 20000 * 8 = 560 kbytes of
it. Similarly, the decompressor will allocate 3700k but only touch 100k</p>
<ul>
<li>20000 * 4 = 180 kbytes.</li>
</ul>
<p>Here is a table which summarises the maximum memory usage for different
block sizes. Also recorded is the total compressed size for 14 files of
the Calgary Text Compression Corpus totalling 3,141,622 bytes. This
column gives some feel for how compression varies with block size. These
figures tend to understate the advantage of larger block sizes for
larger files, since the Corpus is dominated by smaller files.</p>
<p>
Compress Decompress Decompress Corpus Flag usage usage -s usage Size</p>
<p>
-1 1200k 500k 350k 914704 -2 2000k 900k 600k 877703 -3 2800k 1300k 850k
860338 -4 3600k 1700k 1100k 846899 -5 4400k 2100k 1350k 845160 -6 5200k
2500k 1600k 838626 -7 6100k 2900k 1850k 834096 -8 6800k 3300k 2100k
828642 -9 7600k 3700k 2350k 828642</p>
</div>
</div>
<div id="outline-container-headline-6" class="outline-2">
<h2 id="headline-6">
RECOVERING DATA FROM DAMAGED FILES
</h2>
<div id="outline-text-headline-6" class="outline-text-2">
<p><em>bzip2</em> compresses files in blocks, usually 900kbytes long. Each block
is handled independently. If a media or transmission error causes a
multi-block .bz2 file to become damaged, it may be possible to recover
data from the undamaged blocks in the file.</p>
<p>
The compressed representation of each block is delimited by a 48-bit
pattern, which makes it possible to find the block boundaries with
reasonable certainty. Each block also carries its own 32-bit CRC, so
damaged blocks can be distinguished from undamaged ones.</p>
<p>
<em>bzip2recover</em> is a simple program whose purpose is to search for blocks
in .bz2 files, and write each block out into its own .bz2 file. You can
then use <em>bzip2</em> -t to test the integrity of the resulting files, and
decompress those which are undamaged.</p>
<p>
<em>bzip2recover</em> takes a single argument, the name of the damaged file,
and writes a number of files &#34;rec00001file.bz2&#34;, &#34;rec00002file.bz2&#34;,
etc, containing the extracted blocks. The output filenames are designed
so that the use of wildcards in subsequent processing – for example,
&#34;bzip2 -dc rec*file.bz2 &gt; recovered_data&#34; – processes the files in the
correct order.</p>
<p>
<em>bzip2recover</em> should be of most use dealing with large .bz2 files, as
these will contain many blocks. It is clearly futile to use it on
damaged single-block files, since a damaged block cannot be recovered.
If you wish to minimise any potential data loss through media or
transmission errors, you might consider compressing with a smaller block
size.</p>
</div>
</div>
<div id="outline-container-headline-7" class="outline-2">
<h2 id="headline-7">
PERFORMANCE NOTES
</h2>
<div id="outline-text-headline-7" class="outline-text-2">
<p>The sorting phase of compression gathers together similar strings in the
file. Because of this, files containing very long runs of repeated
symbols, like &#34;aabaabaabaab …&#34; (repeated several hundred times) may
compress more slowly than normal. Versions 0.9.5 and above fare much
better than previous versions in this respect. The ratio between
worst-case and average-case compression time is in the region of 10:1.
For previous versions, this figure was more like 100:1. You can use the
-vvvv option to monitor progress in great detail, if you want.</p>
<p>
Decompression speed is unaffected by these phenomena.</p>
<p>
<em>bzip2</em> usually allocates several megabytes of memory to operate in, and
then charges all over it in a fairly random fashion. This means that
performance, both for compressing and decompressing, is largely
determined by the speed at which your machine can service cache misses.
Because of this, small changes to the code to reduce the miss rate have
been observed to give disproportionately large performance improvements.
I imagine <em>bzip2</em> will perform best on machines with very large caches.</p>
</div>
</div>
<div id="outline-container-headline-8" class="outline-2">
<h2 id="headline-8">
CAVEATS
</h2>
<div id="outline-text-headline-8" class="outline-text-2">
<p>I/O error messages are not as helpful as they could be. <em>bzip2</em> tries
hard to detect I/O errors and exit cleanly, but the details of what the
problem is sometimes seem rather misleading.</p>
<p>
This manual page pertains to version 1.0.8 of <em>bzip2.</em> Compressed data
created by this version is entirely forwards and backwards compatible
with the previous public releases, versions 0.1pl2, 0.9.0, 0.9.5, 1.0.0,
1.0.1, 1.0.2 and above, but with the following exception: 0.9.0 and
above can correctly decompress multiple concatenated compressed files.
0.1pl2 cannot do this; it will stop after decompressing just the first
file in the stream.</p>
<p>
<em>bzip2recover</em> versions prior to 1.0.2 used 32-bit integers to represent
bit positions in compressed files, so they could not handle compressed
files more than 512 megabytes long. Versions 1.0.2 and above use 64-bit
ints on some platforms which support them (GNU supported targets, and
Windows). To establish whether or not bzip2recover was built with such a
limitation, run it without arguments. In any event you can build
yourself an unlimited version if you can recompile it with MaybeUInt64
set to be an unsigned 64-bit integer.</p>
</div>
</div>
<div id="outline-container-headline-9" class="outline-2">
<h2 id="headline-9">
AUTHOR
</h2>
<div id="outline-text-headline-9" class="outline-text-2">
<p>Julian Seward, jseward@acm.org.</p>
<p>
https://sourceware.org/bzip2/</p>
<p>
The ideas embodied in <em>bzip2</em> are due to (at least) the following
people: Michael Burrows and David Wheeler (for the block sorting
transformation), David Wheeler (again, for the Huffman coder), Peter
Fenwick (for the structured coding model in the original <em>bzip,</em> and
many refinements), and Alistair Moffat, Radford Neal and Ian Witten (for
the arithmetic coder in the original <em>bzip).</em> I am much indebted for
their help, support and advice. See the manual in the source
distribution for pointers to sources of documentation. Christian von
Roques encouraged me to look for faster sorting algorithms, so as to
speed up compression. Bela Lubkin encouraged me to improve the
worst-case compression performance. Donna Robinson XMLised the
documentation. The bz* scripts are derived from those of GNU gzip. Many
people sent patches, helped with portability problems, lent machines,
gave advice and were generally helpful.</p>
</div>
</div>


        </main>
        <footer class="container footer">
            <p>Copyright 2024. All rights reserved.</p>

        </footer>

        
        

        
            <script src="/js/main.js"></script>
    </body>
</html>
